(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{430:function(e,t,a){"use strict";a.r(t);var n=a(56),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_10-8-压缩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-8-压缩"}},[e._v("#")]),e._v(" 10.8 压缩")]),e._v(" "),a("p",[e._v("Java 1.1也添加一个类，用以支持对压缩格式的数据流的读写。它们封装到现成的IO类中，以提供压缩功能。")]),e._v(" "),a("p",[e._v("此时Java 1.1的一个问题显得非常突出：它们不是从新的"),a("code",[e._v("Reader")]),e._v("和"),a("code",[e._v("Writer")]),e._v("类派生出来的，而是属于"),a("code",[e._v("InputStream")]),e._v("和"),a("code",[e._v("OutputStream")]),e._v("层次结构的一部分。所以有时不得不混合使用两种类型的数据流（注意可用"),a("code",[e._v("InputStreamReader")]),e._v("和"),a("code",[e._v("OutputStreamWriter")]),e._v("在不同的类型间方便地进行转换）。")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Java 1.1压缩类")]),e._v(" "),a("th",[e._v("功能")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("CheckedInputStream")])]),e._v(" "),a("td",[a("code",[e._v("GetCheckSum()")]),e._v("为任何"),a("code",[e._v("InputStream")]),e._v("产生校验和（不仅是解压）")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("CheckedOutputStream")])]),e._v(" "),a("td",[a("code",[e._v("GetCheckSum()")]),e._v("为任何"),a("code",[e._v("OutputStream")]),e._v("产生校验和（不仅是解压）")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("DeflaterOutputStream")])]),e._v(" "),a("td",[e._v("用于压缩类的基类")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("ZipOutputStream")])]),e._v(" "),a("td",[e._v("一个"),a("code",[e._v("DeflaterOutputStream")]),e._v("，将数据压缩成Zip文件格式")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("GZIPOutputStream")])]),e._v(" "),a("td",[e._v("一个"),a("code",[e._v("DeflaterOutputStream")]),e._v("，将数据压缩成GZIP文件格式")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("InflaterInputStream")])]),e._v(" "),a("td",[e._v("用于解压类的基类")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("ZipInputStream")])]),e._v(" "),a("td",[e._v("一个"),a("code",[e._v("DeflaterInputStream")]),e._v("，解压用Zip文件格式保存的数据")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("GZIPInputStream")])]),e._v(" "),a("td",[e._v("一个"),a("code",[e._v("DeflaterInputStream")]),e._v("，解压用GZIP文件格式保存的数据")])])])]),e._v(" "),a("p",[e._v("尽管存在许多种压缩算法，但是Zip和GZIP可能最常用的。所以能够很方便地用多种现成的工具来读写这些格式的压缩数据。")]),e._v(" "),a("h2",{attrs:{id:"_10-8-1-用gzip进行简单压缩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-8-1-用gzip进行简单压缩"}},[e._v("#")]),e._v(" 10.8.1 用GZIP进行简单压缩")]),e._v(" "),a("p",[e._v("GZIP接口非常简单，所以如果只有单个数据流需要压缩（而不是一系列不同的数据），那么它就可能是最适当选择。下面是对单个文件进行压缩的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//: GZIPcompress.java\n// Uses Java 1.1 GZIP compression to compress\n// a file whose name is passed on the command\n// line.\nimport java.io.*;\nimport java.util.zip.*;\n\npublic class GZIPcompress {\n  public static void main(String[] args) {\n    try {\n      BufferedReader in =\n        new BufferedReader(\n          new FileReader(args[0]));\n      BufferedOutputStream out =\n        new BufferedOutputStream(\n          new GZIPOutputStream(\n            new FileOutputStream("test.gz")));\n      System.out.println("Writing file");\n      int c;\n      while((c = in.read()) != -1)\n        out.write(c);\n      in.close();\n      out.close();\n      System.out.println("Reading file");\n      BufferedReader in2 =\n        new BufferedReader(\n          new InputStreamReader(\n            new GZIPInputStream(\n              new FileInputStream("test.gz"))));\n      String s;\n      while((s = in2.readLine()) != null)\n        System.out.println(s);\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n} ///:~\n')])])]),a("p",[e._v("压缩类的用法非常直观——只需将输出流封装到一个"),a("code",[e._v("GZIPOutputStream")]),e._v("或者"),a("code",[e._v("ZipOutputStream")]),e._v("内，并将输入流封装到"),a("code",[e._v("GZIPInputStream")]),e._v("或者"),a("code",[e._v("ZipInputStream")]),e._v("内即可。剩余的全部操作就是标准的IO读写。然而，这是一个很典型的例子，我们不得不混合使用新旧IO流：数据的输入使用"),a("code",[e._v("Reader")]),e._v("类，而"),a("code",[e._v("GZIPOutputStream")]),e._v("的构造器只能接收一个"),a("code",[e._v("OutputStream")]),e._v("对象，不能接收"),a("code",[e._v("Writer")]),e._v("对象。")]),e._v(" "),a("h2",{attrs:{id:"_10-8-2-用zip进行多文件保存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-8-2-用zip进行多文件保存"}},[e._v("#")]),e._v(" 10.8.2 用Zip进行多文件保存")]),e._v(" "),a("p",[e._v("提供了Zip支持的Java 1.1库显得更加全面。利用它可以方便地保存多个文件。甚至有一个独立的类来简化对Zip文件的读操作。这个库采采用的是标准Zip格式，所以能与当前因特网上使用的大量压缩、解压工具很好地协作。下面这个例子采取了与前例相同的形式，但能根据我们需要控制任意数量的命令行参数。除此之外，它展示了如何用"),a("code",[e._v("Checksum")]),e._v("类来计算和校验文件的“校验和”（"),a("code",[e._v("Checksum")]),e._v("）。可选用两种类型的"),a("code",[e._v("Checksum")]),e._v("："),a("code",[e._v("Adler32")]),e._v("（速度要快一些）和"),a("code",[e._v("CRC32")]),e._v("（慢一些，但更准确）。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//: ZipCompress.java\n// Uses Java 1.1 Zip compression to compress\n// any number of files whose names are passed\n// on the command line.\nimport java.io.*;\nimport java.util.*;\nimport java.util.zip.*;\n\npublic class ZipCompress {\n  public static void main(String[] args) {\n    try {\n      FileOutputStream f =\n        new FileOutputStream("test.zip");\n      CheckedOutputStream csum =\n        new CheckedOutputStream(\n          f, new Adler32());\n      ZipOutputStream out =\n        new ZipOutputStream(\n          new BufferedOutputStream(csum));\n      out.setComment("A test of Java Zipping");\n      // Can\'t read the above comment, though\n      for(int i = 0; i < args.length; i++) {\n        System.out.println(\n          "Writing file " + args[i]);\n        BufferedReader in =\n          new BufferedReader(\n            new FileReader(args[i]));\n        out.putNextEntry(new ZipEntry(args[i]));\n        int c;\n        while((c = in.read()) != -1)\n          out.write(c);\n        in.close();\n      }\n      out.close();\n      // Checksum valid only after the file\n      // has been closed!\n      System.out.println("Checksum: " +\n        csum.getChecksum().getValue());\n      // Now extract the files:\n      System.out.println("Reading file");\n      FileInputStream fi =\n         new FileInputStream("test.zip");\n      CheckedInputStream csumi =\n        new CheckedInputStream(\n          fi, new Adler32());\n      ZipInputStream in2 =\n        new ZipInputStream(\n          new BufferedInputStream(csumi));\n      ZipEntry ze;\n      System.out.println("Checksum: " +\n        csumi.getChecksum().getValue());\n      while((ze = in2.getNextEntry()) != null) {\n        System.out.println("Reading file " + ze);\n        int x;\n        while((x = in2.read()) != -1)\n          System.out.write(x);\n      }\n      in2.close();\n      // Alternative way to open and read\n      // zip files:\n      ZipFile zf = new ZipFile("test.zip");\n      Enumeration e = zf.entries();\n      while(e.hasMoreElements()) {\n        ZipEntry ze2 = (ZipEntry)e.nextElement();\n        System.out.println("File: " + ze2);\n        // ... and extract the data as before\n      }\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n} ///:~\n')])])]),a("p",[e._v("对于要加入压缩档的每一个文件，都必须调用"),a("code",[e._v("putNextEntry()")]),e._v("，并将其传递给一个"),a("code",[e._v("ZipEntry")]),e._v("对象。"),a("code",[e._v("ZipEntry")]),e._v("对象包含了一个功能全面的接口，利用它可以获取和设置Zip文件内那个特定的"),a("code",[e._v("Entry")]),e._v("（入口）上能够接受的所有数据：名字、压缩后和压缩前的长度、日期、CRC校验和、额外字段的数据、注释、压缩方法以及它是否一个目录入口等等。然而，虽然Zip格式提供了设置密码的方法，但Java的Zip库没有提供这方面的支持。而且尽管"),a("code",[e._v("CheckedInputStream")]),e._v("和"),a("code",[e._v("CheckedOutputStream")]),e._v("同时提供了对"),a("code",[e._v("Adler32")]),e._v("和"),a("code",[e._v("CRC32")]),e._v("校验和的支持，但是"),a("code",[e._v("ZipEntry")]),e._v("只支持CRC的接口。这虽然属于基层Zip格式的限制，但却限制了我们使用速度更快的"),a("code",[e._v("Adler32")]),e._v("。")]),e._v(" "),a("p",[e._v("为解压文件，"),a("code",[e._v("ZipInputStream")]),e._v("提供了一个"),a("code",[e._v("getNextEntry()")]),e._v("方法，能在有的前提下返回下一个"),a("code",[e._v("ZipEntry")]),e._v("。作为一个更简洁的方法，可以用"),a("code",[e._v("ZipFile")]),e._v("对象读取文件。该对象有一个"),a("code",[e._v("entries()")]),e._v("方法，可以为"),a("code",[e._v("ZipEntry")]),e._v("返回一个"),a("code",[e._v("Enumeration")]),e._v("（枚举）。")]),e._v(" "),a("p",[e._v("为读取校验和，必须多少拥有对关联的"),a("code",[e._v("Checksum")]),e._v("对象的访问权限。在这里保留了指向"),a("code",[e._v("CheckedOutputStream")]),e._v("和"),a("code",[e._v("CheckedInputStream")]),e._v("对象的一个引用。但是，也可以只占有指向"),a("code",[e._v("Checksum")]),e._v("对象的一个引用。")]),e._v(" "),a("p",[e._v("Zip流中一个令人困惑的方法是"),a("code",[e._v("setComment()")]),e._v("。正如前面展示的那样，我们可在写一个文件时设置注释内容，但却没有办法取出"),a("code",[e._v("ZipInputStream")]),e._v("内的注释。看起来，似乎只能通过"),a("code",[e._v("ZipEntry")]),e._v("逐个入口地提供对注释的完全支持。")]),e._v(" "),a("p",[e._v("当然，使用GZIP或Zip库时并不仅仅限于文件——可以压缩任何东西，包括要通过网络连接发送的数据。")]),e._v(" "),a("h2",{attrs:{id:"_10-8-3-java归档-jar-实用程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-8-3-java归档-jar-实用程序"}},[e._v("#")]),e._v(" 10.8.3 Java归档（"),a("code",[e._v("jar")]),e._v("）实用程序")]),e._v(" "),a("p",[e._v("Zip格式亦在Java 1.1的JAR（Java ARchive）文件格式中得到了采用。这种文件格式的作用是将一系列文件合并到单个压缩文件里，就象Zip那样。然而，同Java中其他任何东西一样，JAR文件是跨平台的，所以不必关心涉及具体平台的问题。除了可以包括声音和图像文件以外，也可以在其中包括类文件。")]),e._v(" "),a("p",[e._v("涉及因特网应用时，JAR文件显得特别有用。在JAR文件之前，Web浏览器必须重复多次请求Web服务器，以便下载完构成一个“程序片”（Applet）的所有文件。除此以外，每个文件都是未经压缩的。但在将所有这些文件合并到一个JAR文件里以后，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，所以可在更短的时间里获得全部数据。另外，JAR文件里的每个入口（条目）都可以加上数字化签名（详情参考Java用户文档）。")]),e._v(" "),a("p",[e._v("一个JAR文件由一系列采用Zip压缩格式的文件构成，同时还有一张“详情单”，对所有这些文件进行了描述（可创建自己的详情单文件；否则，"),a("code",[e._v("jar")]),e._v("程序会为我们代劳）。在联机用户文档中，可以找到与JAR详情单更多的资料（详情单的英语是“Manifest”）。\n"),a("code",[e._v("jar")]),e._v("实用程序已与Sun的JDK配套提供，可以按我们的选择自动压缩文件。请在命令行调用它：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("jar [选项] 说明 [详情单] 输入文件\n")])])]),a("p",[e._v("其中，“选项”用一系列字母表示（不必输入连字号或其他任何指示符）。如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c 创建新的或空的压缩档\nt 列出目录表\nx 解压所有文件\nx file 解压指定文件\nf 指出“我准备向你提供文件名”。若省略此参数，jar会假定它的输入来自标准输入；或者在它创建文件时，输出会进入标准输出内\nm 指出第一个参数将是用户自建的详情表文件的名字\nv 产生详细输出，对jar做的工作进行巨细无遗的描述\nO 只保存文件；不压缩文件（用于创建一个JAR文件，以便我们将其置入自己的类路径中）\nM 不自动生成详情表文件\n")])])]),a("p",[e._v("在准备进入JAR文件的文件中，若包括了一个子目录，那个子目录会自动添加，其中包括它自己的所有子目录，以此类推。路径信息也会得到保留。")]),e._v(" "),a("p",[e._v("下面是调用"),a("code",[e._v("jar")]),e._v("的一些典型方法：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("jar cf myJarFile.jar *.class\n")])])]),a("p",[e._v("用于创建一个名为"),a("code",[e._v("myJarFile.jar")]),e._v("的JAR文件，其中包含了当前目录中的所有类文件，同时还有自动产生的详情表文件。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("jar cmf myJarFile.jar myManifestFile.mf *.class\n")])])]),a("p",[e._v("与前例类似，但添加了一个名为"),a("code",[e._v("myManifestFile.mf")]),e._v("的用户自建详情表文件。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("jar tf myJarFile.jar\n")])])]),a("p",[e._v("生成"),a("code",[e._v("myJarFile.jar")]),e._v("内所有文件的一个目录表。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("jar tvf myJarFile.jar\n")])])]),a("p",[e._v("添加"),a("code",[e._v("verbose")]),e._v("（详尽）标志，提供与"),a("code",[e._v("myJarFile.jar")]),e._v("中的文件有关的、更详细的资料。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("jar cvf myApp.jar audio classes image\n")])])]),a("p",[e._v("假定"),a("code",[e._v("audio")]),e._v("，"),a("code",[e._v("classes")]),e._v("和"),a("code",[e._v("image")]),e._v("是子目录，这样便将所有子目录合并到文件"),a("code",[e._v("myApp.jar")]),e._v("中。其中也包括了"),a("code",[e._v("verbose")]),e._v("标志，可在"),a("code",[e._v("jar")]),e._v("程序工作时反馈更详尽的信息。")]),e._v(" "),a("p",[e._v("如果用O选项创建了一个JAR文件，那个文件就可置入自己的类路径（"),a("code",[e._v("CLASSPATH")]),e._v("）中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('CLASSPATH="lib1.jar;lib2.jar;"\n')])])]),a("p",[e._v("Java能在"),a("code",[e._v("lib1.jar")]),e._v("和"),a("code",[e._v("lib2.jar")]),e._v("中搜索目标类文件。")]),e._v(" "),a("p",[a("code",[e._v("jar")]),e._v("工具的功能没有"),a("code",[e._v("zip")]),e._v("工具那么丰富。例如，不能够添加或更新一个现成JAR文件中的文件，只能从头开始新建一个JAR文件。此外，不能将文件移入一个JAR文件，并在移动后将它们删除。然而，在一种平台上创建的JAR文件可在其他任何平台上由"),a("code",[e._v("jar")]),e._v("工具毫无阻碍地读出（这个问题有时会困扰"),a("code",[e._v("zip")]),e._v("工具）。")]),e._v(" "),a("p",[e._v("正如大家在第13章会看到的那样，我们也用JAR为Java Beans打包。")])])}),[],!1,null,null,null);t.default=v.exports}}]);