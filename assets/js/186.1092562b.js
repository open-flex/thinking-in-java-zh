(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{582:function(v,t,_){"use strict";_.r(t);var a=_(56),e=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"附录d-性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#附录d-性能"}},[v._v("#")]),v._v(" 附录D 性能")]),v._v(" "),_("p",[v._v("“本附录由Joe Sharp投稿，并获得他的同意在这儿转载。请联系"),_("code",[v._v("SharpJoe@aol.com")]),v._v("”")]),v._v(" "),_("p",[v._v("Java语言特别强调准确性，但可靠的行为要以性能作为代价。这一特点反映在自动收集垃圾、严格的运行期检查、完整的字节码检查以及保守的运行期同步等等方面。对一个解释型的虚拟机来说，由于目前有大量平台可供挑选，所以进一步阻碍了性能的发挥。\n“先做完它，再逐步完善。幸好需要改进的地方通常不会太多。”（Steve McConnell的《About performance》[16]）\n本附录的宗旨就是指导大家寻找和优化“需要完善的那一部分”。")]),v._v(" "),_("h2",{attrs:{id:"d-1-基本方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-1-基本方法"}},[v._v("#")]),v._v(" D.1 基本方法")]),v._v(" "),_("p",[v._v("只有正确和完整地检测了程序后，再可着手解决性能方面的问题：")]),v._v(" "),_("p",[v._v("(1) 在现实环境中检测程序的性能。若符合要求，则目标达到。若不符合，则转到下一步。")]),v._v(" "),_("p",[v._v("(2) 寻找最致命的性能瓶颈。这也许要求一定的技巧，但所有努力都不会白费。如简单地猜测瓶颈所在，并试图进行优化，那么可能是白花时间。")]),v._v(" "),_("p",[v._v("(3) 运用本附录介绍的提速技术，然后返回步骤1。")]),v._v(" "),_("p",[v._v("为使努力不至白费，瓶颈的定位是至关重要的一环。Donald Knuth[9]曾改进过一个程序，那个程序把50％的时间都花在约4％的代码量上。在仅一个工作小时里，他修改了几行代码，使程序的执行速度倍增。此时，若将时间继续投入到剩余代码的修改上，那么只会得不偿失。Knuth在编程界有一句名言：“过早的优化是万恶之源”（Premature optimization is the root of all evil）。最明智的做法是抑制过早优化的冲动，因为那样做可能遗漏多种有用的编程技术，造成代码更难理解和操控，并需更大的精力进行维护。")]),v._v(" "),_("h2",{attrs:{id:"d-2-寻找瓶颈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-2-寻找瓶颈"}},[v._v("#")]),v._v(" D.2 寻找瓶颈")]),v._v(" "),_("p",[v._v("为找出最影响程序性能的瓶颈，可采取下述几种方法：")]),v._v(" "),_("h3",{attrs:{id:"d-2-1-安插自己的测试代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-2-1-安插自己的测试代码"}},[v._v("#")]),v._v(" D.2.1 安插自己的测试代码")]),v._v(" "),_("p",[v._v("插入下述“显式”计时代码，对程序进行评测：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("long start = System.currentTimeMillis();\n// 要计时的运算代码放在这儿\nlong time = System.currentTimeMillis() - start;\n")])])]),_("p",[v._v("利用"),_("code",[v._v("System.out.println()")]),v._v("，让一种不常用到的方法将累积时间打印到控制台窗口。由于一旦出错，编译器会将其忽略，所以可用一个“静态最终布尔值”（"),_("code",[v._v("Static final boolean")]),v._v("）打开或关闭计时，使代码能放心留在最终发行的程序里，这样任何时候都可以拿来应急。尽管还可以选用更复杂的评测手段，但若仅仅为了量度一个特定任务的执行时间，这无疑是最简便的方法。")]),v._v(" "),_("p",[_("code",[v._v("System.currentTimeMillis()")]),v._v("返回的时间以千分之一秒（1毫秒）为单位。然而，有些系统的时间精度低于1毫秒（如Windows PC），所以需要重复"),_("code",[v._v("n")]),v._v("次，再将总时间除以"),_("code",[v._v("n")]),v._v("，获得准确的时间。")]),v._v(" "),_("h3",{attrs:{id:"d-2-2-jdk性能评测-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-2-2-jdk性能评测-2"}},[v._v("#")]),v._v(" D.2.2 JDK性能评测[2]")]),v._v(" "),_("p",[v._v("JDK配套提供了一个内建的评测程序，能跟踪花在每个例程上的时间，并将评测结果写入一个文件。不幸的是，JDK评测器并不稳定。它在JDK 1.1.1中能正常工作，但在后续版本中却非常不稳定。")]),v._v(" "),_("p",[v._v("为运行评测程序，请在调用Java解释器的未优化版本时加上"),_("code",[v._v("-prof")]),v._v("选项。例如：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("java_g -prof myClass\n")])])]),_("p",[v._v("或加上一个程序片（Applet）：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("java_g -prof sun.applet.AppletViewer applet.html\n")])])]),_("p",[v._v("理解评测程序的输出信息并不容易。事实上，在JDK 1.0中，它居然将方法名称截短为30字符。所以可能无法区分出某些方法。然而，若您用的平台确实能支持"),_("code",[v._v("-prof")]),v._v("选项，那么可试试Vladimir Bulatov的“HyperPorf”[3]或者Greg White的“ProfileViewer”来解释一下结果。")]),v._v(" "),_("h3",{attrs:{id:"d-2-3-特殊工具"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-2-3-特殊工具"}},[v._v("#")]),v._v(" D.2.3 特殊工具")]),v._v(" "),_("p",[v._v("如果想随时跟上性能优化工具的潮流，最好的方法就是作一些Web站点的常客。比如由Jonathan Hardwick制作的“Tools for Optimizing Java”（Java优化工具）网站：")]),v._v(" "),_("p",[v._v("http://www.cs.cmu.edu/~jch/java/tools.html")]),v._v(" "),_("h3",{attrs:{id:"d-2-4-性能评测的技巧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-2-4-性能评测的技巧"}},[v._v("#")]),v._v(" D.2.4 性能评测的技巧")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("由于评测时要用到系统时钟，所以当时不要运行其他任何进程或应用程序，以免影响测试结果。")])]),v._v(" "),_("li",[_("p",[v._v("如对自己的程序进行了修改，并试图（至少在开发平台上）改善它的性能，那么在修改前后应分别测试一下代码的执行时间。")])]),v._v(" "),_("li",[_("p",[v._v("尽量在完全一致的环境中进行每一次时间测试。")])]),v._v(" "),_("li",[_("p",[v._v("如果可能，应设计一个不依赖任何用户输入的测试，避免用户的不同反应导致结果出现误差。")])])]),v._v(" "),_("h2",{attrs:{id:"d-3-提速方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-3-提速方法"}},[v._v("#")]),v._v(" D.3 提速方法")]),v._v(" "),_("p",[v._v("现在，关键的性能瓶颈应已隔离出来。接下来，可对其应用两种类型的优化：常规手段以及依赖Java语言。")]),v._v(" "),_("h3",{attrs:{id:"d-3-1-常规手段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-3-1-常规手段"}},[v._v("#")]),v._v(" D.3.1 常规手段")]),v._v(" "),_("p",[v._v("通常，一个有效的提速方法是用更现实的方式重新定义程序。例如，在《Programming Pearls》（编程珠玑）一书中[14]，Bentley利用了一段小说数据描写，它可以生成速度非常快、而且非常精简的拼写检查器，从而介绍了Doug McIlroy对英语语言的表述。除此以外，与其他方法相比，更好的算法也许能带来更大的性能提升——特别是在数据集的尺寸越来越大的时候。欲了解这些常规手段的详情，请参考本附录末尾的“一般书籍”清单。")]),v._v(" "),_("h3",{attrs:{id:"d-3-2-依赖语言的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-3-2-依赖语言的方法"}},[v._v("#")]),v._v(" D.3.2 依赖语言的方法")]),v._v(" "),_("p",[v._v("为进行客观的分析，最好明确掌握各种运算的执行时间。这样一来，得到的结果可独立于当前使用的计算机——通过除以花在本地赋值上的时间，最后得到的就是“标准时间”。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("运算")]),v._v(" "),_("th",[v._v("示例")]),v._v(" "),_("th",[v._v("标准时间")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("本地赋值")]),v._v(" "),_("td",[_("code",[v._v("i=n;")])]),v._v(" "),_("td",[v._v("1.0")])]),v._v(" "),_("tr",[_("td",[v._v("实例赋值")]),v._v(" "),_("td",[_("code",[v._v("this.i=n;")])]),v._v(" "),_("td",[v._v("1.2")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("int")]),v._v("自增")]),v._v(" "),_("td",[_("code",[v._v("i++;")])]),v._v(" "),_("td",[v._v("1.5")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("byte")]),v._v("自增")]),v._v(" "),_("td",[_("code",[v._v("b++;")])]),v._v(" "),_("td",[v._v("2.0")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("short")]),v._v("自增")]),v._v(" "),_("td",[_("code",[v._v("s++;")])]),v._v(" "),_("td",[v._v("2.0")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("float")]),v._v("自增")]),v._v(" "),_("td",[_("code",[v._v("f++;")])]),v._v(" "),_("td",[v._v("2.0")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("double")]),v._v("自增")]),v._v(" "),_("td",[_("code",[v._v("d++;")])]),v._v(" "),_("td",[v._v("2.0")])]),v._v(" "),_("tr",[_("td",[v._v("空循环")]),v._v(" "),_("td",[_("code",[v._v("while(true) n++;")])]),v._v(" "),_("td",[v._v("2.0")])]),v._v(" "),_("tr",[_("td",[v._v("三元表达式")]),v._v(" "),_("td",[_("code",[v._v("(x<0) ?-x : x")])]),v._v(" "),_("td",[v._v("2.2")])]),v._v(" "),_("tr",[_("td",[v._v("算术调用")]),v._v(" "),_("td",[_("code",[v._v("Math.abs(x);")])]),v._v(" "),_("td",[v._v("2.5")])]),v._v(" "),_("tr",[_("td",[v._v("数组赋值")]),v._v(" "),_("td",[v._v("a[0] = n;")]),v._v(" "),_("td",[v._v("2.7")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("long")]),v._v("自增")]),v._v(" "),_("td",[v._v("l++;")]),v._v(" "),_("td",[v._v("3.5")])]),v._v(" "),_("tr",[_("td",[v._v("方法调用")]),v._v(" "),_("td",[_("code",[v._v("funct();")])]),v._v(" "),_("td",[v._v("5.9")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("throw")]),v._v("或"),_("code",[v._v("catch")]),v._v("异常")]),v._v(" "),_("td",[_("code",[v._v("try{ throw e; }")]),v._v("或"),_("code",[v._v("catch(e){}")])]),v._v(" "),_("td",[v._v("320")])]),v._v(" "),_("tr",[_("td",[v._v("同步方法调用")]),v._v(" "),_("td",[_("code",[v._v("synchMehod();")])]),v._v(" "),_("td",[v._v("570")])]),v._v(" "),_("tr",[_("td",[v._v("新建对象")]),v._v(" "),_("td",[_("code",[v._v("new Object();")])]),v._v(" "),_("td",[v._v("980")])]),v._v(" "),_("tr",[_("td",[v._v("新建数组")]),v._v(" "),_("td",[_("code",[v._v("new int[10];")])]),v._v(" "),_("td",[v._v("3100")])])])]),v._v(" "),_("p",[v._v("通过自己的系统（如我的Pentium 200 Pro，Netscape 3及JDK 1.1.5），这些相对时间向大家揭示出：新建对象和数组会造成最沉重的开销，同步会造成比较沉重的开销，而一次不同步的方法调用会造成适度的开销。参考资源[5]和[6]为大家总结了测量用程序片的Web地址，可到自己的机器上运行它们。")]),v._v(" "),_("p",[v._v("(1) 常规修改")]),v._v(" "),_("p",[v._v("下面是加快Java程序关键部分执行速度的一些常规操作建议（注意对比修改前后的测试结果）。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("将...")]),v._v(" "),_("th",[v._v("修改成...")]),v._v(" "),_("th",[v._v("理由")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("接口")]),v._v(" "),_("td",[v._v("抽象类（只需一个父时）")]),v._v(" "),_("td",[v._v("接口的多个继承会妨碍性能的优化")])]),v._v(" "),_("tr",[_("td",[v._v("非本地或数组循环变量")]),v._v(" "),_("td",[v._v("本地循环变量")]),v._v(" "),_("td",[v._v("根据前表的耗时比较，一次实例整数赋值的时间是本地整数赋值时间的1.2倍，但数组赋值的时间是本地整数赋值的2.7倍")])]),v._v(" "),_("tr",[_("td",[v._v("链接列表（固定尺寸）")]),v._v(" "),_("td",[v._v("保存丢弃的链接项目，或将列表替换成一个循环数组（大致知道尺寸）")]),v._v(" "),_("td",[v._v("每新建一个对象，都相当于本地赋值980次。参考“重复利用对象”（下一节）、Van Wyk[12] p.87以及Bentley[15] p.81")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("x/2")]),v._v("（或2的任意次幂）")]),v._v(" "),_("td",[_("code",[v._v("X>>2")]),v._v("（或2的任意次幂）")]),v._v(" "),_("td",[v._v("使用更快的硬件指令")])])])]),v._v(" "),_("h3",{attrs:{id:"d-3-3-特殊情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-3-3-特殊情况"}},[v._v("#")]),v._v(" D.3.3 特殊情况")]),v._v(" "),_("ul",[_("li",[v._v("字符串的开销：字符串连接运算符"),_("code",[v._v("+")]),v._v("看似简单，但实际需要消耗大量系统资源。编译器可高效地连接字符串，但变量字符串却要求可观的处理器时间。例如，假设"),_("code",[v._v("s")]),v._v("和"),_("code",[v._v("t")]),v._v("是字符串变量：")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('System.out.println("heading" + s + "trailer" + t);\n')])])]),_("p",[v._v("上述语句要求新建一个"),_("code",[v._v("StringBuffer")]),v._v("（字符串缓冲），追加参数，然后用"),_("code",[v._v("toString()")]),v._v("将结果转换回一个字符串。因此，无论磁盘空间还是处理器时间，都会受到严重消耗。若准备追加多个字符串，则可考虑直接使用一个字符串缓冲——特别是能在一个循环里重复利用它的时候。通过在每次循环里禁止新建一个字符串缓冲，可节省980单位的对象创建时间（如前所述）。利用"),_("code",[v._v("substring()")]),v._v("以及其他字符串方法，可进一步地改善性能。如果可行，字符数组的速度甚至能够更快。也要注意由于同步的关系，所以"),_("code",[v._v("StringTokenizer")]),v._v("会造成较大的开销。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("同步：在JDK解释器中，调用同步方法通常会比调用不同步方法慢10倍。经JIT编译器处理后，这一性能上的差距提升到50到100倍（注意前表总结的时间显示出要慢97倍）。所以要尽可能避免使用同步方法——若不能避免，方法的同步也要比代码块的同步稍快一些。")])]),v._v(" "),_("li",[_("p",[v._v("重复利用对象：要花很长的时间来新建一个对象（根据前表总结的时间，对象的新建时间是赋值时间的980倍，而新建一个小数组的时间是赋值时间的3100倍）。因此，最明智的做法是保存和更新老对象的字段，而不是创建一个新对象。例如，不要在自己的"),_("code",[v._v("paint()")]),v._v("方法中新建一个"),_("code",[v._v("Font")]),v._v("对象。相反，应将其声明成实例对象，再初始化一次。在这以后，可在"),_("code",[v._v("paint()")]),v._v("里需要的时候随时进行更新。参见Bentley编著的《编程珠玑》，p.81[15]。")])]),v._v(" "),_("li",[_("p",[v._v("异常：只有在不正常的情况下，才应放弃异常处理模块。什么才叫“不正常”呢？这通常是指程序遇到了问题，而这一般是不愿见到的，所以性能不再成为优先考虑的目标。进行优化时，将小的"),_("code",[v._v("try-catch")]),v._v("块合并到一起。由于这些块将代码分割成小的、各自独立的片断，所以会妨碍编译器进行优化。另一方面，若过份热衷于删除异常处理模块，也可能造成代码健壮程度的下降。")])]),v._v(" "),_("li",[_("p",[v._v("散列处理：首先，Java 1.0和1.1的标准“散列表”（"),_("code",[v._v("Hashtable")]),v._v("）类需要转换以及特别消耗系统资源的同步处理（570单位的赋值时间）。其次，早期的JDK库不能自动决定最佳的表格尺寸。最后，散列函数应针对实际使用项（"),_("code",[v._v("Key")]),v._v("）的特征设计。考虑到所有这些原因，我们可特别设计一个散列类，令其与特定的应用程序配合，从而改善常规散列表的性能。注意Java 1.2集合库的散列映射（"),_("code",[v._v("HashMap")]),v._v("）具有更大的灵活性，而且不会自动同步。")])]),v._v(" "),_("li",[_("p",[v._v("方法内嵌：只有在方法属于"),_("code",[v._v("final")]),v._v("（最终）、"),_("code",[v._v("private")]),v._v("（专用）或"),_("code",[v._v("static")]),v._v("（静态）的情况下，Java编译器才能内嵌这个方法。而且某些情况下，还要求它绝对不可以有局部变量。若代码花大量时间调用一个不含上述任何属性的方法，那么请考虑为其编写一个"),_("code",[v._v("final")]),v._v("版本。")])]),v._v(" "),_("li",[_("p",[v._v("I/O：应尽可能使用缓冲。否则，最终也许就是一次仅输入／输出一个字节的恶果。注意JDK 1.0的I/O类采用了大量同步措施，所以若使用象"),_("code",[v._v("readFully()")]),v._v("这样的一个“大批量”调用，然后由自己解释数据，就可获得更佳的性能。也要注意Java 1.1的"),_("code",[v._v("reader")]),v._v("和"),_("code",[v._v("writer")]),v._v("类已针对性能进行了优化。")])]),v._v(" "),_("li",[_("p",[v._v("转换和实例：转换会耗去2到200个单位的赋值时间。开销更大的甚至要求上溯继承（遗传）结构。其他高代价的操作会损失和恢复更低层结构的能力。")])]),v._v(" "),_("li",[_("p",[v._v("图形：利用剪切技术，减少在"),_("code",[v._v("repaint()")]),v._v("中的工作量；倍增缓冲区，提高接收速度；同时利用图形压缩技术，缩短下载时间。来自JavaWorld的“Java Applets”以及来自Sun的“Performing Animation”是两个很好的教程。请记着使用最贴切的命令。例如，为根据一系列点画一个多边形，和"),_("code",[v._v("drawLine()")]),v._v("相比，"),_("code",[v._v("drawPolygon()")]),v._v("的速度要快得多。如必须画一条单像素粗细的直线，"),_("code",[v._v("drawLine(x,y,x,y)")]),v._v("的速度比"),_("code",[v._v("fillRect(x,y,1,1)")]),v._v("快。")])]),v._v(" "),_("li",[_("p",[v._v("使用API类：尽量使用来自Java API的类，因为它们本身已针对机器的性能进行了优化。这是用Java难于达到的。比如在复制任意长度的一个数组时，"),_("code",[v._v("arraryCopy()")]),v._v("比使用循环的速度快得多。")])]),v._v(" "),_("li",[_("p",[v._v("替换API类：有些时候，API类提供了比我们希望更多的功能，相应的执行时间也会增加。因此，可定做特别的版本，让它做更少的事情，但可更快地运行。例如，假定一个应用程序需要一个容器来保存大量数组。为加快执行速度，可将原来的"),_("code",[v._v("Vector")]),v._v("（向量）替换成更快的动态对象数组。")])])]),v._v(" "),_("p",[v._v("(1) 其他建议")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("将重复的常数计算移至关键循环之外——比如计算固定长度缓冲区的"),_("code",[v._v("buffer.length")]),v._v("。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("static final")]),v._v("（静态最终）常数有助于编译器优化程序。")])]),v._v(" "),_("li",[_("p",[v._v("实现固定长度的循环。")])]),v._v(" "),_("li",[_("p",[v._v("使用"),_("code",[v._v("javac")]),v._v("的优化选项："),_("code",[v._v("-O")]),v._v("。它通过内嵌"),_("code",[v._v("static")]),v._v("，"),_("code",[v._v("final")]),v._v("以及"),_("code",[v._v("private")]),v._v("方法，从而优化编译过的代码。注意类的长度可能会增加（只对JDK 1.1而言——更早的版本也许不能执行字节查证）。新型的“Just-in-time”（JIT）编译器会动态加速代码。")])]),v._v(" "),_("li",[_("p",[v._v("尽可能地将计数减至0——这使用了一个特殊的JVM字节码。")])])]),v._v(" "),_("h2",{attrs:{id:"d-4-参考资源"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-4-参考资源"}},[v._v("#")]),v._v(" D.4 参考资源")]),v._v(" "),_("h3",{attrs:{id:"d-4-1-性能工具"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-4-1-性能工具"}},[v._v("#")]),v._v(" D.4.1 性能工具")]),v._v(" "),_("p",[v._v("[1] 运行于Pentium Pro 200，Netscape 3.0，JDK 1.1.4的MicroBenchmark（参见下面的参考资源[5]）")]),v._v(" "),_("p",[v._v("[2] Sun的Java文档页——JDK Java解释器主题：")]),v._v(" "),_("p",[v._v("http://java.sun.com/products/JDK/tools/win32/java.html")]),v._v(" "),_("p",[v._v("[3] Vladimir Bulatov的HyperProf")]),v._v(" "),_("p",[v._v("http://www.physics.orst.edu/~bulatov/HyperProf")]),v._v(" "),_("p",[v._v("[4] Greg White的ProfileViewer")]),v._v(" "),_("p",[v._v("http://www.inetmi.com/~gwhi/ProfileViewer/ProfileViewer.html")]),v._v(" "),_("h3",{attrs:{id:"d-4-2-web站点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-4-2-web站点"}},[v._v("#")]),v._v(" D.4.2 Web站点")]),v._v(" "),_("p",[v._v("[5] 对于Java代码的优化主题，最出色的在线参考资源是Jonathan Hardwick的“Java Optimization”网站：")]),v._v(" "),_("p",[v._v("http://www.cs.cmu.edu/~jch/java/optimization.html")]),v._v(" "),_("p",[v._v("“Java优化工具”主页：")]),v._v(" "),_("p",[v._v("http://www.cs.cmu.edu/~jch/java/tools.html")]),v._v(" "),_("p",[v._v("以及“Java Microbenchmarks”（有一个45秒钟的评测过程）：")]),v._v(" "),_("p",[v._v("http://www.cs.cmu.edu/~jch/java/benchmarks.html")]),v._v(" "),_("h3",{attrs:{id:"d-4-3-文章"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-4-3-文章"}},[v._v("#")]),v._v(" D.4.3 文章")]),v._v(" "),_("p",[v._v("[6] “Make Java fast:Optimize! How to get the greatest performanceout of your code through low-level optimizations in Java”（让Java更快：优化！如何通过在Java中的低级优化，使代码发挥最出色的性能）。作者：Doug Bell。网址：")]),v._v(" "),_("p",[v._v("http://www.javaworld.com/javaworld/jw-04-1997/jw-04-optimize.html")]),v._v(" "),_("p",[v._v("（含一个全面的性能评测程序片，有详尽注释）")]),v._v(" "),_("p",[v._v("[7] “Java Optimization Resources”（Java优化资源）")]),v._v(" "),_("p",[v._v("http://www.cs.cmu.edu/~jch/java/resources.html")]),v._v(" "),_("p",[v._v("[8] “Optimizing Java for Speed”（优化Java，提高速度）：")]),v._v(" "),_("p",[v._v("http://www.cs.cmu.edu/~jch/java/speed.html")]),v._v(" "),_("p",[v._v("[9] “An Empirical Study of FORTRAN Programs”（FORTRAN程序实战解析）。作者：Donald Knuth。1971年出版。第1卷，p.105-33，“软件——实践和练习”。")]),v._v(" "),_("p",[v._v("[10] “Building High-Performance Applications and Servers in Java:An Experiential Study”。作者:Jimmy Nguyen，Michael Fraenkel，RichardRedpath，Binh Q. Nguyen以及Sandeep K. Singhal。IBM T.J. Watson ResearchCenter,IBM Software Solutions。")]),v._v(" "),_("p",[v._v("http://www.ibm.com/java/education/javahipr.html")]),v._v(" "),_("h3",{attrs:{id:"d-4-4-java专业书籍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-4-4-java专业书籍"}},[v._v("#")]),v._v(" D.4.4 Java专业书籍")]),v._v(" "),_("p",[v._v("[11] 《Advanced Java，Idioms，Pitfalls，Styles, and Programming Tips》。作者：Chris Laffra。Prentice Hall 1997年出版（Java 1.0）。第11章第20小节。")]),v._v(" "),_("h3",{attrs:{id:"d-4-5-一般书籍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#d-4-5-一般书籍"}},[v._v("#")]),v._v(" D.4.5 一般书籍")]),v._v(" "),_("p",[v._v("[12] 《Data Structures and C Programs》（数据结构和C程序）。作者：J.Van Wyk。Addison-Wesly 1998年出版。")]),v._v(" "),_("p",[v._v("[13] 《Writing Efficient Programs》（编写有效的程序）。作者：Jon Bentley。Prentice Hall 1982年出版。特别参考p.110和p.145-151。")]),v._v(" "),_("p",[v._v("[14] 《More Programming Pearls》（编程珠玑第二版）。作者：JonBentley。“Association for Computing Machinery”，1998年2月。")]),v._v(" "),_("p",[v._v("[15] 《Programming Pearls》（编程珠玑）。作者：Jone Bentley。Addison-Wesley 1989年出版。第2部分强调了常规的性能改善问题。 [16] 《Code Complete:A Practical Handbook of Software Construction》（完整代码索引：实用软件开发手册）。作者：Steve McConnell。Microsoft出版社1993年出版，第9章。")]),v._v(" "),_("p",[v._v("[17] 《Object-Oriented System Development》（面向对象系统的开发）。作者：Champeaux，Lea和Faure。第25章。")]),v._v(" "),_("p",[v._v("[18] 《The Art of Programming》（编程艺术）。作者：Donald Knuth。第1卷“基本算法第3版”；第3卷“排序和搜索第2版”。Addison-Wesley出版。这是有关程序算法的一本百科全书。")]),v._v(" "),_("p",[v._v("[19] 《Algorithms in C:Fundammentals,Data Structures, Sorting,Searching》（C算法：基础、数据结构、排序、搜索）第3版。作者：RobertSedgewick。Addison-Wesley 1997年出版。作者是Knuth的学生。这是专门讨论几种语言的七个版本之一。对算法进行了深入浅出的解释。")])])}),[],!1,null,null,null);t.default=e.exports}}]);