(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{469:function(n,e,t){"use strict";t.r(e);var a=t(56),i=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"_14-2-共享有限的资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-共享有限的资源"}},[n._v("#")]),n._v(" 14.2 共享有限的资源")]),n._v(" "),t("p",[n._v("可将单线程程序想象成一种孤立的实体，它能遍历我们的问题空间，而且一次只能做一件事情。由于只有一个实体，所以永远不必担心会有两个实体同时试图使用相同的资源，就象两个人同时都想停到一个车位，同时都想通过一扇门，甚至同时发话。")]),n._v(" "),t("p",[n._v("进入多线程环境后，它们则再也不是孤立的。可能会有两个甚至更多的线程试图同时同一个有限的资源。必须对这种潜在资源冲突进行预防，否则就可能发生两个线程同时访问一个银行帐号，打印到同一台计算机，以及对同一个值进行调整等等。")]),n._v(" "),t("h2",{attrs:{id:"_14-2-1-资源访问的错误方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-1-资源访问的错误方法"}},[n._v("#")]),n._v(" 14.2.1 资源访问的错误方法")]),n._v(" "),t("p",[n._v("现在考虑换成另一种方式来使用本章频繁见到的计数器。在下面的例子中，每个线程都包含了两个计数器，它们在"),t("code",[n._v("run()")]),n._v("里自增以及显示。除此以外，我们使用了"),t("code",[n._v("Watcher")]),n._v("类的另一个线程。它的作用是监视计数器，检查它们是否保持相等。这表面是一项无意义的行动，因为如果查看代码，就会发现计数器肯定是相同的。但实际情况却不一定如此。下面是程序的第一个版本：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Sharing1.java\n// Problems with resource sharing while threading\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.applet.*;\n\nclass TwoCounter extends Thread {\n  private boolean started = false;\n  private TextField\n    t1 = new TextField(5),\n    t2 = new TextField(5);\n  private Label l =\n    new Label("count1 == count2");\n  private int count1 = 0, count2 = 0;\n  // Add the display components as a panel\n  // to the given container:\n  public TwoCounter(Container c) {\n    Panel p = new Panel();\n    p.add(t1);\n    p.add(t2);\n    p.add(l);\n    c.add(p);\n  }\n  public void start() {\n    if(!started) {\n      started = true;\n      super.start();\n    }\n  }\n  public void run() {\n    while (true) {\n      t1.setText(Integer.toString(count1++));\n      t2.setText(Integer.toString(count2++));\n      try {\n        sleep(500);\n      } catch (InterruptedException e){}\n    }\n  }\n  public void synchTest() {\n    Sharing1.incrementAccess();\n    if(count1 != count2)\n      l.setText("Unsynched");\n  }\n}\n\nclass Watcher extends Thread {\n  private Sharing1 p;\n  public Watcher(Sharing1 p) {\n    this.p = p;\n    start();\n  }\n  public void run() {\n    while(true) {\n      for(int i = 0; i < p.s.length; i++)\n        p.s[i].synchTest();\n      try {\n        sleep(500);\n      } catch (InterruptedException e){}\n    }\n  }\n}\n\npublic class Sharing1 extends Applet {\n  TwoCounter[] s;\n  private static int accessCount = 0;\n  private static TextField aCount =\n    new TextField("0", 10);\n  public static void incrementAccess() {\n    accessCount++;\n    aCount.setText(Integer.toString(accessCount));\n  }\n  private Button\n    start = new Button("Start"),\n    observer = new Button("Observe");\n  private boolean isApplet = true;\n  private int numCounters = 0;\n  private int numObservers = 0;\n  public void init() {\n    if(isApplet) {\n      numCounters =\n        Integer.parseInt(getParameter("size"));\n      numObservers =\n        Integer.parseInt(\n          getParameter("observers"));\n    }\n    s = new TwoCounter[numCounters];\n    for(int i = 0; i < s.length; i++)\n      s[i] = new TwoCounter(this);\n    Panel p = new Panel();\n    start.addActionListener(new StartL());\n    p.add(start);\n    observer.addActionListener(new ObserverL());\n    p.add(observer);\n    p.add(new Label("Access Count"));\n    p.add(aCount);\n    add(p);\n  }\n  class StartL implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n      for(int i = 0; i < s.length; i++)\n        s[i].start();\n    }\n  }\n  class ObserverL implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n      for(int i = 0; i < numObservers; i++)\n        new Watcher(Sharing1.this);\n    }\n  }\n  public static void main(String[] args) {\n    Sharing1 applet = new Sharing1();\n    // This isn\'t an applet, so set the flag and\n    // produce the parameter values from args:\n    applet.isApplet = false;\n    applet.numCounters =\n      (args.length == 0 ? 5 :\n        Integer.parseInt(args[0]));\n    applet.numObservers =\n      (args.length < 2 ? 5 :\n        Integer.parseInt(args[1]));\n    Frame aFrame = new Frame("Sharing1");\n    aFrame.addWindowListener(\n      new WindowAdapter() {\n        public void windowClosing(WindowEvent e){\n          System.exit(0);\n        }\n      });\n    aFrame.add(applet, BorderLayout.CENTER);\n    aFrame.setSize(350, applet.numCounters *100);\n    applet.init();\n    applet.start();\n    aFrame.setVisible(true);\n  }\n} ///:~\n')])])]),t("p",[n._v("和往常一样，每个计数器都包含了自己的显示组件：两个文本字段以及一个标签。根据它们的初始值，可知道计数是相同的。这些组件在"),t("code",[n._v("TwoCounter")]),n._v("构造器加入"),t("code",[n._v("Container")]),n._v("。由于这个线程是通过用户的一个“按下按钮”操作启动的，所以"),t("code",[n._v("start()")]),n._v("可能被多次调用。但对一个线程来说，对"),t("code",[n._v("Thread.start()")]),n._v("的多次调用是非法的（会产生异常）。在"),t("code",[n._v("started")]),n._v("标记和重载的"),t("code",[n._v("start()")]),n._v("方法中，大家可看到针对这一情况采取的防范措施。")]),n._v(" "),t("p",[n._v("在"),t("code",[n._v("run()")]),n._v("中，"),t("code",[n._v("count1")]),n._v("和"),t("code",[n._v("count2")]),n._v("的自增与显示方式表面上似乎能保持它们完全一致。随后会调用"),t("code",[n._v("sleep()")]),n._v("；若没有这个调用，程序便会出错，因为那会造成CPU难于交换任务。")]),n._v(" "),t("p",[t("code",[n._v("synchTest()")]),n._v("方法采取的似乎是没有意义的行动，它检查"),t("code",[n._v("count1")]),n._v("是否等于"),t("code",[n._v("count2")]),n._v("；如果不等，就把标签设为"),t("code",[n._v('"Unsynched"')]),n._v("（不同步）。但是首先，它调用的是类"),t("code",[n._v("Sharing1")]),n._v("的一个静态成员，以便自增和显示一个访问计数器，指出这种检查已成功进行了多少次（这样做的理由会在本例的其他版本中变得非常明显）。")]),n._v(" "),t("p",[t("code",[n._v("Watcher")]),n._v("类是一个线程，它的作用是为处于活动状态的所有"),t("code",[n._v("TwoCounter")]),n._v("对象都调用"),t("code",[n._v("synchTest()")]),n._v("。其间，它会对"),t("code",[n._v("Sharing1")]),n._v("对象中容纳的数组进行遍历。可将"),t("code",[n._v("Watcher")]),n._v("想象成它掠过"),t("code",[n._v("TwoCounter")]),n._v("对象的肩膀不断地“偷看”。")]),n._v(" "),t("p",[t("code",[n._v("Sharing1")]),n._v("包含了"),t("code",[n._v("TwoCounter")]),n._v("对象的一个数组，它通过"),t("code",[n._v("init()")]),n._v("进行初始化，并在我们按下"),t("code",[n._v('"start"')]),n._v("按钮后作为线程启动。以后若按下"),t("code",[n._v('"Observe"')]),n._v("（观察）按钮，就会创建一个或者多个观察器，并对毫不设防的"),t("code",[n._v("TwoCounter")]),n._v("进行调查。")]),n._v(" "),t("p",[n._v("注意为了让它作为一个程序片在浏览器中运行，Web页需要包含下面这几行：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<applet code=Sharing1 width=650 height=500>\n<param name=size value="20">\n<param name=observers value="1">\n</applet>\n')])])]),t("p",[n._v("可自行改变宽度、高度以及参数，根据自己的意愿进行试验。若改变了"),t("code",[n._v("size")]),n._v("和"),t("code",[n._v("observers")]),n._v("，程序的行为也会发生变化。我们也注意到，通过从命令行接受参数（或者使用默认值），它被设计成作为一个独立的应用程序运行。")]),n._v(" "),t("p",[n._v("下面才是最让人“不可思议”的。在"),t("code",[n._v("TwoCounter.run()")]),n._v("中，无限循环只是不断地重复相邻的行：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("t1.setText(Integer.toString(count1++));\nt2.setText(Integer.toString(count2++));\n")])])]),t("p",[n._v("（和“睡眠”一样，不过在这里并不重要）。但在程序运行的时候，你会发现"),t("code",[n._v("count1")]),n._v("和"),t("code",[n._v("count2")]),n._v("被“观察”（用"),t("code",[n._v("Watcher")]),n._v("观察）的次数是不相等的！这是由线程的本质造成的——它们可在任何时候挂起（暂停）。所以在上述两行的执行时刻之间，有时会出现执行暂停现象。同时，"),t("code",[n._v("Watcher")]),n._v("线程也正好跟随着进来，并正好在这个时候进行比较，造成计数器出现不相等的情况。")]),n._v(" "),t("p",[n._v("本例揭示了使用线程时一个非常基本的问题。我们跟无从知道一个线程什么时候运行。想象自己坐在一张桌子前面，桌上放有一把叉子，准备叉起自己的最后一块食物。当叉子要碰到食物时，食物却突然消失了（因为这个线程已被挂起，同时另一个线程进来“偷”走了食物）。这便是我们要解决的问题。")]),n._v(" "),t("p",[n._v("有的时候，我们并不介意一个资源在尝试使用它的时候是否正被访问（食物在另一些盘子里）。但为了让多线程机制能够正常运转，需要采取一些措施来防止两个线程访问相同的资源——至少在关键的时期。")]),n._v(" "),t("p",[n._v("为防止出现这样的冲突，只需在线程使用一个资源时为其加锁即可。访问资源的第一个线程会其加上锁以后，其他线程便不能再使用那个资源，除非被解锁。如果车子的前座是有限的资源，高喊“这是我的！”的孩子会主张把它锁起来。")]),n._v(" "),t("h2",{attrs:{id:"_14-2-2-java如何共享资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-2-java如何共享资源"}},[n._v("#")]),n._v(" 14.2.2 Java如何共享资源")]),n._v(" "),t("p",[n._v("对一种特殊的资源——对象中的内存——Java提供了内建的机制来防止它们的冲突。由于我们通常将数据元素设为从属于"),t("code",[n._v("private")]),n._v("（私有）类，然后只通过方法访问那些内存，所以只需将一个特定的方法设为"),t("code",[n._v("synchronized")]),n._v("（同步的），便可有效地防止冲突。在任何时刻，只可有一个线程调用特定对象的一个"),t("code",[n._v("synchronized")]),n._v("方法（尽管那个线程可以调用多个对象的同步方法）。下面列出简单的s"),t("code",[n._v("ynchronized")]),n._v("方法：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("synchronized void f() { /* ... */ }\nsynchronized void g() { /* ... */ }\n")])])]),t("p",[n._v("每个对象都包含了一把锁（也叫作“监视器”），它自动成为对象的一部分（不必为此写任何特殊的代码）。调用任何"),t("code",[n._v("synchronized")]),n._v("方法时，对象就会被锁定，不可再调用那个对象的其他任何"),t("code",[n._v("synchronized")]),n._v("方法，除非第一个方法完成了自己的工作，并解除锁定。在上面的例子中，如果为一个对象调用"),t("code",[n._v("f()")]),n._v("，便不能再为同样的对象调用"),t("code",[n._v("g()")]),n._v("，除非"),t("code",[n._v("f()")]),n._v("完成并解除锁定。因此，一个特定对象的所有"),t("code",[n._v("synchronized")]),n._v("方法都共享着一把锁，而且这把锁能防止多个方法对通用内存同时进行写操作（比如同时有多个线程）。")]),n._v(" "),t("p",[n._v("每个类也有自己的一把锁（作为类的"),t("code",[n._v("Class")]),n._v("对象的一部分），所以"),t("code",[n._v("synchronized static")]),n._v("方法可在一个类的范围内被相互间锁定起来，防止与"),t("code",[n._v("static")]),n._v("数据的接触。")]),n._v(" "),t("p",[n._v("注意如果想保护其他某些资源不被多个线程同时访问，可以强制通过"),t("code",[n._v("synchronized")]),n._v("方访问那些资源。")]),n._v(" "),t("p",[n._v("(1) 计数器的同步")]),n._v(" "),t("p",[n._v("装备了这个新关键字后，我们能够采取的方案就更灵活了：可以只为"),t("code",[n._v("TwoCounter")]),n._v("中的方法简单地使用"),t("code",[n._v("synchronized")]),n._v("关键字。下面这个例子是对前例的改版，其中加入了新的关键字：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Sharing2.java\n// Using the synchronized keyword to prevent\n// multiple access to a particular resource.\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.applet.*;\n\nclass TwoCounter2 extends Thread {\n  private boolean started = false;\n  private TextField\n    t1 = new TextField(5),\n    t2 = new TextField(5);\n  private Label l =\n    new Label("count1 == count2");\n  private int count1 = 0, count2 = 0;\n  public TwoCounter2(Container c) {\n    Panel p = new Panel();\n    p.add(t1);\n    p.add(t2);\n    p.add(l);\n    c.add(p);\n  }    \n  public void start() {\n    if(!started) {\n      started = true;\n      super.start();\n    }\n  }\n  public synchronized void run() {\n    while (true) {\n      t1.setText(Integer.toString(count1++));\n      t2.setText(Integer.toString(count2++));\n      try {\n        sleep(500);\n      } catch (InterruptedException e){}\n    }\n  }\n  public synchronized void synchTest() {\n    Sharing2.incrementAccess();\n    if(count1 != count2)\n      l.setText("Unsynched");\n  }\n}\n\nclass Watcher2 extends Thread {\n  private Sharing2 p;\n  public Watcher2(Sharing2 p) {\n    this.p = p;\n    start();\n  }\n  public void run() {\n    while(true) {\n      for(int i = 0; i < p.s.length; i++)\n        p.s[i].synchTest();\n      try {\n        sleep(500);\n      } catch (InterruptedException e){}\n    }\n  }\n}\n\npublic class Sharing2 extends Applet {\n  TwoCounter2[] s;\n  private static int accessCount = 0;\n  private static TextField aCount =\n    new TextField("0", 10);\n  public static void incrementAccess() {\n    accessCount++;\n    aCount.setText(Integer.toString(accessCount));\n  }\n  private Button\n    start = new Button("Start"),\n    observer = new Button("Observe");\n  private boolean isApplet = true;\n  private int numCounters = 0;\n  private int numObservers = 0;\n  public void init() {\n    if(isApplet) {\n      numCounters =\n        Integer.parseInt(getParameter("size"));\n      numObservers =\n        Integer.parseInt(\n          getParameter("observers"));\n    }\n    s = new TwoCounter2[numCounters];\n    for(int i = 0; i < s.length; i++)\n      s[i] = new TwoCounter2(this);\n    Panel p = new Panel();\n    start.addActionListener(new StartL());\n    p.add(start);\n    observer.addActionListener(new ObserverL());\n    p.add(observer);\n    p.add(new Label("Access Count"));\n    p.add(aCount);\n    add(p);\n  }\n  class StartL implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n      for(int i = 0; i < s.length; i++)\n        s[i].start();\n    }\n  }\n  class ObserverL implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n      for(int i = 0; i < numObservers; i++)\n        new Watcher2(Sharing2.this);\n    }\n  }\n  public static void main(String[] args) {\n    Sharing2 applet = new Sharing2();\n    // This isn\'t an applet, so set the flag and\n    // produce the parameter values from args:\n    applet.isApplet = false;\n    applet.numCounters =\n      (args.length == 0 ? 5 :\n        Integer.parseInt(args[0]));\n    applet.numObservers =\n      (args.length < 2 ? 5 :\n        Integer.parseInt(args[1]));\n    Frame aFrame = new Frame("Sharing2");\n    aFrame.addWindowListener(\n      new WindowAdapter() {\n        public void windowClosing(WindowEvent e){\n          System.exit(0);\n        }\n      });\n    aFrame.add(applet, BorderLayout.CENTER);\n    aFrame.setSize(350, applet.numCounters *100);\n    applet.init();\n    applet.start();\n    aFrame.setVisible(true);\n  }\n} ///:~\n')])])]),t("p",[n._v("我们注意到无论"),t("code",[n._v("run()")]),n._v("还是"),t("code",[n._v("synchTest()")]),n._v("都是“同步的”。如果只同步其中的一个方法，那么另一个就可以自由忽视对象的锁定，并可无碍地调用。所以必须记住一个重要的规则：对于访问某个关键共享资源的所有方法，都必须把它们设为"),t("code",[n._v("synchronized")]),n._v("，否则就不能正常地工作。")]),n._v(" "),t("p",[n._v("现在又遇到了一个新问题。"),t("code",[n._v("Watcher2")]),n._v("永远都不能看到正在进行的事情，因为整个"),t("code",[n._v("run()")]),n._v("方法已设为“同步”。而且由于肯定要为每个对象运行"),t("code",[n._v("run()")]),n._v("，所以锁永远不能打开，而"),t("code",[n._v("synchTest()")]),n._v("永远不会得到调用。之所以能看到这一结果，是因为"),t("code",[n._v("accessCount")]),n._v("根本没有变化。")]),n._v(" "),t("p",[n._v("为解决这个问题，我们能采取的一个办法是只将"),t("code",[n._v("run()")]),n._v("中的一部分代码隔离出来。想用这个办法隔离出来的那部分代码叫作“关键区域”，而且要用不同的方式来使用"),t("code",[n._v("synchronized")]),n._v("关键字，以设置一个关键区域。Java通过“同步块”提供对关键区域的支持；这一次，我们用"),t("code",[n._v("synchronized")]),n._v("关键字指出对象的锁用于对其中封闭的代码进行同步。如下所示：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("synchronized(syncObject) {\n  // This code can be accessed by only\n  // one thread at a time, assuming all\n  // threads respect syncObject's lock\n}\n")])])]),t("p",[n._v("在能进入同步块之前，必须在"),t("code",[n._v("synchObject")]),n._v("上取得锁。如果已有其他线程取得了这把锁，块便不能进入，必须等候那把锁被释放。")]),n._v(" "),t("p",[n._v("可从整个"),t("code",[n._v("run()")]),n._v("中删除"),t("code",[n._v("synchronized")]),n._v("关键字，换成用一个同步块包围两个关键行，从而完成对"),t("code",[n._v("Sharing2")]),n._v("例子的修改。但什么对象应作为锁来使用呢？那个对象已由"),t("code",[n._v("synchTest()")]),n._v("标记出来了——也就是当前对象（"),t("code",[n._v("this")]),n._v("）！所以修改过的"),t("code",[n._v("run()")]),n._v("方法象下面这个样子：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("  public void run() {\n    while (true) {\n      synchronized(this) {\n        t1.setText(Integer.toString(count1++));\n        t2.setText(Integer.toString(count2++));\n      }\n      try {\n        sleep(500);\n      } catch (InterruptedException e){}\n    }\n  }\n")])])]),t("p",[n._v("这是必须对"),t("code",[n._v("Sharing2.java")]),n._v("作出的唯一修改，我们会看到尽管两个计数器永远不会脱离同步（取决于允许"),t("code",[n._v("Watcher")]),n._v("什么时候检查它们），但在"),t("code",[n._v("run()")]),n._v("执行期间，仍然向"),t("code",[n._v("Watcher")]),n._v("提供了足够的访问权限。")]),n._v(" "),t("p",[n._v("当然，所有同步都取决于程序员是否勤奋：要访问共享资源的每一部分代码都必须封装到一个适当的同步块里。")]),n._v(" "),t("p",[n._v("(2) 同步的效率")]),n._v(" "),t("p",[n._v("由于要为同样的数据编写两个方法，所以无论如何都不会给人留下效率很高的印象。看来似乎更好的一种做法是将所有方法都设为自动同步，并完全消除"),t("code",[n._v("synchronized")]),n._v("关键字（当然，含有"),t("code",[n._v("synchronized run()")]),n._v("的例子显示出这样做是很不通的）。但它也揭示出获取一把锁并非一种“廉价”方案——为一次方法调用付出的代价（进入和退出方法，不执行方法主体）至少要累加到四倍，而且根据我们的具体现方案，这一代价还有可能变得更高。所以假如已知一个方法不会造成冲突，最明智的做法便是撤消其中的"),t("code",[n._v("synchronized")]),n._v("关键字。")]),n._v(" "),t("h2",{attrs:{id:"_14-2-3-回顾java-beans"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-3-回顾java-beans"}},[n._v("#")]),n._v(" 14.2.3 回顾Java Beans")]),n._v(" "),t("p",[n._v("我们现在已理解了同步，接着可换从另一个角度来考察Java Beans。无论什么时候创建了一个Bean，就必须假定它要在一个多线程的环境中运行。这意味着：")]),n._v(" "),t("p",[n._v("(1) 只要可行，Bean的所有公共方法都应同步。当然，这也带来了“同步”在运行期间的开销。若特别在意这个问题，在关键区域中不会造成问题的方法就可保留为“不同步”，但注意这通常都不是十分容易判断。有资格的方法倾向于规模很小（如下例的"),t("code",[n._v("getCircleSize()")]),n._v("）以及／或者“微小”。也就是说，这个方法调用在如此少的代码片里执行，以至于在执行期间对象不能改变。如果将这种方法设为“不同步”，可能对程序的执行速度不会有明显的影响。可能也将一个Bean的所有"),t("code",[n._v("public")]),n._v("方法都设为"),t("code",[n._v("synchronized")]),n._v("，并只有在保证特别必要、而且会造成一个差异的情况下，才将"),t("code",[n._v("synchronized")]),n._v("关键字删去。")]),n._v(" "),t("p",[n._v("(2) 如果将一个多转换事件送给一系列对那个事件感兴趣的“听众”，必须假在列表中移动的时候可以添加或者删除。")]),n._v(" "),t("p",[n._v("第一点很容易处理，但第二点需要考虑更多的东西。让我们以前一章提供的"),t("code",[n._v("BangBean.java")]),n._v("为例。在那个例子中，我们忽略了"),t("code",[n._v("synchronized")]),n._v("关键字（那时还没有引入呢），并将转换设为单转换，从而回避了多线程的问题。在下面这个修改过的版本中，我们使其能在多线程环境中工作，并为事件采用了多转换技术：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: BangBean2.java\n// You should write your Beans this way so they\n// can run in a multithreaded environment.\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class BangBean2 extends Canvas\n    implements Serializable {\n  private int xm, ym;\n  private int cSize = 20; // Circle size\n  private String text = "Bang!";\n  private int fontSize = 48;\n  private Color tColor = Color.red;\n  private Vector actionListeners = new Vector();\n  public BangBean2() {\n    addMouseListener(new ML());\n    addMouseMotionListener(new MM());\n  }\n  public synchronized int getCircleSize() {\n    return cSize;\n  }\n  public synchronized void\n  setCircleSize(int newSize) {\n    cSize = newSize;\n  }\n  public synchronized String getBangText() {\n    return text;\n  }\n  public synchronized void\n  setBangText(String newText) {\n    text = newText;\n  }\n  public synchronized int getFontSize() {\n    return fontSize;\n  }\n  public synchronized void\n  setFontSize(int newSize) {\n    fontSize = newSize;\n  }\n  public synchronized Color getTextColor() {\n    return tColor;\n  }\n  public synchronized void\n  setTextColor(Color newColor) {\n    tColor = newColor;\n  }\n  public void paint(Graphics g) {\n    g.setColor(Color.black);\n    g.drawOval(xm - cSize/2, ym - cSize/2,\n      cSize, cSize);\n  }\n  // This is a multicast listener, which is\n  // more typically used than the unicast\n  // approach taken in BangBean.java:\n  public synchronized void addActionListener (\n      ActionListener l) {\n    actionListeners.addElement(l);\n  }\n  public synchronized void removeActionListener(\n      ActionListener l) {\n    actionListeners.removeElement(l);\n  }\n  // Notice this isn\'t synchronized:\n  public void notifyListeners() {\n    ActionEvent a =\n      new ActionEvent(BangBean2.this,\n        ActionEvent.ACTION_PERFORMED, null);\n    Vector lv = null;\n    // Make a copy of the vector in case someone\n    // adds a listener while we\'re\n    // calling listeners:\n    synchronized(this) {\n      lv = (Vector)actionListeners.clone();\n    }\n    // Call all the listener methods:\n    for(int i = 0; i < lv.size(); i++) {\n      ActionListener al =\n        (ActionListener)lv.elementAt(i);\n      al.actionPerformed(a);\n    }\n  }\n  class ML extends MouseAdapter {\n    public void mousePressed(MouseEvent e) {\n      Graphics g = getGraphics();\n      g.setColor(tColor);\n      g.setFont(\n        new Font(\n          "TimesRoman", Font.BOLD, fontSize));\n      int width =\n        g.getFontMetrics().stringWidth(text);\n      g.drawString(text,\n        (getSize().width - width) /2,\n        getSize().height/2);\n      g.dispose();\n      notifyListeners();\n    }\n  }\n  class MM extends MouseMotionAdapter {\n    public void mouseMoved(MouseEvent e) {\n      xm = e.getX();\n      ym = e.getY();\n      repaint();\n    }\n  }\n  // Testing the BangBean2:\n  public static void main(String[] args) {\n    BangBean2 bb = new BangBean2();\n    bb.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e){\n        System.out.println("ActionEvent" + e);\n      }\n    });\n    bb.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e){\n        System.out.println("BangBean2 action");\n      }\n    });\n    bb.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e){\n        System.out.println("More action");\n      }\n    });\n    Frame aFrame = new Frame("BangBean2 Test");\n    aFrame.addWindowListener(new WindowAdapter(){\n      public void windowClosing(WindowEvent e) {\n        System.exit(0);\n      }\n    });\n    aFrame.add(bb, BorderLayout.CENTER);\n    aFrame.setSize(300,300);\n    aFrame.setVisible(true);\n  }\n} ///:~\n')])])]),t("p",[n._v("很容易就可以为方法添加"),t("code",[n._v("synchronized")]),n._v("。但注意在"),t("code",[n._v("addActionListener()")]),n._v("和"),t("code",[n._v("removeActionListener()")]),n._v("中，现在添加了"),t("code",[n._v("ActionListener")]),n._v("，并从一个"),t("code",[n._v("Vector")]),n._v("中移去，所以能够根据自己愿望使用任意多个。")]),n._v(" "),t("p",[n._v("我们注意到，"),t("code",[n._v("notifyListeners()")]),n._v("方法并未设为“同步”。可从多个线程中发出对这个方法的调用。另外，在对"),t("code",[n._v("notifyListeners()")]),n._v("调用的中途，也可能发出对"),t("code",[n._v("addActionListener()")]),n._v("和"),t("code",[n._v("removeActionListener()")]),n._v("的调用。这显然会造成问题，因为它否定了"),t("code",[n._v("Vector actionListeners")]),n._v("。为缓解这个问题，我们在一个"),t("code",[n._v("synchronized")]),n._v("从句中“克隆”了"),t("code",[n._v("Vector")]),n._v("，并对克隆进行了否定。这样便可在不影响"),t("code",[n._v("notifyListeners()")]),n._v("的前提下，对"),t("code",[n._v("Vector")]),n._v("进行操纵。")]),n._v(" "),t("p",[t("code",[n._v("paint()")]),n._v("方法也没有设为“同步”。与单纯地添加自己的方法相比，决定是否对重载的方法进行同步要困难得多。在这个例子中，无论"),t("code",[n._v("paint()")]),n._v("是否“同步”，它似乎都能正常地工作。但必须考虑的问题包括：")]),n._v(" "),t("p",[n._v("(1) 方法会在对象内部修改“关键”变量的状态吗？为判断一个变量是否“关键”，必须知道它是否会被程序中的其他线程读取或设置（就目前的情况看，读取或设置几乎肯定是通过“同步”方法进行的，所以可以只对它们进行检查）。对"),t("code",[n._v("paint()")]),n._v("的情况来说，不会发生任何修改。")]),n._v(" "),t("p",[n._v("(2) 方法要以这些“关键”变量的状态为基础吗？如果一个“同步”方法修改了一个变量，而我们的方法要用到这个变量，那么一般都愿意把自己的方法也设为“同步”。基于这一前提，大家可观察到"),t("code",[n._v("cSize")]),n._v("由“同步”方法进行了修改，所以"),t("code",[n._v("paint()")]),n._v("应当是“同步”的。但在这里，我们可以问：“假如"),t("code",[n._v("cSize")]),n._v("在"),t("code",[n._v("paint()")]),n._v("执行期间发生了变化，会发生的最糟糕的事情是什么呢？”如果发现情况不算太坏，而且仅仅是暂时的效果，那么最好保持"),t("code",[n._v("paint()")]),n._v("的“不同步”状态，以避免同步方法调用带来的额外开销。")]),n._v(" "),t("p",[n._v("(3) 要留意的第三条线索是"),t("code",[n._v("paint()")]),n._v("基类版本是否“同步”，在这里它不是同步的。这并不是一个非常严格的参数，仅仅是一条“线索”。比如在目前的情况下，通过同步方法（好"),t("code",[n._v("cSize")]),n._v("）改变的一个字段已组合到"),t("code",[n._v("paint()")]),n._v("公式里，而且可能已改变了情况。但请注意，"),t("code",[n._v("synchronized")]),n._v("不能继承——也就是说，假如一个方法在基类中是“同步”的，那么在派生类重载版本中，它不会自动进入“同步”状态。")]),n._v(" "),t("p",[t("code",[n._v("TestBangBean2")]),n._v("中的测试代码已在前一章的基础上进行了修改，已在其中加入了额外的“听众”，从而演示了"),t("code",[n._v("BangBean2")]),n._v("的多转换能力。")])])}),[],!1,null,null,null);e.default=i.exports}}]);