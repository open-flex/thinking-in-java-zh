(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{549:function(n,t,e){"use strict";e.r(t);var a=e(56),v=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_7-3-覆盖与重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-覆盖与重载"}},[n._v("#")]),n._v(" 7.3 覆盖与重载")]),n._v(" "),e("p",[n._v("现在让我们用不同的眼光来看看本章的头一个例子。在下面这个程序中，方法"),e("code",[n._v("play()")]),n._v("的接口会在被覆盖的过程中发生变化。这意味着我们实际并没有“覆盖”方法，而是使其“重载”。编译器允许我们对方法进行重载处理，使其不报告出错。但这种行为可能并不是我们所希望的。下面是这个例子：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//: WindError.java\n// Accidentally changing the interface\n\nclass NoteX {\n  public static final int\n    MIDDLE_C = 0, C_SHARP = 1, C_FLAT = 2;\n}\n\nclass InstrumentX {\n  public void play(int NoteX) {\n    System.out.println("InstrumentX.play()");\n  }\n}\n\nclass WindX extends InstrumentX {\n  // OOPS! Changes the method interface:\n  public void play(NoteX n) {\n    System.out.println("WindX.play(NoteX n)");\n  }\n}\n\npublic class WindError {\n  public static void tune(InstrumentX i) {\n    // ...\n    i.play(NoteX.MIDDLE_C);\n  }\n  public static void main(String[] args) {\n    WindX flute = new WindX();\n    tune(flute); // Not the desired behavior!\n  }\n} ///:~\n')])])]),e("p",[n._v("这里还向大家引入了另一个易于混淆的概念。在"),e("code",[n._v("InstrumentX")]),n._v("中，"),e("code",[n._v("play()")]),n._v("方法采用了一个"),e("code",[n._v("int")]),n._v("（整数）数值，它的标识符是"),e("code",[n._v("NoteX")]),n._v("。也就是说，即使"),e("code",[n._v("NoteX")]),n._v("是一个类名，也可以把它作为一个标识符使用，编译器不会报告出错。但在"),e("code",[n._v("WindX")]),n._v("中，"),e("code",[n._v("play()")]),n._v("采用一个"),e("code",[n._v("NoteX")]),n._v("引用，它有一个标识符"),e("code",[n._v("n")]),n._v("。即便我们使用"),e("code",[n._v("play(NoteX NoteX)")]),n._v("，编译器也不会报告错误。这样一来，看起来就象是程序员有意覆盖"),e("code",[n._v("play()")]),n._v("的功能，但对方法的类型定义却稍微有些不确切。然而，编译器此时假定的是程序员有意进行“重载”，而非“覆盖”。请仔细体会这两个术语的区别。“重载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。请注意如果遵守标准的Java命名规范，参数标识符就应该是"),e("code",[n._v("noteX")]),n._v("，这样可把它与类名区分开。")]),n._v(" "),e("p",[n._v("在"),e("code",[n._v("tune")]),n._v("中，"),e("code",[n._v("InstrumentX i")]),n._v("会发出"),e("code",[n._v("play()")]),n._v("消息，同时将某个"),e("code",[n._v("NoteX")]),n._v("成员作为参数使用（"),e("code",[n._v("MIDDLE_C")]),n._v("）。由于"),e("code",[n._v("NoteX")]),n._v("包含了"),e("code",[n._v("int")]),n._v("定义，重载的"),e("code",[n._v("play()")]),n._v("方法的"),e("code",[n._v("int")]),n._v("版本会得到调用。同时由于它尚未被“覆盖”，所以会使用基类版本。")]),n._v(" "),e("p",[n._v("输出是：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("InstrumentX.play()\n")])])])])}),[],!1,null,null,null);t.default=v.exports}}]);