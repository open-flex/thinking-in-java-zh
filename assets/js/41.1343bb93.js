(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{440:function(a,n,s){"use strict";s.r(n);var t=s(56),e=Object(t.a)({},(function(){var a=this,n=a.$createElement,s=a._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_12-1-传递引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-传递引用"}},[a._v("#")]),a._v(" 12.1 传递引用")]),a._v(" "),s("p",[a._v("将引用传递进入一个方法时，指向的仍然是相同的对象。一个简单的实验可以证明这一点（若执行这个程序时有麻烦，请参考第3章3.1.2小节“赋值”）：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('//: PassHandles.java\n// Passing handles around\npackage c12;\n\npublic class PassHandles {\n  static void f(PassHandles h) {\n    System.out.println("h inside f(): " + h);\n  }\n  public static void main(String[] args) {\n    PassHandles p = new PassHandles();\n    System.out.println("p inside main(): " + p);\n    f(p);\n  }\n} ///:~\n')])])]),s("p",[s("code",[a._v("toString")]),a._v("方法会在打印语句里自动调用，而"),s("code",[a._v("PassHandles")]),a._v("直接从"),s("code",[a._v("Object")]),a._v("继承，没有"),s("code",[a._v("toString")]),a._v("的重新定义。因此，这里会采用"),s("code",[a._v("toString")]),a._v("的"),s("code",[a._v("Object")]),a._v("版本，打印出对象的类，接着是那个对象所在的位置（不是引用，而是对象的实际存储位置）。输出结果如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("p inside main(): PassHandles@1653748\nh inside f() : PassHandles@1653748\n")])])]),s("p",[a._v("可以看到，无论"),s("code",[a._v("p")]),a._v("还是"),s("code",[a._v("h")]),a._v("引用的都是同一个对象。这比复制一个新的"),s("code",[a._v("PassHandles")]),a._v("对象有效多了，使我们能将一个参数发给一个方法。但这样做也带来了另一个重要的问题。")]),a._v(" "),s("h2",{attrs:{id:"_12-1-1-别名问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-1-别名问题"}},[a._v("#")]),a._v(" 12.1.1 别名问题")]),a._v(" "),s("p",[a._v("“别名”意味着多个引用都试图指向同一个对象，就象前面的例子展示的那样。若有人向那个对象里写入一点什么东西，就会产生别名问题。若其他引用的所有者不希望那个对象改变，恐怕就要失望了。这可用下面这个简单的例子说明：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('//: Alias1.java\n// Aliasing two handles to one object\n\npublic class Alias1 {\n  int i;\n  Alias1(int ii) { i = ii; }\n  public static void main(String[] args) {\n    Alias1 x = new Alias1(7);\n    Alias1 y = x; // Assign the handle\n    System.out.println("x: " + x.i);\n    System.out.println("y: " + y.i);\n    System.out.println("Incrementing x");\n    x.i++;\n    System.out.println("x: " + x.i);\n    System.out.println("y: " + y.i);\n  }\n} ///:~\n')])])]),s("p",[a._v("对下面这行：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Alias1 y = x; // Assign the handle\n")])])]),s("p",[a._v("它会新建一个"),s("code",[a._v("Alias1")]),a._v("引用，但不是把它分配给由new创建的一个新鲜对象，而是分配给一个现有的引用。所以引用x的内容——即对象"),s("code",[a._v("x")]),a._v("指向的地址——被分配给"),s("code",[a._v("y")]),a._v("，所以无论"),s("code",[a._v("x")]),a._v("还是"),s("code",[a._v("y")]),a._v("都与相同的对象连接起来。这样一来，一旦"),s("code",[a._v("x")]),a._v("的"),s("code",[a._v("i")]),a._v("在下述语句中自增：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("x.i++;\n")])])]),s("p",[s("code",[a._v("y")]),a._v("的"),s("code",[a._v("i")]),a._v("值也必然受到影响。从最终的输出就可以看出：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("x: 7\ny: 7\nIncrementing x\nx: 8\ny: 8\n")])])]),s("p",[a._v("此时最直接的一个解决办法就是干脆不这样做：不要有意将多个引用指向同一个作用域内的同一个对象。这样做可使代码更易理解和调试。然而，一旦准备将引用作为一个变量或参数传递——这是Java设想的正常方法——别名问题就会自动出现，因为创建的本地引用可能修改“外部对象”（在方法作用域之外创建的对象）。下面是一个例子：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('//: Alias2.java\n// Method calls implicitly alias their\n// arguments.\n\npublic class Alias2 {\n  int i;\n  Alias2(int ii) { i = ii; }\n  static void f(Alias2 handle) {\n    handle.i++;\n  }\n  public static void main(String[] args) {\n    Alias2 x = new Alias2(7);\n    System.out.println("x: " + x.i);\n    System.out.println("Calling f(x)");\n    f(x);\n    System.out.println("x: " + x.i);\n  }\n} ///:~\n')])])]),s("p",[a._v("输出如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("x: 7\nCalling f(x)\nx: 8\n")])])]),s("p",[a._v("方法改变了自己的参数——外部对象。一旦遇到这种情况，必须判断它是否合理，用户是否愿意这样，以及是不是会造成问题。")]),a._v(" "),s("p",[a._v("通常，我们调用一个方法是为了产生返回值，或者用它改变为其调用方法的那个对象的状态（方法其实就是我们向那个对象“发一条消息”的方式）。很少需要调用一个方法来处理它的参数；这叫作利用方法的“副作用”（Side Effect）。所以倘若创建一个会修改自己参数的方法，必须向用户明确地指出这一情况，并警告使用那个方法可能会有的后果以及它的潜在威胁。由于存在这些混淆和缺陷，所以应该尽量避免改变参数。")]),a._v(" "),s("p",[a._v("若需在一个方法调用期间修改一个参数，且不打算修改外部参数，就应在自己的方法内部制作一个副本，从而保护那个参数。本章的大多数内容都是围绕这个问题展开的。")])])}),[],!1,null,null,null);n.default=e.exports}}]);