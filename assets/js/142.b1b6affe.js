(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{537:function(n,e,t){"use strict";t.r(e);var a=t(56),i=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"_6-3-组合与继承的结合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-组合与继承的结合"}},[n._v("#")]),n._v(" 6.3 组合与继承的结合")]),n._v(" "),t("p",[n._v("许多时候都要求将组合与继承两种技术结合起来使用。下面这个例子展示了如何同时采用继承与组合技术，从而创建一个更复杂的类，同时进行必要的构造器初始化工作：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: PlaceSetting.java\n// Combining composition & inheritance\n\nclass Plate {\n  Plate(int i) {\n    System.out.println("Plate constructor");\n  }\n}\n\nclass DinnerPlate extends Plate {\n  DinnerPlate(int i) {\n    super(i);\n    System.out.println(\n      "DinnerPlate constructor");\n  }\n}\n\nclass Utensil {\n  Utensil(int i) {\n    System.out.println("Utensil constructor");\n  }\n}\n\nclass Spoon extends Utensil {\n  Spoon(int i) {\n    super(i);\n    System.out.println("Spoon constructor");\n  }\n}\n\nclass Fork extends Utensil {\n  Fork(int i) {\n    super(i);\n    System.out.println("Fork constructor");\n  }\n}\n\nclass Knife extends Utensil {\n  Knife(int i) {\n    super(i);\n    System.out.println("Knife constructor");\n  }\n}\n\n// A cultural way of doing something:\nclass Custom {\n  Custom(int i) {\n    System.out.println("Custom constructor");\n  }\n}\n\npublic class PlaceSetting extends Custom {\n  Spoon sp;\n  Fork frk;\n  Knife kn;\n  DinnerPlate pl;\n  PlaceSetting(int i) {\n    super(i + 1);\n    sp = new Spoon(i + 2);\n    frk = new Fork(i + 3);\n    kn = new Knife(i + 4);\n    pl = new DinnerPlate(i + 5);\n    System.out.println(\n      "PlaceSetting constructor");\n  }\n  public static void main(String[] args) {\n    PlaceSetting x = new PlaceSetting(9);\n  }\n} ///:~\n')])])]),t("p",[n._v("尽管编译器会强迫我们对基类进行初始化，并要求我们在构造器最开头做这一工作，但它并不会监视我们是否正确初始化了成员对象。所以对此必须特别加以留意。")]),n._v(" "),t("h2",{attrs:{id:"_6-3-1-确保正确的清除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-1-确保正确的清除"}},[n._v("#")]),n._v(" 6.3.1 确保正确的清除")]),n._v(" "),t("p",[n._v("Java不具备象C++的“析构器”那样的概念。在C++中，一旦析构（清除）一个对象，就会自动调用析构器方法。之所以将其省略，大概是由于在Java中只需简单地忘记对象，不需强行析构它们。垃圾收集器会在必要的时候自动回收内存。")]),n._v(" "),t("p",[n._v("垃圾收集器大多数时候都能很好地工作，但在某些情况下，我们的类可能在自己的存在时期采取一些行动，而这些行动要求必须进行明确的清除工作。正如第4章已经指出的那样，我们并不知道垃圾收集器什么时候才会显身，或者说不知它何时会调用。所以一旦希望为一个类清除什么东西，必须写一个特别的方法，明确、专门地来做这件事情。同时，还要让客户程序员知道他们必须调用这个方法。而在所有这一切的后面，就如第9章（异常控制）要详细解释的那样，必须将这样的清除代码置于一个"),t("code",[n._v("finally")]),n._v("从句中，从而防范任何可能出现的异常事件。")]),n._v(" "),t("p",[n._v("下面介绍的是一个计算机辅助设计系统的例子，它能在屏幕上描绘图形：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: CADSystem.java\n// Ensuring proper cleanup\nimport java.util.*;\n\nclass Shape {\n  Shape(int i) {\n    System.out.println("Shape constructor");\n  }\n  void cleanup() {\n    System.out.println("Shape cleanup");\n  }\n}\n\nclass Circle extends Shape {\n  Circle(int i) {\n    super(i);\n    System.out.println("Drawing a Circle");\n  }\n  void cleanup() {\n    System.out.println("Erasing a Circle");\n    super.cleanup();\n  }\n}\n\nclass Triangle extends Shape {\n  Triangle(int i) {\n    super(i);\n    System.out.println("Drawing a Triangle");\n  }\n  void cleanup() {\n    System.out.println("Erasing a Triangle");\n    super.cleanup();\n  }\n}\n\nclass Line extends Shape {\n  private int start, end;\n  Line(int start, int end) {\n    super(start);\n    this.start = start;\n    this.end = end;\n    System.out.println("Drawing a Line: " +\n           start + ", " + end);\n  }\n  void cleanup() {\n    System.out.println("Erasing a Line: " +\n           start + ", " + end);\n    super.cleanup();\n  }\n}\n\npublic class CADSystem extends Shape {\n  private Circle c;\n  private Triangle t;\n  private Line[] lines = new Line[10];\n  CADSystem(int i) {\n    super(i + 1);\n    for(int j = 0; j < 10; j++)\n      lines[j] = new Line(j, j*j);\n    c = new Circle(1);\n    t = new Triangle(1);\n    System.out.println("Combined constructor");\n  }\n  void cleanup() {\n    System.out.println("CADSystem.cleanup()");\n    t.cleanup();\n    c.cleanup();\n    for(int i = 0; i < lines.length; i++)\n      lines[i].cleanup();\n    super.cleanup();\n  }\n  public static void main(String[] args) {\n    CADSystem x = new CADSystem(47);\n    try {\n      // Code and exception handling...\n    } finally {\n      x.cleanup();\n    }\n  }\n} ///:~\n')])])]),t("p",[n._v("这个系统中的所有东西都属于某种"),t("code",[n._v("Shape")]),n._v("（几何形状）。"),t("code",[n._v("Shape")]),n._v("本身是一种"),t("code",[n._v("Object")]),n._v("（对象），因为它是从根类明确继承的。每个类都重新定义了"),t("code",[n._v("Shape")]),n._v("的"),t("code",[n._v("cleanup()")]),n._v("方法，同时还要用"),t("code",[n._v("super")]),n._v("调用那个方法的基类版本。尽管对象存在期间调用的所有方法都可负责做一些要求清除的工作，但对于特定的"),t("code",[n._v("Shape")]),n._v("类——"),t("code",[n._v("Circle")]),n._v("（圆）、"),t("code",[n._v("Triangle")]),n._v("（三角形）以及"),t("code",[n._v("Line")]),n._v("（直线），它们都拥有自己的构造器，能完成“作图”（"),t("code",[n._v("draw")]),n._v("）任务。每个类都有它们自己的"),t("code",[n._v("cleanup()")]),n._v("方法，用于将非内存的东西恢复回对象存在之前的景象。")]),n._v(" "),t("p",[n._v("在"),t("code",[n._v("main()")]),n._v("中，可看到两个新关键字："),t("code",[n._v("try")]),n._v("和"),t("code",[n._v("finally")]),n._v("。我们要到第9章才会向大家正式引荐它们。其中，"),t("code",[n._v("try")]),n._v("关键字指出后面跟随的块（由花括号定界）是一个“警戒区”。也就是说，它会受到特别的待遇。其中一种待遇就是：该警戒区后面跟随的"),t("code",[n._v("finally")]),n._v("从句的代码肯定会得以执行——不管"),t("code",[n._v("try")]),n._v("块到底存不存在（通过异常控制技术，"),t("code",[n._v("try")]),n._v("块可有多种不寻常的应用）。在这里，"),t("code",[n._v("finally")]),n._v("从句的意思是“总是为"),t("code",[n._v("x")]),n._v("调用"),t("code",[n._v("cleanup()")]),n._v("，无论会发生什么事情”。这些关键字将在第9章进行全面、完整的解释。")]),n._v(" "),t("p",[n._v("在自己的清除方法中，必须注意对基类以及成员对象清除方法的调用顺序——假若一个子对象要以另一个为基础。通常，应采取与C++编译器对它的“析构器”采取的同样的形式：首先完成与类有关的所有特殊工作（可能要求基类元素仍然可见），然后调用基类清除方法，就象这儿演示的那样。")]),n._v(" "),t("p",[n._v("许多情况下，清除可能并不是个问题；只需让垃圾收集器尽它的职责即可。但一旦必须由自己明确清除，就必须特别谨慎，并要求周全的考虑。")]),n._v(" "),t("p",[n._v("(1) 垃圾收集的顺序")]),n._v(" "),t("p",[n._v("不能指望自己能确切知道何时会开始垃圾收集。垃圾收集器可能永远不会得到调用。即使得到调用，它也可能以自己愿意的任何顺序回收对象。除此以外，Java 1.0实现的垃圾收集器机制通常不会调用"),t("code",[n._v("finalize()")]),n._v("方法。除内存的回收以外，其他任何东西都最好不要依赖垃圾收集器进行回收。若想明确地清除什么，请制作自己的清除方法，而且不要依赖"),t("code",[n._v("finalize()")]),n._v("。然而正如以前指出的那样，可强迫Java1.1调用所有收尾模块（"),t("code",[n._v("Finalizer")]),n._v("）。")]),n._v(" "),t("h2",{attrs:{id:"_6-3-2-名字的隐藏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-2-名字的隐藏"}},[n._v("#")]),n._v(" 6.3.2 名字的隐藏")]),n._v(" "),t("p",[n._v("只有C++程序员可能才会惊讶于名字的隐藏，因为它的工作原理与在C++里是完全不同的。如果Java基类有一个方法名被“重载”使用多次，在派生类里对那个方法名的重新定义就不会隐藏任何基类的版本。所以无论方法在这一级还是在一个基类中定义，重载都会生效：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Hide.java\n// Overloading a base-class method name\n// in a derived class does not hide the\n// base-class versions\n\nclass Homer {\n  char doh(char c) {\n    System.out.println(\"doh(char)\");\n    return 'd';\n  }\n  float doh(float f) {\n    System.out.println(\"doh(float)\");\n    return 1.0f;\n  }\n}\n\nclass Milhouse {}\n\nclass Bart extends Homer {\n  void doh(Milhouse m) {}\n}\n\nclass Hide {\n  public static void main(String[] args) {\n    Bart b = new Bart();\n    b.doh(1); // doh(float) used\n    b.doh('x');\n    b.doh(1.0f);\n    b.doh(new Milhouse());\n  }\n} ///:~\n")])])]),t("p",[n._v("正如下一章会讲到的那样，很少会用与基类里完全一致的签名和返回类型来覆盖同名的方法，否则会使人感到迷惑（这正是C++不允许那样做的原因，所以能够防止产生一些不必要的错误）。")])])}),[],!1,null,null,null);e.default=i.exports}}]);