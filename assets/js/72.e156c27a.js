(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{470:function(e,n,t){"use strict";t.r(n);var v=t(56),a=Object(v.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_14-3-堵塞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-堵塞"}},[e._v("#")]),e._v(" 14.3 堵塞")]),e._v(" "),t("p",[e._v("一个线程可以有四种状态：")]),e._v(" "),t("p",[e._v("(1) 新（New）：线程对象已经创建，但尚未启动，所以不可运行。")]),e._v(" "),t("p",[e._v("(2) 可运行（Runnable）：意味着一旦时间分片机制有空闲的CPU周期提供给一个线程，那个线程便可立即开始运行。因此，线程可能在、也可能不在运行当中，但一旦条件许可，没有什么能阻止它的运行——它既没有“死”掉，也未被“堵塞”。")]),e._v(" "),t("p",[e._v("(3) 死（Dead）：从自己的"),t("code",[e._v("run()")]),e._v("方法中返回后，一个线程便已“死”掉。亦可调用"),t("code",[e._v("stop()")]),e._v("令其死掉，但会产生一个异常——属于"),t("code",[e._v("Error")]),e._v("的一个子类（也就是说，我们通常不捕获它）。记住一个异常的“抛”出应当是一个特殊事件，而不是正常程序运行的一部分。所以不建议你使用"),t("code",[e._v("stop()")]),e._v("（在Java 1.2则是坚决反对）。另外还有一个"),t("code",[e._v("destroy()")]),e._v("方法（它永远不会实现），应该尽可能地避免调用它，因为它非常武断，根本不会解除对象的锁定。")]),e._v(" "),t("p",[e._v("(4) 堵塞（Blocked）：线程可以运行，但有某种东西阻碍了它。若线程处于堵塞状态，调度机制可以简单地跳过它，不给它分配任何CPU时间。除非线程再次进入“可运行”状态，否则不会采取任何操作。")]),e._v(" "),t("h2",{attrs:{id:"_14-3-1-为何会堵塞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-1-为何会堵塞"}},[e._v("#")]),e._v(" 14.3.1 为何会堵塞")]),e._v(" "),t("p",[e._v("堵塞状态是前述四种状态中最有趣的，值得我们作进一步的探讨。线程被堵塞可能是由下述五方面的原因造成的：")]),e._v(" "),t("p",[e._v("(1) 调用"),t("code",[e._v("sleep(毫秒数)")]),e._v("，使线程进入“睡眠”状态。在规定的时间内，这个线程是不会运行的。")]),e._v(" "),t("p",[e._v("(2) 用"),t("code",[e._v("suspend()")]),e._v("暂停了线程的执行。除非线程收到"),t("code",[e._v("resume()")]),e._v("消息，否则不会返回“可运行”状态。")]),e._v(" "),t("p",[e._v("(3) 用"),t("code",[e._v("wait()")]),e._v("暂停了线程的执行。除非线程收到"),t("code",[e._v("nofify()")]),e._v("或者"),t("code",[e._v("notifyAll()")]),e._v("消息，否则不会变成“可运行”（是的，这看起来同原因2非常相象，但有一个明显的区别是我们马上要揭示的）。")]),e._v(" "),t("p",[e._v("(4) 线程正在等候一些IO（输入输出）操作完成。")]),e._v(" "),t("p",[e._v("(5) 线程试图调用另一个对象的“同步”方法，但那个对象处于锁定状态，暂时无法使用。")]),e._v(" "),t("p",[e._v("亦可调用"),t("code",[e._v("yield()")]),e._v("（"),t("code",[e._v("Thread")]),e._v("类的一个方法）自动放弃CPU，以便其他线程能够运行。然而，假如调度机制觉得我们的线程已拥有足够的时间，并跳转到另一个线程，就会发生同样的事情。也就是说，没有什么能防止调度机制重新启动我们的线程。线程被堵塞后，便有一些原因造成它不能继续运行。")]),e._v(" "),t("p",[e._v("下面这个例子展示了进入堵塞状态的全部五种途径。它们全都存在于名为"),t("code",[e._v("Blocking.java")]),e._v("的一个文件中，但在这儿采用散落的片断进行解释（大家可注意到片断前后的"),t("code",[e._v("Continued")]),e._v("以及"),t("code",[e._v("Continuing")]),e._v("标志。利用第17章介绍的工具，可将这些片断连结到一起）。首先让我们看看基本的框架：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Blocking.java\n// Demonstrates the various ways a thread\n// can be blocked.\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.applet.*;\nimport java.io.*;\n\n//////////// The basic framework ///////////\nclass Blockable extends Thread {\n  private Peeker peeker;\n  protected TextField state = new TextField(40);\n  protected int i;\n  public Blockable(Container c) {\n    c.add(state);\n    peeker = new Peeker(this, c);\n  }\n  public synchronized int read() { return i; }\n  protected synchronized void update() {\n    state.setText(getClass().getName()\n      + " state: i = " + i);\n  }\n  public void stopPeeker() {\n    // peeker.stop(); Deprecated in Java 1.2\n    peeker.terminate(); // The preferred approach\n  }\n}\n\nclass Peeker extends Thread {\n  private Blockable b;\n  private int session;\n  private TextField status = new TextField(40);\n  private boolean stop = false;\n  public Peeker(Blockable b, Container c) {\n    c.add(status);\n    this.b = b;\n    start();\n  }\n  public void terminate() { stop = true; }\n  public void run() {\n    while (!stop) {\n      status.setText(b.getClass().getName()\n        + " Peeker " + (++session)\n        + "; value = " + b.read());\n       try {\n        sleep(100);\n      } catch (InterruptedException e){}\n    }\n  }\n} ///:Continued\n')])])]),t("p",[t("code",[e._v("Blockable")]),e._v("类打算成为本例所有类的一个基类。一个"),t("code",[e._v("Blockable")]),e._v("对象包含了一个名为"),t("code",[e._v("state")]),e._v("的"),t("code",[e._v("TextField")]),e._v("（文本字段），用于显示出对象有关的信息。用于显示这些信息的方法叫作"),t("code",[e._v("update()")]),e._v("。我们发现它用"),t("code",[e._v("getClass.getName()")]),e._v("来产生类名，而不是仅仅把它打印出来；这是由于"),t("code",[e._v("update(0)")]),e._v("不知道自己为其调用的那个类的准确名字，因为那个类是从"),t("code",[e._v("Blockable")]),e._v("派生出来的。")]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("Blockable")]),e._v("中，变动指示符是一个"),t("code",[e._v("int i")]),e._v("；派生类的"),t("code",[e._v("run()")]),e._v("方法会为其自增。")]),e._v(" "),t("p",[e._v("针对每个"),t("code",[e._v("Bloackable")]),e._v("对象，都会启动"),t("code",[e._v("Peeker")]),e._v("类的一个线程。"),t("code",[e._v("Peeker")]),e._v("的任务是调用"),t("code",[e._v("read()")]),e._v("方法，检查与自己关联的"),t("code",[e._v("Blockable")]),e._v("对象，看看i是否发生了变化，最后用它的"),t("code",[e._v("status")]),e._v("文本字段报告检查结果。注意"),t("code",[e._v("read()")]),e._v("和"),t("code",[e._v("update()")]),e._v("都是同步的，要求对象的锁定能自由解除，这一点非常重要。")]),e._v(" "),t("p",[e._v("(1) 睡眠")]),e._v(" "),t("p",[e._v("这个程序的第一项测试是用"),t("code",[e._v("sleep()")]),e._v("作出的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("///:Continuing\n///////////// Blocking via sleep() ///////////\nclass Sleeper1 extends Blockable {\n  public Sleeper1(Container c) { super(c); }\n  public synchronized void run() {\n    while(true) {\n      i++;\n      update();\n       try {\n        sleep(1000);\n      } catch (InterruptedException e){}\n    }\n  }\n}\n\nclass Sleeper2 extends Blockable {\n  public Sleeper2(Container c) { super(c); }\n  public void run() {\n    while(true) {\n      change();\n       try {\n        sleep(1000);\n      } catch (InterruptedException e){}\n    }\n  }\n  public synchronized void change() {\n      i++;\n      update();\n  }\n} ///:Continued\n")])])]),t("p",[e._v("在"),t("code",[e._v("Sleeper1")]),e._v("中，整个"),t("code",[e._v("run()")]),e._v("方法都是同步的。我们可看到与这个对象关联在一起的"),t("code",[e._v("Peeker")]),e._v("可以正常运行，直到我们启动线程为止，随后"),t("code",[e._v("Peeker")]),e._v("便会完全停止。这正是“堵塞”的一种形式：因为"),t("code",[e._v("Sleeper1.run()")]),e._v("是同步的，而且一旦线程启动，它就肯定在"),t("code",[e._v("run()")]),e._v("内部，方法永远不会放弃对象锁定，造成"),t("code",[e._v("Peeker")]),e._v("线程的堵塞。")]),e._v(" "),t("p",[t("code",[e._v("Sleeper2")]),e._v("通过设置不同步的运行，提供了一种解决方案。只有"),t("code",[e._v("change()")]),e._v("方法才是同步的，所以尽管"),t("code",[e._v("run()")]),e._v("位于"),t("code",[e._v("sleep()")]),e._v("内部，"),t("code",[e._v("Peeker")]),e._v("仍然能访问自己需要的同步方法——"),t("code",[e._v("read()")]),e._v("。在这里，我们可看到在启动了"),t("code",[e._v("Sleeper2")]),e._v("线程以后，"),t("code",[e._v("Peeker")]),e._v("会持续运行下去。")]),e._v(" "),t("p",[e._v("(2) 暂停和恢复")]),e._v(" "),t("p",[e._v("这个例子接下来的一部分引入了“挂起”或者“暂停”（"),t("code",[e._v("Suspend")]),e._v("）的概述。"),t("code",[e._v("Thread")]),e._v("类提供了一个名为"),t("code",[e._v("suspend()")]),e._v("的方法，可临时中止线程；以及一个名为"),t("code",[e._v("resume()")]),e._v("的方法，用于从暂停处开始恢复线程的执行。显然，我们可以推断出"),t("code",[e._v("resume()")]),e._v("是由暂停线程外部的某个线程调用的。在这种情况下，需要用到一个名为"),t("code",[e._v("Resumer")]),e._v("（恢复器）的独立类。演示暂停／恢复过程的每个类都有一个相关的恢复器。如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("///:Continuing\n/////////// Blocking via suspend() ///////////\nclass SuspendResume extends Blockable {\n  public SuspendResume(Container c) {\n    super(c);    \n    new Resumer(this);\n  }\n}\n\nclass SuspendResume1 extends SuspendResume {\n  public SuspendResume1(Container c) { super(c);}\n  public synchronized void run() {\n    while(true) {\n      i++;\n      update();\n      suspend(); // Deprecated in Java 1.2\n    }\n  }\n}\n\nclass SuspendResume2 extends SuspendResume {\n  public SuspendResume2(Container c) { super(c);}\n  public void run() {\n    while(true) {\n      change();\n      suspend(); // Deprecated in Java 1.2\n    }\n  }\n  public synchronized void change() {\n      i++;\n      update();\n  }\n}\n\nclass Resumer extends Thread {\n  private SuspendResume sr;\n  public Resumer(SuspendResume sr) {\n    this.sr = sr;\n    start();\n  }\n  public void run() {\n    while(true) {\n       try {\n        sleep(1000);\n      } catch (InterruptedException e){}\n      sr.resume(); // Deprecated in Java 1.2\n    }\n  }\n} ///:Continued\n")])])]),t("p",[t("code",[e._v("SuspendResume1")]),e._v("也提供了一个同步的"),t("code",[e._v("run()")]),e._v("方法。同样地，当我们启动这个线程以后，就会发现与它关联的"),t("code",[e._v("Peeker")]),e._v("进入“堵塞”状态，等候对象锁被释放，但那永远不会发生。和往常一样，这个问题在"),t("code",[e._v("SuspendResume2")]),e._v("里得到了解决，它并不同步整个"),t("code",[e._v("run()")]),e._v("方法，而是采用了一个单独的同步"),t("code",[e._v("change()")]),e._v("方法。")]),e._v(" "),t("p",[e._v("对于Java 1.2，大家应注意"),t("code",[e._v("suspend()")]),e._v("和"),t("code",[e._v("resume()")]),e._v("已获得强烈反对，因为"),t("code",[e._v("suspend()")]),e._v("包含了对象锁，所以极易出现“死锁”现象。换言之，很容易就会看到许多被锁住的对象在傻乎乎地等待对方。这会造成整个应用程序的“凝固”。尽管在一些老程序中还能看到它们的踪迹，但在你写自己的程序时，无论如何都应避免。本章稍后就会讲述正确的方案是什么。")]),e._v(" "),t("p",[e._v("(3) 等待和通知")]),e._v(" "),t("p",[e._v("通过前两个例子的实践，我们知道无论"),t("code",[e._v("sleep()")]),e._v("还是"),t("code",[e._v("suspend()")]),e._v("都不会在自己被调用的时候解除锁定。需要用到对象锁时，请务必注意这个问题。在另一方面，"),t("code",[e._v("wait()")]),e._v("方法在被调用时却会解除锁定，这意味着可在执行"),t("code",[e._v("wait()")]),e._v("期间调用线程对象中的其他同步方法。但在接着的两个类中，我们看到"),t("code",[e._v("run()")]),e._v("方法都是“同步”的。在"),t("code",[e._v("wait()")]),e._v("期间，"),t("code",[e._v("Peeker")]),e._v("仍然拥有对同步方法的完全访问权限。这是由于"),t("code",[e._v("wait()")]),e._v("在挂起内部调用的方法时，会解除对象的锁定。")]),e._v(" "),t("p",[e._v("我们也可以看到"),t("code",[e._v("wait()")]),e._v("的两种形式。第一种形式采用一个以毫秒为单位的参数，它具有与"),t("code",[e._v("sleep()")]),e._v("中相同的含义：暂停这一段规定时间。区别在于在"),t("code",[e._v("wait()")]),e._v("中，对象锁已被解除，而且能够自由地退出"),t("code",[e._v("wait()")]),e._v("，因为一个"),t("code",[e._v("notify()")]),e._v("可强行使时间流逝。")]),e._v(" "),t("p",[e._v("第二种形式不采用任何参数，这意味着"),t("code",[e._v("wait()")]),e._v("会持续执行，直到"),t("code",[e._v("notify()")]),e._v("介入为止。而且在一段时间以后，不会自行中止。")]),e._v(" "),t("p",[t("code",[e._v("wait()")]),e._v("和"),t("code",[e._v("notify()")]),e._v("比较特别的一个地方是这两个方法都属于基类"),t("code",[e._v("Object")]),e._v("的一部分，不象"),t("code",[e._v("sleep()")]),e._v("，"),t("code",[e._v("suspend()")]),e._v("以及"),t("code",[e._v("resume()")]),e._v("那样属于"),t("code",[e._v("Thread")]),e._v("的一部分。尽管这表面看有点儿奇怪——居然让专门进行线程处理的东西成为通用基类的一部分——但仔细想想又会释然，因为它们操纵的对象锁也属于每个对象的一部分。因此，我们可将一个"),t("code",[e._v("wait()")]),e._v("置入任何同步方法内部，无论在那个类里是否准备进行涉及线程的处理。事实上，我们能调用"),t("code",[e._v("wait()")]),e._v("的唯一地方是在一个同步的方法或代码块内部。若在一个不同步的方法内调用"),t("code",[e._v("wait()")]),e._v("或者"),t("code",[e._v("notify()")]),e._v("，尽管程序仍然会编译，但在运行它的时候，就会得到一个"),t("code",[e._v("IllegalMonitorStateException")]),e._v("（非法监视器状态异常），而且会出现多少有点莫名其妙的一条消息："),t("code",[e._v("current thread not owner")]),e._v("（当前线程不是所有人”。注意"),t("code",[e._v("sleep()")]),e._v("，"),t("code",[e._v("suspend()")]),e._v("以及"),t("code",[e._v("resume()")]),e._v("都能在不同步的方法内调用，因为它们不需要对锁定进行操作。")]),e._v(" "),t("p",[e._v("只能为自己的锁定调用"),t("code",[e._v("wait()")]),e._v("和"),t("code",[e._v("notify()")]),e._v("。同样地，仍然可以编译那些试图使用错误锁定的代码，但和往常一样会产生同样的"),t("code",[e._v("IllegalMonitorStateException")]),e._v("异常。我们没办法用其他人的对象锁来愚弄系统，但可要求另一个对象执行相应的操作，对它自己的锁进行操作。所以一种做法是创建一个同步方法，令其为自己的对象调用"),t("code",[e._v("notify()")]),e._v("。但在"),t("code",[e._v("Notifier")]),e._v("中，我们会看到一个同步方法内部的"),t("code",[e._v("notify()")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("synchronized(wn2) {\n  wn2.notify();\n}\n")])])]),t("p",[e._v("其中，"),t("code",[e._v("wn2")]),e._v("是类型为"),t("code",[e._v("WaitNotify2")]),e._v("的对象。尽管并不属于"),t("code",[e._v("WaitNotify2")]),e._v("的一部分，这个方法仍然获得了"),t("code",[e._v("wn2")]),e._v("对象的锁定。在这个时候，它为"),t("code",[e._v("wn2")]),e._v("调用"),t("code",[e._v("notify()")]),e._v("是合法的，不会得到"),t("code",[e._v("IllegalMonitorStateException")]),e._v("异常。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("///:Continuing\n/////////// Blocking via wait() ///////////\nclass WaitNotify1 extends Blockable {\n  public WaitNotify1(Container c) { super(c); }\n  public synchronized void run() {\n    while(true) {\n      i++;\n      update();\n       try {\n        wait(1000);\n      } catch (InterruptedException e){}\n    }\n  }\n}\n\nclass WaitNotify2 extends Blockable {\n  public WaitNotify2(Container c) {\n    super(c);\n    new Notifier(this);\n  }\n  public synchronized void run() {\n    while(true) {\n      i++;\n      update();\n       try {\n        wait();\n      } catch (InterruptedException e){}\n    }\n  }\n}\n\nclass Notifier extends Thread {\n  private WaitNotify2 wn2;\n  public Notifier(WaitNotify2 wn2) {\n    this.wn2 = wn2;\n    start();\n  }\n  public void run() {\n    while(true) {\n       try {\n        sleep(2000);\n      } catch (InterruptedException e){}\n      synchronized(wn2) {\n        wn2.notify();\n      }\n    }\n  }\n} ///:Continued\n")])])]),t("p",[e._v("若必须等候其他某些条件（从线程外部加以控制）发生变化，同时又不想在线程内一直傻乎乎地等下去，一般就需要用到"),t("code",[e._v("wait()")]),e._v("。"),t("code",[e._v("wait()")]),e._v("允许我们将线程置入“睡眠”状态，同时又“积极”地等待条件发生改变。而且只有在一个"),t("code",[e._v("notify()")]),e._v("或"),t("code",[e._v("notifyAll()")]),e._v("发生变化的时候，线程才会被唤醒，并检查条件是否有变。因此，我们认为它提供了在线程间进行同步的一种手段。")]),e._v(" "),t("p",[e._v("(4) IO堵塞")]),e._v(" "),t("p",[e._v("若一个数据流必须等候一些IO活动，便会自动进入“堵塞”状态。在本例下面列出的部分中，有两个类协同通用的"),t("code",[e._v("Reader")]),e._v("以及"),t("code",[e._v("Writer")]),e._v("对象工作（使用Java 1.1的流）。但在测试模型中，会设置一个管道化的数据流，使两个线程相互间能安全地传递数据（这正是使用管道流的目的）。")]),e._v(" "),t("p",[t("code",[e._v("Sender")]),e._v("将数据置入"),t("code",[e._v("Writer")]),e._v("，并“睡眠”随机长短的时间。然而，"),t("code",[e._v("Receiver")]),e._v("本身并没有包括"),t("code",[e._v("sleep()")]),e._v("，"),t("code",[e._v("suspend()")]),e._v("或者"),t("code",[e._v("wait()")]),e._v("方法。但在执行"),t("code",[e._v("read()")]),e._v("的时候，如果没有数据存在，它会自动进入“堵塞”状态。如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("///:Continuing\nclass Sender extends Blockable { // send\n  private Writer out;\n  public Sender(Container c, Writer out) {\n    super(c);\n    this.out = out;\n  }\n  public void run() {\n    while(true) {\n      for(char c = 'A'; c <= 'z'; c++) {\n         try {\n          i++;\n          out.write(c);\n          state.setText(\"Sender sent: \"\n            + (char)c);\n          sleep((int)(3000 * Math.random()));\n        } catch (InterruptedException e){}\n          catch (IOException e) {}\n      }\n    }\n  }\n}\n\nclass Receiver extends Blockable {\n  private Reader in;\n  public Receiver(Container c, Reader in) {\n    super(c);\n    this.in = in;\n  }\n  public void run() {\n    try {\n      while(true) {\n        i++; // Show peeker it's alive\n        // Blocks until characters are there:\n        state.setText(\"Receiver read: \"\n          + (char)in.read());\n      }\n    } catch(IOException e) { e.printStackTrace();}\n  }\n} ///:Continued\n")])])]),t("p",[e._v("这两个类也将信息送入自己的"),t("code",[e._v("state")]),e._v("字段，并修改"),t("code",[e._v("i")]),e._v("值，使"),t("code",[e._v("Peeker")]),e._v("知道线程仍在运行。")]),e._v(" "),t("p",[e._v("(5) 测试")]),e._v(" "),t("p",[e._v("令人惊讶的是，主要的程序片（Applet）类非常简单，这是大多数工作都已置入"),t("code",[e._v("Blockable")]),e._v("框架的缘故。大概地说，我们创建了一个由"),t("code",[e._v("Blockable")]),e._v("对象构成的数组。而且由于每个对象都是一个线程，所以在按下"),t("code",[e._v('"start"')]),e._v("按钮后，它们会采取自己的行动。还有另一个按钮和"),t("code",[e._v("actionPerformed()")]),e._v("从句，用于中止所有"),t("code",[e._v("Peeker")]),e._v("对象。由于Java 1.2“反对”使用"),t("code",[e._v("Thread")]),e._v("的"),t("code",[e._v("stop()")]),e._v("方法，所以可考虑采用这种折衷形式的中止方式。")]),e._v(" "),t("p",[e._v("为了在"),t("code",[e._v("Sender")]),e._v("和"),t("code",[e._v("Receiver")]),e._v("之间建立一个连接，我们创建了一个"),t("code",[e._v("PipedWriter")]),e._v("和一个"),t("code",[e._v("PipedReader")]),e._v("。注意"),t("code",[e._v("PipedReader in")]),e._v("必须通过一个构造器参数同"),t("code",[e._v("PipedWriterout")]),e._v("连接起来。在那以后，我们在"),t("code",[e._v("out")]),e._v("内放进去的所有东西都可从"),t("code",[e._v("in")]),e._v("中提取出来——似乎那些东西是通过一个“管道”传输过去的。随后将"),t("code",[e._v("in")]),e._v("和"),t("code",[e._v("out")]),e._v("对象分别传递给"),t("code",[e._v("Receiver")]),e._v("和"),t("code",[e._v("Sender")]),e._v("构造器；后者将它们当作任意类型的"),t("code",[e._v("Reader")]),e._v("和"),t("code",[e._v("Writer")]),e._v("看待（也就是说，它们被“上溯”转换了）。")]),e._v(" "),t("p",[t("code",[e._v("Blockable")]),e._v("引用"),t("code",[e._v("b")]),e._v("的数组在定义之初并未得到初始化，因为管道化的数据流是不可在定义前设置好的（对"),t("code",[e._v("try")]),e._v("块的需要将成为障碍）：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('///:Continuing\n/////////// Testing Everything ///////////\npublic class Blocking extends Applet {\n  private Button\n    start = new Button("Start"),\n    stopPeekers = new Button("Stop Peekers");\n  private boolean started = false;\n  private Blockable[] b;\n  private PipedWriter out;\n  private PipedReader in;\n  public void init() {\n     out = new PipedWriter();\n    try {\n      in = new PipedReader(out);\n    } catch(IOException e) {}\n    b = new Blockable[] {\n      new Sleeper1(this),\n      new Sleeper2(this),\n      new SuspendResume1(this),\n      new SuspendResume2(this),\n      new WaitNotify1(this),\n      new WaitNotify2(this),\n      new Sender(this, out),\n      new Receiver(this, in)\n    };\n    start.addActionListener(new StartL());\n    add(start);\n    stopPeekers.addActionListener(\n      new StopPeekersL());\n    add(stopPeekers);\n  }\n  class StartL implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n      if(!started) {\n        started = true;\n        for(int i = 0; i < b.length; i++)\n          b[i].start();\n      }\n    }\n  }\n  class StopPeekersL implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n      // Demonstration of the preferred\n      // alternative to Thread.stop():\n      for(int i = 0; i < b.length; i++)\n        b[i].stopPeeker();\n    }\n  }\n  public static void main(String[] args) {\n    Blocking applet = new Blocking();\n    Frame aFrame = new Frame("Blocking");\n    aFrame.addWindowListener(\n      new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n          System.exit(0);\n        }\n      });\n    aFrame.add(applet, BorderLayout.CENTER);\n    aFrame.setSize(350,550);\n    applet.init();\n    applet.start();\n    aFrame.setVisible(true);\n  }\n} ///:~\n')])])]),t("p",[e._v("在"),t("code",[e._v("init()")]),e._v("中，注意循环会遍历整个数组，并为页添加"),t("code",[e._v("state")]),e._v("和"),t("code",[e._v("peeker.status")]),e._v("文本字段。")]),e._v(" "),t("p",[e._v("首次创建好"),t("code",[e._v("Blockable")]),e._v("线程以后，每个这样的线程都会自动创建并启动自己的"),t("code",[e._v("Peeker")]),e._v("。所以我们会看到各个"),t("code",[e._v("Peeker")]),e._v("都在"),t("code",[e._v("Blockable")]),e._v("线程启动之前运行起来。这一点非常重要，因为在"),t("code",[e._v("Blockable")]),e._v("线程启动的时候，部分"),t("code",[e._v("Peeker")]),e._v("会被堵塞，并停止运行。弄懂这一点，将有助于我们加深对“堵塞”这一概念的认识。")]),e._v(" "),t("h2",{attrs:{id:"_14-3-2-死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-2-死锁"}},[e._v("#")]),e._v(" 14.3.2 死锁")]),e._v(" "),t("p",[e._v("由于线程可能进入堵塞状态，而且由于对象可能拥有“同步”方法——除非同步锁定被解除，否则线程不能访问那个对象——所以一个线程完全可能等候另一个对象，而另一个对象又在等候下一个对象，以此类推。这个“等候”链最可怕的情形就是进入封闭状态——最后那个对象等候的是第一个对象！此时，所有线程都会陷入无休止的相互等待状态，大家都动弹不得。我们将这种情况称为“死锁”。尽管这种情况并非经常出现，但一旦碰到，程序的调试将变得异常艰难。")]),e._v(" "),t("p",[e._v("就语言本身来说，尚未直接提供防止死锁的帮助措施，需要我们通过谨慎的设计来避免。如果有谁需要调试一个死锁的程序，他是没有任何窍门可用的。")]),e._v(" "),t("p",[e._v("(1) Java 1.2对"),t("code",[e._v("stop()")]),e._v("，"),t("code",[e._v("suspend()")]),e._v("，"),t("code",[e._v("resume()")]),e._v("以及"),t("code",[e._v("destroy()")]),e._v("的反对")]),e._v(" "),t("p",[e._v("为减少出现死锁的可能，Java 1.2作出的一项贡献是“反对”使用"),t("code",[e._v("Thread")]),e._v("的"),t("code",[e._v("stop()")]),e._v("，"),t("code",[e._v("suspend()")]),e._v("，"),t("code",[e._v("resume()")]),e._v("以及"),t("code",[e._v("destroy()")]),e._v("方法。")]),e._v(" "),t("p",[e._v("之所以反对使用"),t("code",[e._v("stop()")]),e._v("，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态（“被析构”），那么其他线程能在那种状态下检查和修改它们。结果便造成了一种微妙的局面，我们很难检查出真正的问题所在。所以应尽量避免使用"),t("code",[e._v("stop()")]),e._v("，应该采用"),t("code",[e._v("Blocking.java")]),e._v("那样的方法，用一个标志告诉线程什么时候通过退出自己的"),t("code",[e._v("run()")]),e._v("方法来中止自己的执行。")]),e._v(" "),t("p",[e._v("如果一个线程被堵塞，比如在它等候输入的时候，那么一般都不能象在"),t("code",[e._v("Blocking.java")]),e._v("中那样轮询一个标志。但在这些情况下，我们仍然不该使用"),t("code",[e._v("stop()")]),e._v("，而应换用由"),t("code",[e._v("Thread")]),e._v("提供的"),t("code",[e._v("interrupt()")]),e._v("方法，以便中止并退出堵塞的代码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Interrupt.java\n// The alternative approach to using stop()\n// when a thread is blocked\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.applet.*;\n\nclass Blocked extends Thread {\n  public synchronized void run() {\n    try {\n      wait(); // Blocks\n    } catch(InterruptedException e) {\n      System.out.println("InterruptedException");\n    }\n    System.out.println("Exiting run()");\n  }\n}\n\npublic class Interrupt extends Applet {\n  private Button\n    interrupt = new Button("Interrupt");\n  private Blocked blocked = new Blocked();\n  public void init() {\n    add(interrupt);\n    interrupt.addActionListener(\n      new ActionListener() {\n        public\n        void actionPerformed(ActionEvent e) {\n          System.out.println("Button pressed");\n          if(blocked == null) return;\n          Thread remove = blocked;\n          blocked = null; // to release it\n          remove.interrupt();\n        }\n      });\n    blocked.start();\n  }\n  public static void main(String[] args) {\n    Interrupt applet = new Interrupt();\n    Frame aFrame = new Frame("Interrupt");\n    aFrame.addWindowListener(\n      new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n          System.exit(0);\n        }\n      });\n    aFrame.add(applet, BorderLayout.CENTER);\n    aFrame.setSize(200,100);\n    applet.init();\n    applet.start();\n    aFrame.setVisible(true);\n  }\n} ///:~\n')])])]),t("p",[t("code",[e._v("Blocked.run()")]),e._v("内部的"),t("code",[e._v("wait()")]),e._v("会产生堵塞的线程。当我们按下按钮以后，"),t("code",[e._v("blocked")]),e._v("（堵塞）的引用就会设为"),t("code",[e._v("null")]),e._v("，使垃圾收集器能够将其清除，然后调用对象的"),t("code",[e._v("interrupt()")]),e._v("方法。如果是首次按下按钮，我们会看到线程正常退出。但在没有可供“杀死”的线程以后，看到的便只是按钮被按下而已。")]),e._v(" "),t("p",[t("code",[e._v("suspend()")]),e._v("和"),t("code",[e._v("resume()")]),e._v("方法天生容易发生死锁。调用"),t("code",[e._v("suspend()")]),e._v("的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成令人难堪的死锁。所以我们不应该使用"),t("code",[e._v("suspend()")]),e._v("和"),t("code",[e._v("resume()")]),e._v("，而应在自己的"),t("code",[e._v("Thread")]),e._v("类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用"),t("code",[e._v("wait()")]),e._v("命其进入等待状态。若标志指出线程应当恢复，则用一个"),t("code",[e._v("notify()")]),e._v("重新启动线程。我们可以修改前面的"),t("code",[e._v("Counter2.java")]),e._v("来实际体验一番。尽管两个版本的效果是差不多的，但大家会注意到代码的组织结构发生了很大的变化——为所有“听众”都使用了匿名的内部类，而且"),t("code",[e._v("Thread")]),e._v("是一个内部类。这使得程序的编写稍微方便一些，因为它取消了"),t("code",[e._v("Counter2.java")]),e._v("中一些额外的记录工作。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Suspend.java\n// The alternative approach to using suspend()\n// and resume(), which have been deprecated\n// in Java 1.2.\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.applet.*;\n\npublic class Suspend extends Applet {\n  private TextField t = new TextField(10);\n  private Button\n    suspend = new Button("Suspend"),\n    resume = new Button("Resume");\n  class Suspendable extends Thread {\n    private int count = 0;\n    private boolean suspended = false;\n    public Suspendable() { start(); }\n    public void fauxSuspend() {\n      suspended = true;\n    }\n    public synchronized void fauxResume() {\n      suspended = false;\n      notify();\n    }\n    public void run() {\n      while (true) {\n        try {\n          sleep(100);\n          synchronized(this) {\n            while(suspended)\n              wait();\n          }\n        } catch (InterruptedException e){}\n        t.setText(Integer.toString(count++));\n      }\n    }\n  }\n  private Suspendable ss = new Suspendable();\n  public void init() {\n    add(t);\n    suspend.addActionListener(\n      new ActionListener() {\n        public\n        void actionPerformed(ActionEvent e) {\n          ss.fauxSuspend();\n        }\n      });\n    add(suspend);\n    resume.addActionListener(\n      new ActionListener() {\n        public\n        void actionPerformed(ActionEvent e) {\n          ss.fauxResume();\n        }\n      });\n    add(resume);\n  }\n  public static void main(String[] args) {\n    Suspend applet = new Suspend();\n    Frame aFrame = new Frame("Suspend");\n    aFrame.addWindowListener(\n      new WindowAdapter() {\n        public void windowClosing(WindowEvent e){\n          System.exit(0);\n        }\n      });\n    aFrame.add(applet, BorderLayout.CENTER);\n    aFrame.setSize(300,100);\n    applet.init();\n    applet.start();\n    aFrame.setVisible(true);\n  }\n} ///:~\n')])])]),t("p",[t("code",[e._v("Suspendable")]),e._v("中的"),t("code",[e._v("suspended")]),e._v("（已挂起）标志用于开关“挂起”或者“暂停”状态。为挂起一个线程，只需调用"),t("code",[e._v("fauxSuspend(")]),e._v(")将标志设为"),t("code",[e._v("true")]),e._v("（真）即可。对标志状态的侦测是在"),t("code",[e._v("run()")]),e._v("内进行的。就象本章早些时候提到的那样，"),t("code",[e._v("wait()")]),e._v("必须设为“同步”（"),t("code",[e._v("synchronized")]),e._v("），使其能够使用对象锁。在"),t("code",[e._v("fauxResume()")]),e._v("中，"),t("code",[e._v("suspended")]),e._v("标志被设为"),t("code",[e._v("false")]),e._v("（假），并调用"),t("code",[e._v("notify()")]),e._v("——由于这会在一个“同步”从句中唤醒"),t("code",[e._v("wait()")]),e._v("，所以"),t("code",[e._v("fauxResume()")]),e._v("方法也必须同步，使其能在调用"),t("code",[e._v("notify()")]),e._v("之前取得对象锁（这样一来，对象锁可由要唤醍的那个"),t("code",[e._v("wait()")]),e._v("使用）。如果遵照本程序展示的样式，可以避免使用"),t("code",[e._v("wait()")]),e._v("和"),t("code",[e._v("notify()")]),e._v("。")]),e._v(" "),t("p",[t("code",[e._v("Thread")]),e._v("的"),t("code",[e._v("destroy()")]),e._v("方法根本没有实现；它类似一个根本不能恢复的"),t("code",[e._v("suspend()")]),e._v("，所以会发生与"),t("code",[e._v("suspend()")]),e._v("一样的死锁问题。然而，这一方法没有得到明确的“反对”，也许会在Java以后的版本（1.2版以后）实现，用于一些可以承受死锁危险的特殊场合。")]),e._v(" "),t("p",[e._v("大家可能会奇怪当初为什么要实现这些现在又被“反对”的方法。之所以会出现这种情况，大概是由于Sun公司主要让技术人员来决定对语言的改动，而不是那些市场销售人员。通常，技术人员比搞销售的更能理解语言的实质。当初犯下了错误以后，也能较为理智地正视它们。这意味着Java能够继续进步，即便这使Java程序员多少感到有些不便。就我自己来说，宁愿面对这些不便之处，也不愿看到语言停滞不前。")])])}),[],!1,null,null,null);n.default=a.exports}}]);