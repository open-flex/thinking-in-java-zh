(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{439:function(e,n,t){"use strict";t.r(n);var c=t(56),o=Object(c.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_12-2-制作本地副本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-制作本地副本"}},[e._v("#")]),e._v(" 12.2 制作本地副本")]),e._v(" "),t("p",[e._v("稍微总结一下：Java中的所有参数传递都是通过传递引用进行的。也就是说，当我们传递“一个对象”时，实际传递的只是指向位于方法外部的那个对象的“一个引用”。所以一旦要对那个引用进行任何修改，便相当于修改外部对象。此外：")]),e._v(" "),t("ul",[t("li",[e._v("参数传递过程中会自动产生别名问题")]),e._v(" "),t("li",[e._v("不存在本地对象，只有本地引用")]),e._v(" "),t("li",[e._v("引用有自己的作用域，而对象没有")]),e._v(" "),t("li",[e._v("对象的“存在时间”在Java里不是个问题")]),e._v(" "),t("li",[e._v("没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用）")])]),e._v(" "),t("p",[e._v("若只是从对象中读取信息，而不修改它，传递引用便是参数传递中最有效的一种形式。这种做非常恰当；默认的方法一般也是最有效的方法。然而，有时仍需将对象当作“本地的”对待，使我们作出的改变只影响一个本地副本，不会对外面的对象造成影响。许多程序设计语言都支持在方法内自动生成外部对象的一个本地副本（注释①）。尽管Java不具备这种能力，但允许我们达到同样的效果。")]),e._v(" "),t("p",[e._v("①：在C语言中，通常控制的是少量数据位，默认操作是按值传递。C++也必须遵照这一形式，但按值传递对象并非肯定是一种有效的方式。此外，在C++中用于支持按值传递的代码也较难编写，是件让人头痛的事情。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-1-按值传递"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-1-按值传递"}},[e._v("#")]),e._v(" 12.2.1 按值传递")]),e._v(" "),t("p",[e._v("首先要解决术语的问题，最适合“按值传递”的看起来是参数。“按值传递”以及它的含义取决于如何理解程序的运行方式。最常见的意思是获得要传递的任何东西的一个本地副本，但这里真正的问题是如何看待自己准备传递的东西。对于“按值传递”的含义，目前存在两种存在明显区别的见解：")]),e._v(" "),t("p",[e._v("(1) Java按值传递任何东西。若将基本数据类型传递进入一个方法，会明确得到基本数据类型的一个副本。但若将一个引用传递进入方法，得到的是引用的副本。所以人们认为“一切”都按值传递。当然，这种说法也有一个前提：引用肯定也会被传递。但Java的设计模式似乎有些超前，允许我们忽略（大多数时候）自己处理的是一个引用。也就是说，它允许我们将引用假想成“对象”，因为在发出方法调用时，系统会自动照管两者间的差异。")]),e._v(" "),t("p",[e._v("(2) Java主要按值传递（无参数），但对象却是按引用传递的。得到这个结论的前提是引用只是对象的一个“别名”，所以不考虑传递引用的问题，而是直接指出“我准备传递对象”。由于将其传递进入一个方法时没有获得对象的一个本地副本，所以对象显然不是按值传递的。Sun公司似乎在某种程度上支持这一见解，因为它“保留但未实现”的关键字之一便是"),t("code",[e._v("byvalue")]),e._v("（按值）。但没人知道那个关键字什么时候可以发挥作用。")]),e._v(" "),t("p",[e._v("尽管存在两种不同的见解，但其间的分歧归根到底是由于对“引用”的不同解释造成的。我打算在本书剩下的部分里回避这个问题。大家不久就会知道，这个问题争论下去其实是没有意义的——最重要的是理解一个引用的传递会使调用者的对象发生意外的改变。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-2-克隆对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-2-克隆对象"}},[e._v("#")]),e._v(" 12.2.2 克隆对象")]),e._v(" "),t("p",[e._v("若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见的一种用途。若决定制作一个本地副本，只需简单地使用"),t("code",[e._v("clone()")]),e._v("方法即可。"),t("code",[e._v("Clone")]),e._v("是“克隆”的意思，即制作完全一模一样的副本。这个方法在基类"),t("code",[e._v("Object")]),e._v("中定义成"),t("code",[e._v("protected")]),e._v("（受保护）模式。但在希望克隆的任何派生类中，必须将其覆盖为"),t("code",[e._v("public")]),e._v("模式。例如，标准库类"),t("code",[e._v("Vector")]),e._v("覆盖了"),t("code",[e._v("clone()")]),e._v("，所以能为"),t("code",[e._v("Vector")]),e._v("调用"),t("code",[e._v("clone()")]),e._v("，如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Cloning.java\n// The clone() operation works for only a few\n// items in the standard Java library.\nimport java.util.*;\n\nclass Int {\n  private int i;\n  public Int(int ii) { i = ii; }\n  public void increment() { i++; }\n  public String toString() {\n    return Integer.toString(i);\n  }\n}\n\npublic class Cloning {\n  public static void main(String[] args) {\n    Vector v = new Vector();\n    for(int i = 0; i < 10; i++ )\n      v.addElement(new Int(i));\n    System.out.println("v: " + v);\n    Vector v2 = (Vector)v.clone();\n    // Increment all v2\'s elements:\n    for(Enumeration e = v2.elements();\n        e.hasMoreElements(); )\n      ((Int)e.nextElement()).increment();\n    // See if it changed v\'s elements:\n    System.out.println("v: " + v);\n  }\n} ///:~\n')])])]),t("p",[t("code",[e._v("clone()")]),e._v("方法产生了一个"),t("code",[e._v("Object")]),e._v("，后者必须立即重新转换为正确类型。这个例子指出"),t("code",[e._v("Vector")]),e._v("的"),t("code",[e._v("clone()")]),e._v("方法不能自动尝试克隆"),t("code",[e._v("Vector")]),e._v("内包含的每个对象——由于别名问题，老的"),t("code",[e._v("Vector")]),e._v("和克隆的"),t("code",[e._v("Vector")]),e._v("都包含了相同的对象。我们通常把这种情况叫作“简单复制”或者“浅层复制”，因为它只复制了一个对象的“表面”部分。实际对象除包含这个“表面”以外，还包括引用指向的所有对象，以及那些对象又指向的其他所有对象，由此类推。这便是“对象网”或“对象关系网”的由来。若能复制下所有这张网，便叫作“全面复制”或者“深层复制”。")]),e._v(" "),t("p",[e._v("在输出中可看到浅层复制的结果，注意对"),t("code",[e._v("v2")]),e._v("采取的行动也会影响到"),t("code",[e._v("v")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("v: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nv: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n")])])]),t("p",[e._v("一般来说，由于不敢保证"),t("code",[e._v("Vector")]),e._v("里包含的对象是“可以克隆”（注释②）的，所以最好不要试图克隆那些对象。")]),e._v(" "),t("p",[e._v("②：“可以克隆”用英语讲是"),t("code",[e._v("cloneable")]),e._v("，请留意Java库中专门保留了这样的一个关键字。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-3-使类具有克隆能力"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-3-使类具有克隆能力"}},[e._v("#")]),e._v(" 12.2.3 使类具有克隆能力")]),e._v(" "),t("p",[e._v("尽管克隆方法是在所有类最基本的"),t("code",[e._v("Object")]),e._v("中定义的，但克隆仍然不会在每个类里自动进行。这似乎有些不可思议，因为基类方法在派生类里是肯定能用的。但Java确实有点儿反其道而行之；如果想在一个类里使用克隆方法，唯一的办法就是专门添加一些代码，以便保证克隆的正常进行。")]),e._v(" "),t("p",[e._v("(1) 使用"),t("code",[e._v("protected")]),e._v("时的技巧")]),e._v(" "),t("p",[e._v("为避免我们创建的每个类都默认具有克隆能力，"),t("code",[e._v("clone()")]),e._v("方法在基类"),t("code",[e._v("Object")]),e._v("里得到了“保留”（设为"),t("code",[e._v("protected")]),e._v("）。这样造成的后果就是：对那些简单地使用一下这个类的客户程序员来说，他们不会默认地拥有这个方法；其次，我们不能利用指向基类的一个引用来调用"),t("code",[e._v("clone()")]),e._v("（尽管那样做在某些情况下特别有用，比如用多态性的方式克隆一系列对象）。在编译期的时候，这实际是通知我们对象不可克隆的一种方式——而且最奇怪的是，Java库中的大多数类都不能克隆。因此，假如我们执行下述代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Integer x = new Integer(l);\nx = x.clone();\n")])])]),t("p",[e._v("那么在编译期，就有一条讨厌的错误消息弹出，告诉我们不可访问"),t("code",[e._v("clone()")]),e._v("——因为"),t("code",[e._v("Integer")]),e._v("并没有覆盖它，而且它对"),t("code",[e._v("protected")]),e._v("版本来说是默认的）。")]),e._v(" "),t("p",[e._v("但是，假若我们是在一个从"),t("code",[e._v("Object")]),e._v("派生出来的类中（所有类都是从"),t("code",[e._v("Object")]),e._v("派生的），就有权调用"),t("code",[e._v("Object.clone()")]),e._v("，因为它是"),t("code",[e._v("protected")]),e._v("，而且我们在一个迭代器中。基类"),t("code",[e._v("clone()")]),e._v("提供了一个有用的功能——它进行的是对派生类对象的真正“按位”复制，所以相当于标准的克隆行动。然而，我们随后需要将自己的克隆操作设为"),t("code",[e._v("public")]),e._v("，否则无法访问。总之，克隆时要注意的两个关键问题是：几乎肯定要调用"),t("code",[e._v("super.clone()")]),e._v("，以及注意将克隆设为"),t("code",[e._v("public")]),e._v("。")]),e._v(" "),t("p",[e._v("有时还想在更深层的派生类中覆盖"),t("code",[e._v("clone()")]),e._v("，否则就直接使用我们的"),t("code",[e._v("clone()")]),e._v("（现在已成为"),t("code",[e._v("public")]),e._v("），而那并不一定是我们所希望的（然而，由于"),t("code",[e._v("Object.clone()")]),e._v("已制作了实际对象的一个副本，所以也有可能允许这种情况）。"),t("code",[e._v("protected")]),e._v("的技巧在这里只能用一次：首次从一个不具备克隆能力的类继承，而且想使一个类变成“能够克隆”。而在从我们的类继承的任何场合，"),t("code",[e._v("clone()")]),e._v("方法都是可以使用的，因为Java不可能在派生之后反而缩小方法的访问范围。换言之，一旦对象变得可以克隆，从它派生的任何东西都是能够克隆的，除非使用特殊的机制（后面讨论）令其“关闭”克隆能力。")]),e._v(" "),t("p",[e._v("(2) 实现"),t("code",[e._v("Cloneable")]),e._v("接口")]),e._v(" "),t("p",[e._v("为使一个对象的克隆能力功成圆满，还需要做另一件事情：实现"),t("code",[e._v("Cloneable")]),e._v("接口。这个接口使人稍觉奇怪，因为它是空的！")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface Cloneable {}\n")])])]),t("p",[e._v("之所以要实现这个空接口，显然不是因为我们准备向上转换成一个"),t("code",[e._v("Cloneable")]),e._v("，以及调用它的某个方法。有些人认为在这里使用接口属于一种“欺骗”行为，因为它使用的特性打的是别的主意，而非原来的意思。"),t("code",[e._v("Cloneable interface")]),e._v("的实现扮演了一个标记的角色，封装到类的类型中。")]),e._v(" "),t("p",[e._v("两方面的原因促成了"),t("code",[e._v("Cloneable interface")]),e._v("的存在。首先，可能有一个向上转换引用指向一个基类型，而且不知道它是否真的能克隆那个对象。在这种情况下，可用"),t("code",[e._v("instanceof")]),e._v("关键字（第11章有介绍）调查引用是否确实同一个能克隆的对象连接：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if(myHandle instanceof Cloneable) // ...\n")])])]),t("p",[e._v("第二个原因是考虑到我们可能不愿所有对象类型都能克隆。所以"),t("code",[e._v("Object.clone()")]),e._v("会验证一个类是否真的是实现了"),t("code",[e._v("Cloneable")]),e._v("接口。若答案是否定的，则“抛”出一个"),t("code",[e._v("CloneNotSupportedException")]),e._v("异常。所以在一般情况下，我们必须将"),t("code",[e._v("implement Cloneable")]),e._v("作为对克隆能力提供支持的一部分。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-4-成功的克隆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-4-成功的克隆"}},[e._v("#")]),e._v(" 12.2.4 成功的克隆")]),e._v(" "),t("p",[e._v("理解了实现"),t("code",[e._v("clone()")]),e._v("方法背后的所有细节后，便可创建出能方便复制的类，以便提供了一个本地副本：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: LocalCopy.java\n// Creating local copies with clone()\nimport java.util.*;\n\nclass MyObject implements Cloneable {\n  int i;\n  MyObject(int ii) { i = ii; }\n  public Object clone() {\n    Object o = null;\n    try {\n      o = super.clone();\n    } catch (CloneNotSupportedException e) {\n      System.out.println("MyObject can\'t clone");\n    }\n    return o;\n  }\n  public String toString() {\n    return Integer.toString(i);\n  }\n}\n\npublic class LocalCopy {\n  static MyObject g(MyObject v) {\n    // Passing a handle, modifies outside object:\n    v.i++;\n    return v;\n  }\n  static MyObject f(MyObject v) {\n    v = (MyObject)v.clone(); // Local copy\n    v.i++;\n    return v;\n  }\n  public static void main(String[] args) {\n    MyObject a = new MyObject(11);\n    MyObject b = g(a);\n    // Testing handle equivalence,\n    // not object equivalence:\n    if(a == b)\n      System.out.println("a == b");\n    else\n      System.out.println("a != b");\n    System.out.println("a = " + a);\n    System.out.println("b = " + b);\n    MyObject c = new MyObject(47);\n    MyObject d = f(c);\n    if(c == d)\n      System.out.println("c == d");\n    else\n      System.out.println("c != d");\n    System.out.println("c = " + c);\n    System.out.println("d = " + d);\n  }\n} ///:~\n')])])]),t("p",[e._v("不管怎样，"),t("code",[e._v("clone()")]),e._v("必须能够访问，所以必须将其设为"),t("code",[e._v("public")]),e._v("（公共的）。其次，作为"),t("code",[e._v("clone()")]),e._v("的初期行动，应调用"),t("code",[e._v("clone()")]),e._v("的基类版本。这里调用的"),t("code",[e._v("clone()")]),e._v("是"),t("code",[e._v("Object")]),e._v("内部预先定义好的。之所以能调用它，是由于它具有"),t("code",[e._v("protected")]),e._v("（受到保护的）属性，所以能在派生的类里访问。")]),e._v(" "),t("p",[t("code",[e._v("Object.clone()")]),e._v("会检查原先的对象有多大，再为新对象腾出足够多的内存，将所有二进制位从原来的对象复制到新对象。这叫作“按位复制”，而且按一般的想法，这个工作应该是由"),t("code",[e._v("clone()")]),e._v("方法来做的。但在"),t("code",[e._v("Object.clone()")]),e._v("正式开始操作前，首先会检查一个类是否"),t("code",[e._v("Cloneable")]),e._v("，即是否具有克隆能力——换言之，它是否实现了"),t("code",[e._v("Cloneable")]),e._v("接口。若未实现，"),t("code",[e._v("Object.clone()")]),e._v("就抛出一个"),t("code",[e._v("CloneNotSupportedException")]),e._v("异常，指出我们不能克隆它。因此，我们最好用一个"),t("code",[e._v("try-catch")]),e._v("块将对"),t("code",[e._v("super.clone()")]),e._v("的调用代码包围（或封装）起来，试图捕获一个应当永不出现的异常（因为这里确实已实现了"),t("code",[e._v("Cloneable")]),e._v("接口）。")]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("LocalCopy")]),e._v("中，两个方法"),t("code",[e._v("g()")]),e._v("和"),t("code",[e._v("f()")]),e._v("揭示出两种参数传递方法间的差异。其中，"),t("code",[e._v("g()")]),e._v("演示的是按引用传递，它会修改外部对象，并返回对那个外部对象的一个引用。而"),t("code",[e._v("f()")]),e._v("是对参数进行克隆，所以将其分离出来，并让原来的对象保持独立。随后，它继续做它希望的事情。甚至能返回指向这个新对象的一个引用，而且不会对原来的对象产生任何副作用。注意下面这个多少有些古怪的语句：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("v = (MyObject)v.clone();\n")])])]),t("p",[e._v("它的作用正是创建一个本地副本。为避免被这样的一个语句搞混淆，记住这种相当奇怪的编码形式在Java中是完全允许的，因为有一个名字的所有东西实际都是一个引用。所以引用"),t("code",[e._v("v")]),e._v("用于克隆一个它所指向的副本，而且最终返回指向基类型"),t("code",[e._v("Object")]),e._v("的一个引用（因为它在"),t("code",[e._v("Object.clone()")]),e._v("中是那样被定义的），随后必须将其转换为正确的类型。")]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("main()")]),e._v("中，两种不同参数传递方式的区别在于它们分别测试了一个不同的方法。输出结果如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("a == b\na = 12\nb = 12\nc != d\nc = 47\nd = 48\n")])])]),t("p",[e._v("大家要记住这样一个事实：Java对“是否等价”的测试并不对所比较对象的内部进行检查，从而核实它们的值是否相同。"),t("code",[e._v("==")]),e._v("和"),t("code",[e._v("!=")]),e._v("运算符只是简单地对比引用的内容。若引用内的地址相同，就认为引用指向同样的对象，所以认为它们是“等价”的。所以运算符真正检测的是“由于别名问题，引用是否指向同一个对象？”")]),e._v(" "),t("h2",{attrs:{id:"_12-2-5-object-clone-的效果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-5-object-clone-的效果"}},[e._v("#")]),e._v(" 12.2.5 "),t("code",[e._v("Object.clone()")]),e._v("的效果")]),e._v(" "),t("p",[e._v("调用"),t("code",[e._v("Object.clone()")]),e._v("时，实际发生的是什么事情呢？当我们在自己的类里覆盖"),t("code",[e._v("clone()")]),e._v("时，什么东西对于"),t("code",[e._v("super.clone()")]),e._v("来说是最关键的呢？根类中的"),t("code",[e._v("clone()")]),e._v("方法负责建立正确的存储容量，并通过“按位复制”将二进制位从原始对象中复制到新对象的存储空间。也就是说，它并不只是预留存储空间以及复制一个对象——实际需要调查出欲复制之对象的准确大小，然后复制那个对象。由于所有这些工作都是在由根类定义之"),t("code",[e._v("clone()")]),e._v("方法的内部代码中进行的（根类并不知道要从自己这里继承出去什么），所以大家或许已经猜到，这个过程需要用RTTI判断欲克隆的对象的实际大小。采取这种方式，"),t("code",[e._v("clone()")]),e._v("方法便可建立起正确数量的存储空间，并对那个类型进行正确的按位复制。")]),e._v(" "),t("p",[e._v("不管我们要做什么，克隆过程的第一个部分通常都应该是调用"),t("code",[e._v("super.clone()")]),e._v("。通过进行一次准确的复制，这样做可为后续的克隆进程建立起一个良好的基础。随后，可采取另一些必要的操作，以完成最终的克隆。")]),e._v(" "),t("p",[e._v("为确切了解其他操作是什么，首先要正确理解"),t("code",[e._v("Object.clone()")]),e._v("为我们带来了什么。特别地，它会自动克隆所有引用指向的目标吗？下面这个例子可完成这种形式的检测：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Snake.java\n// Tests cloning to see if destination of\n// handles are also cloned.\n\npublic class Snake implements Cloneable {\n  private Snake next;\n  private char c;\n  // Value of i == number of segments\n  Snake(int i, char x) {\n    c = x;\n    if(--i > 0)\n      next = new Snake(i, (char)(x + 1));\n  }\n  void increment() {\n    c++;\n    if(next != null)\n      next.increment();\n  }\n  public String toString() {\n    String s = ":" + c;\n    if(next != null)\n      s += next.toString();\n    return s;\n  }\n  public Object clone() {\n    Object o = null;\n    try {\n      o = super.clone();\n    } catch (CloneNotSupportedException e) {}\n    return o;\n  }\n  public static void main(String[] args) {\n    Snake s = new Snake(5, \'a\');\n    System.out.println("s = " + s);\n    Snake s2 = (Snake)s.clone();\n    System.out.println("s2 = " + s2);\n    s.increment();\n    System.out.println(\n      "after s.increment, s2 = " + s2);\n  }\n} ///:~\n')])])]),t("p",[e._v("一条"),t("code",[e._v("Snake")]),e._v("（蛇）由数段构成，每一段的类型都是"),t("code",[e._v("Snake")]),e._v("。所以，这是一个一段段链接起来的列表。所有段都是以循环方式创建的，每做好一段，都会使第一个构造器参数的值递减，直至最终为零。而为给每段赋予一个独一无二的标记，第二个参数（一个"),t("code",[e._v("Char")]),e._v("）的值在每次循环构造器调用时都会递增。")]),e._v(" "),t("p",[t("code",[e._v("increment()")]),e._v("方法的作用是循环递增每个标记，使我们能看到发生的变化；而"),t("code",[e._v("toString")]),e._v("则循环打印出每个标记。输出如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("s = :a:b:c:d:e\ns2 = :a:b:c:d:e\nafter s.increment, s2 = :a:c:d:e:f\n")])])]),t("p",[e._v("这意味着只有第一段才是由"),t("code",[e._v("Object.clone()")]),e._v("复制的，所以此时进行的是一种“浅层复制”。若希望复制整条蛇——即进行“深层复制”——必须在被覆盖的"),t("code",[e._v("clone()")]),e._v("里采取附加的操作。")]),e._v(" "),t("p",[e._v("通常可在从一个能克隆的类里调用"),t("code",[e._v("super.clone()")]),e._v("，以确保所有基类行动（包括"),t("code",[e._v("Object.clone()")]),e._v("）能够进行。随着是为对象内每个引用都明确调用一个"),t("code",[e._v("clone()")]),e._v("；否则那些引用会别名变成原始对象的引用。构造器的调用也大致相同——首先构造基类，然后是下一个派生的构造器……以此类推，直到位于最深层的派生构造器。区别在于"),t("code",[e._v("clone()")]),e._v("并不是个构造器，所以没有办法实现自动克隆。为了克隆，必须由自己明确进行。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-6-克隆组合对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-6-克隆组合对象"}},[e._v("#")]),e._v(" 12.2.6 克隆组合对象")]),e._v(" "),t("p",[e._v("试图深层复制组合对象时会遇到一个问题。必须假定成员对象中的"),t("code",[e._v("clone()")]),e._v("方法也能依次对自己的引用进行深层复制，以此类推。这使我们的操作变得复杂。为了能正常实现深层复制，必须对所有类中的代码进行控制，或者至少全面掌握深层复制中需要涉及的类，确保它们自己的深层复制能正确进行。")]),e._v(" "),t("p",[e._v("下面这个例子总结了面对一个组合对象进行深层复制时需要做哪些事情：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//: DeepCopy.java\n// Cloning a composed object\n\nclass DepthReading implements Cloneable {\n  private double depth;\n  public DepthReading(double depth) {\n    this.depth = depth;\n  }\n  public Object clone() {\n    Object o = null;\n    try {\n      o = super.clone();\n    } catch (CloneNotSupportedException e) {\n      e.printStackTrace();\n    }\n    return o;\n  }\n}\n\nclass TemperatureReading implements Cloneable {\n  private long time;\n  private double temperature;\n  public TemperatureReading(double temperature) {\n    time = System.currentTimeMillis();\n    this.temperature = temperature;\n  }\n  public Object clone() {\n    Object o = null;\n    try {\n      o = super.clone();\n    } catch (CloneNotSupportedException e) {\n      e.printStackTrace();\n    }\n    return o;\n  }\n}\n\nclass OceanReading implements Cloneable {\n  private DepthReading depth;\n  private TemperatureReading temperature;\n  public OceanReading(double tdata, double ddata){\n    temperature = new TemperatureReading(tdata);\n    depth = new DepthReading(ddata);\n  }\n  public Object clone() {\n    OceanReading o = null;\n    try {\n      o = (OceanReading)super.clone();\n    } catch (CloneNotSupportedException e) {\n      e.printStackTrace();\n    }\n    // Must clone handles:\n    o.depth = (DepthReading)o.depth.clone();\n    o.temperature =\n      (TemperatureReading)o.temperature.clone();\n    return o; // Upcasts back to Object\n  }\n}\n\npublic class DeepCopy {\n  public static void main(String[] args) {\n    OceanReading reading =\n      new OceanReading(33.9, 100.5);\n    // Now clone it:\n    OceanReading r =\n      (OceanReading)reading.clone();\n  }\n} ///:~\n")])])]),t("p",[t("code",[e._v("DepthReading")]),e._v("和"),t("code",[e._v("TemperatureReading")]),e._v("非常相似；它们都只包含了基本数据类型。所以"),t("code",[e._v("clone()")]),e._v("方法能够非常简单：调用"),t("code",[e._v("super.clone()")]),e._v("并返回结果即可。注意两个类使用的"),t("code",[e._v("clone()")]),e._v("代码是完全一致的。")]),e._v(" "),t("p",[t("code",[e._v("OceanReading")]),e._v("是由"),t("code",[e._v("DepthReading")]),e._v("和"),t("code",[e._v("TemperatureReading")]),e._v("对象合并而成的。为了对其进行深层复制，"),t("code",[e._v("clone()")]),e._v("必须同时克隆"),t("code",[e._v("OceanReading")]),e._v("内的引用。为达到这个目标，"),t("code",[e._v("super.clone()")]),e._v("的结果必须转换成一个"),t("code",[e._v("OceanReading")]),e._v("对象（以便访问"),t("code",[e._v("depth")]),e._v("和"),t("code",[e._v("temperature")]),e._v("引用）。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-7-用vector进行深层复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-7-用vector进行深层复制"}},[e._v("#")]),e._v(" 12.2.7 用"),t("code",[e._v("Vector")]),e._v("进行深层复制")]),e._v(" "),t("p",[e._v("下面让我们复习一下本章早些时候提出的"),t("code",[e._v("Vector")]),e._v("例子。这一次"),t("code",[e._v("Int2")]),e._v("类是可以克隆的，所以能对"),t("code",[e._v("Vector")]),e._v("进行深层复制：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: AddingClone.java\n// You must go through a few gyrations to\n// add cloning to your own class.\nimport java.util.*;\n\nclass Int2 implements Cloneable {\n  private int i;\n  public Int2(int ii) { i = ii; }\n  public void increment() { i++; }\n  public String toString() {\n    return Integer.toString(i);\n  }\n  public Object clone() {\n    Object o = null;\n    try {\n      o = super.clone();\n    } catch (CloneNotSupportedException e) {\n      System.out.println("Int2 can\'t clone");\n    }\n    return o;\n  }\n}\n\n// Once it\'s cloneable, inheritance\n// doesn\'t remove cloneability:\nclass Int3 extends Int2 {\n  private int j; // Automatically duplicated\n  public Int3(int i) { super(i); }\n}\n\npublic class AddingClone {\n  public static void main(String[] args) {\n    Int2 x = new Int2(10);\n    Int2 x2 = (Int2)x.clone();\n    x2.increment();\n    System.out.println(\n      "x = " + x + ", x2 = " + x2);\n    // Anything inherited is also cloneable:\n    Int3 x3 = new Int3(7);\n    x3 = (Int3)x3.clone();\n\n    Vector v = new Vector();\n    for(int i = 0; i < 10; i++ )\n      v.addElement(new Int2(i));\n    System.out.println("v: " + v);\n    Vector v2 = (Vector)v.clone();\n    // Now clone each element:\n    for(int i = 0; i < v.size(); i++)\n      v2.setElementAt(\n        ((Int2)v2.elementAt(i)).clone(), i);\n    // Increment all v2\'s elements:\n    for(Enumeration e = v2.elements();\n        e.hasMoreElements(); )\n      ((Int2)e.nextElement()).increment();\n    // See if it changed v\'s elements:\n    System.out.println("v: " + v);\n    System.out.println("v2: " + v2);\n  }\n} ///:~\n')])])]),t("p",[t("code",[e._v("Int3")]),e._v("自"),t("code",[e._v("Int2")]),e._v("继承而来，并添加了一个新的基本类型成员"),t("code",[e._v("int j")]),e._v("。大家也许认为自己需要再次覆盖"),t("code",[e._v("clone()")]),e._v("，以确保"),t("code",[e._v("j")]),e._v("得到复制，但实情并非如此。将"),t("code",[e._v("Int2")]),e._v("的"),t("code",[e._v("clone()")]),e._v("当作"),t("code",[e._v("Int3")]),e._v("的"),t("code",[e._v("clone()")]),e._v("调用时，它会调用"),t("code",[e._v("Object.clone()")]),e._v("，判断出当前操作的是"),t("code",[e._v("Int3")]),e._v("，并复制"),t("code",[e._v("Int3")]),e._v("内的所有二进制位。只要没有新增需要克隆的引用，对"),t("code",[e._v("Object.clone()")]),e._v("的一个调用就能完成所有必要的复制——无论"),t("code",[e._v("clone()")]),e._v("是在层次结构多深的一级定义的。")]),e._v(" "),t("p",[e._v("至此，大家可以总结出对"),t("code",[e._v("Vector")]),e._v("进行深层复制的先决条件：在克隆了"),t("code",[e._v("Vector")]),e._v("后，必须在其中遍历，并克隆由"),t("code",[e._v("Vector")]),e._v("指向的每个对象。为了对"),t("code",[e._v("Hashtable")]),e._v("（散列表）进行深层复制，也必须采取类似的处理。")]),e._v(" "),t("p",[e._v("这个例子剩余的部分显示出克隆已实际进行——证据就是在克隆了对象以后，可以自由改变它，而原来那个对象不受任何影响。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-8-通过序列化进行深层复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-8-通过序列化进行深层复制"}},[e._v("#")]),e._v(" 12.2.8 通过序列化进行深层复制")]),e._v(" "),t("p",[e._v("若研究一下第10章介绍的那个Java 1.1对象序列化示例，可能发现若在一个对象序列化以后再撤消对它的序列化，或者说进行装配，那么实际经历的正是一个“克隆”的过程。")]),e._v(" "),t("p",[e._v("那么为什么不用序列化进行深层复制呢？下面这个例子通过计算执行时间对比了这两种方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Compete.java\nimport java.io.*;\n\nclass Thing1 implements Serializable {}\nclass Thing2 implements Serializable {\n  Thing1 o1 = new Thing1();\n}\n\nclass Thing3 implements Cloneable {\n  public Object clone() {\n    Object o = null;\n    try {\n      o = super.clone();\n    } catch (CloneNotSupportedException e) {\n      System.out.println("Thing3 can\'t clone");\n    }\n    return o;\n  }\n}\n\nclass Thing4 implements Cloneable {\n  Thing3 o3 = new Thing3();\n  public Object clone() {\n    Thing4 o = null;\n    try {\n      o = (Thing4)super.clone();\n    } catch (CloneNotSupportedException e) {\n      System.out.println("Thing4 can\'t clone");\n    }\n    // Clone the field, too:\n    o.o3 = (Thing3)o3.clone();\n    return o;\n  }\n}\n\npublic class Compete {\n  static final int SIZE = 5000;\n  public static void main(String[] args) {\n    Thing2[] a = new Thing2[SIZE];\n    for(int i = 0; i < a.length; i++)\n      a[i] = new Thing2();\n    Thing4[] b = new Thing4[SIZE];\n    for(int i = 0; i < b.length; i++)\n      b[i] = new Thing4();\n    try {\n      long t1 = System.currentTimeMillis();\n      ByteArrayOutputStream buf =\n        new ByteArrayOutputStream();\n      ObjectOutputStream o =\n        new ObjectOutputStream(buf);\n      for(int i = 0; i < a.length; i++)\n        o.writeObject(a[i]);\n      // Now get copies:\n      ObjectInputStream in =\n        new ObjectInputStream(\n          new ByteArrayInputStream(\n            buf.toByteArray()));\n      Thing2[] c = new Thing2[SIZE];\n      for(int i = 0; i < c.length; i++)\n        c[i] = (Thing2)in.readObject();\n      long t2 = System.currentTimeMillis();\n      System.out.println(\n        "Duplication via serialization: " +\n        (t2 - t1) + " Milliseconds");\n      // Now try cloning:\n      t1 = System.currentTimeMillis();\n      Thing4[] d = new Thing4[SIZE];\n      for(int i = 0; i < d.length; i++)\n        d[i] = (Thing4)b[i].clone();\n      t2 = System.currentTimeMillis();\n      System.out.println(\n        "Duplication via cloning: " +\n        (t2 - t1) + " Milliseconds");\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n} ///:~\n')])])]),t("p",[e._v("其中，"),t("code",[e._v("Thing2")]),e._v("和"),t("code",[e._v("Thing4")]),e._v("包含了成员对象，所以需要进行一些深层复制。一个有趣的地方是尽管"),t("code",[e._v("Serializable")]),e._v("类很容易设置，但在复制它们时却要做多得多的工作。克隆涉及到大量的类设置工作，但实际的对象复制是相当简单的。结果很好地说明了一切。下面是几次运行分别得到的结果：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Duplication via serialization: 3400 Milliseconds\nDuplication via cloning: 110 Milliseconds\n\nDuplication via serialization: 3410 Milliseconds\nDuplication via cloning: 110 Milliseconds\n\nDuplication via serialization: 3520 Milliseconds\nDuplication via cloning: 110 Milliseconds\n")])])]),t("p",[e._v("除了序列化和克隆之间巨大的时间差异以外，我们也注意到序列化技术的运行结果并不稳定，而克隆每一次花费的时间都是相同的。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-9-使克隆具有更大的深度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-9-使克隆具有更大的深度"}},[e._v("#")]),e._v(" 12.2.9 使克隆具有更大的深度")]),e._v(" "),t("p",[e._v("若新建一个类，它的基类会默认为"),t("code",[e._v("Object")]),e._v("，并默认为不具备克隆能力（就象在下一节会看到的那样）。只要不明确地添加克隆能力，这种能力便不会自动产生。但我们可以在任何层添加它，然后便可从那个层开始向下具有克隆能力。如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//: HorrorFlick.java\n// You can insert Cloneability at any\n// level of inheritance.\nimport java.util.*;\n\nclass Person {}\nclass Hero extends Person {}\nclass Scientist extends Person\n    implements Cloneable {\n  public Object clone() {\n    try {\n      return super.clone();\n    } catch (CloneNotSupportedException e) {\n      // this should never happen:\n      // It's Cloneable already!\n      throw new InternalError();\n    }\n  }\n}\nclass MadScientist extends Scientist {}\n\npublic class HorrorFlick {\n  public static void main(String[] args) {\n    Person p = new Person();\n    Hero h = new Hero();\n    Scientist s = new Scientist();\n    MadScientist m = new MadScientist();\n\n    // p = (Person)p.clone(); // Compile error\n    // h = (Hero)h.clone(); // Compile error\n    s = (Scientist)s.clone();\n    m = (MadScientist)m.clone();\n  }\n} ///:~\n")])])]),t("p",[e._v("添加克隆能力之前，编译器会阻止我们的克隆尝试。一旦在"),t("code",[e._v("Scientist")]),e._v("里添加了克隆能力，那么"),t("code",[e._v("Scientist")]),e._v("以及它的所有“后裔”都可以克隆。")]),e._v(" "),t("h2",{attrs:{id:"_12-2-10-为什么有这个奇怪的设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-10-为什么有这个奇怪的设计"}},[e._v("#")]),e._v(" 12.2.10 为什么有这个奇怪的设计")]),e._v(" "),t("p",[e._v("之所以感觉这个方案的奇特，因为它事实上的确如此。也许大家会奇怪它为什么要象这样运行，而该方案背后的真正含义是什么呢？后面讲述的是一个未获证实的故事——大概是由于围绕Java的许多买卖使其成为一种设计优良的语言——但确实要花许多口舌才能讲清楚这背后发生的所有事情。")]),e._v(" "),t("p",[e._v("最初，Java只是作为一种用于控制硬件的语言而设计，与因特网并没有丝毫联系。象这样一类面向大众的语言一样，其意义在于程序员可以对任意一个对象进行克隆。这样一来，"),t("code",[e._v("clone()")]),e._v("就放置在根类"),t("code",[e._v("Object")]),e._v("里面，但因为它是一种公用方式，因而我们通常能够对任意一个对象进行克隆。看来这是最灵活的方式了，毕竟它不会带来任何害处。")]),e._v(" "),t("p",[e._v("正当Java看起来象一种终级因特网程序设计语言的时候，情况却发生了变化。突然地，人们提出了安全问题，而且理所当然，这些问题与使用对象有关，我们不愿望任何人克隆自己的保密对象。所以我们最后看到的是为原来那个简单、直观的方案添加的大量补丁："),t("code",[e._v("clone()")]),e._v("在"),t("code",[e._v("Object")]),e._v("里被设置成"),t("code",[e._v("protected")]),e._v("。必须将其覆盖，并使用"),t("code",[e._v("implement Cloneable")]),e._v("，同时解决异常的问题。")]),e._v(" "),t("p",[e._v("只有在准备调用"),t("code",[e._v("Object")]),e._v("的"),t("code",[e._v("clone()")]),e._v("方法时，才没有必要使用"),t("code",[e._v("Cloneable")]),e._v("接口，因为那个方法会在运行期间得到检查，以确保我们的类实现了"),t("code",[e._v("Cloneable")]),e._v("。但为了保持连贯性（而且由于"),t("code",[e._v("Cloneable")]),e._v("无论如何都是空的），最好还是由自己实现"),t("code",[e._v("Cloneable")]),e._v("。")])])}),[],!1,null,null,null);n.default=o.exports}}]);