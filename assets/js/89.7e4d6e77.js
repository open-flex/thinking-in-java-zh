(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{487:function(e,n,t){"use strict";t.r(n);var v=t(56),a=Object(v.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_16-1-模式的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-1-模式的概念"}},[e._v("#")]),e._v(" 16.1 模式的概念")]),e._v(" "),t("p",[e._v("在最开始，可将模式想象成一种特别聪明、能够自我适应的手法，它可以解决特定类型的问题。也就是说，它类似一些需要全面认识某个问题的人。在了解了问题的方方面面以后，最后提出一套最通用、最灵活的解决方案。具体问题或许是以前见到并解决过的。然而，从前的方案也许并不是最完善的，大家会看到它如何在一个模式里具体表达出来。")]),e._v(" "),t("p",[e._v("尽管我们称之为“设计模式”，但它们实际上并不局限于设计领域。思考“模式”时，应脱离传统意义上分析、设计以及实现的思考方式。相反，“模式”是在一个程序里具体表达一套完整的思想，所以它有时可能出现在分析阶段或者高级设计阶段。这一点是非常有趣的，因为模式具有以代码形式直接实现的形式，所以可能不希望它在低级设计或者具体实现以前显露出来（而且事实上，除非真正进入那些阶段，否则一般意识不到自己需要一个模式来解决问题）。")]),e._v(" "),t("p",[e._v("模式的基本概念亦可看成是程序设计的基本概念：添加一层新的抽象！只要我们抽象了某些东西，就相当于隔离了特定的细节。而且这后面最引人注目的动机就是“将保持不变的东西身上发生的变化孤立出来”。这样做的另一个原因是一旦发现程序的某部分由于这样或那样的原因可能发生变化，我们一般都想防止那些改变在代码内部繁衍出其他变化。这样做不仅可以降低代码的维护代价，也更便于我们理解（结果同样是降低开销）。")]),e._v(" "),t("p",[e._v("为设计出功能强大且易于维护的应用项目，通常最困难的部分就是找出我称之为“领头变化”的东西。这意味着需要找出造成系统改变的最重要的东西，或者换一个角度，找出付出代价最高、开销最大的那一部分。一旦发现了“领头变化”，就可以为自己定下一个焦点，围绕它展开自己的设计。")]),e._v(" "),t("p",[e._v("所以设计模式的最终目标就是将代码中变化的内容隔离开。如果从这个角度观察，就会发现本书实际已采用了一些设计模式。举个例子来说，继承可以想象成一种设计模式（类似一个由编译器实现的）。在都拥有同样接口（即保持不变的东西）的对象内部，它允许我们表达行为上的差异（即发生变化的东西）。组合亦可想象成一种模式，因为它允许我们修改——动态或静态——用于实现类的对象，所以也能修改类的运作方式。")]),e._v(" "),t("p",[e._v("在《设计模式》一书中，大家还能看到另一种模式：“迭代器”（即"),t("code",[e._v("Iterator")]),e._v("，Java 1.0和1.1不负责任地把它叫作"),t("code",[e._v("Enumeration")]),e._v("，即“枚举”；Java1.2的集合则改回了“迭代器”的称呼）。当我们在集合里遍历，逐个选择不同的元素时，迭代器可将集合的实现细节有效地隐藏起来。利用迭代器，可以编写出通用的代码，以便对一个序列里的所有元素采取某种操作，同时不必关心这个序列是如何构建的。这样一来，我们的通用代码即可伴随任何能产生迭代器的集合使用。")]),e._v(" "),t("h2",{attrs:{id:"_16-1-1-单例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-1-1-单例"}},[e._v("#")]),e._v(" 16.1.1 单例")]),e._v(" "),t("p",[e._v("或许最简单的设计模式就是“单例”（"),t("code",[e._v("Singleton")]),e._v("），它能提供对象的一个（而且只有一个）实例。单例在Java库中得到了应用，但下面这个例子显得更直接一些：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//: SingletonPattern.java\n// The Singleton design pattern: you can\n// never instantiate more than one.\npackage c16;\n\n// Since this isn't inherited from a Cloneable\n// base class and cloneability isn't added,\n// making it final prevents cloneability from\n// being added in any derived classes:\nfinal class Singleton {\n  private static Singleton s = new Singleton(47);\n  private int i;\n  private Singleton(int x) { i = x; }\n  public static Singleton getHandle() {\n    return s;\n  }\n  public int getValue() { return i; }\n  public void setValue(int x) { i = x; }\n}\n\npublic class SingletonPattern {\n  public static void main(String[] args) {\n    Singleton s = Singleton.getHandle();\n    System.out.println(s.getValue());\n    Singleton s2 = Singleton.getHandle();\n    s2.setValue(9);\n    System.out.println(s.getValue());\n    try {\n      // Can't do this: compile-time error.\n      // Singleton s3 = (Singleton)s2.clone();\n    } catch(Exception e) {}\n  }\n} ///:~\n")])])]),t("p",[e._v("创建单例的关键就是防止客户程序员采用除由我们提供的之外的任何一种方式来创建一个对象。必须将所有构造器都设为"),t("code",[e._v("private")]),e._v("（私有），而且至少要创建一个构造器，以防止编译器帮我们自动同步一个默认构造器（它会自做聪明地创建成为“友好的”——"),t("code",[e._v("friendly")]),e._v("，而非"),t("code",[e._v("private")]),e._v("）。")]),e._v(" "),t("p",[e._v("此时应决定如何创建自己的对象。在这儿，我们选择了静态创建的方式。但亦可选择等候客户程序员发出一个创建请求，然后根据他们的要求动态创建。不管在哪种情况下，对象都应该保存为“私有”属性。我们通过公用方法提供访问途径。在这里，"),t("code",[e._v("getHandle()")]),e._v("会产生指向"),t("code",[e._v("Singleton")]),e._v("的一个引用。剩下的接口（"),t("code",[e._v("getValue()")]),e._v("和"),t("code",[e._v("setValue()")]),e._v("）属于普通的类接口。")]),e._v(" "),t("p",[e._v("Java也允许通过克隆（"),t("code",[e._v("Clone")]),e._v("）方式来创建一个对象。在这个例子中，将类设为"),t("code",[e._v("final")]),e._v("可禁止克隆的发生。由于"),t("code",[e._v("Singleton")]),e._v("是从"),t("code",[e._v("Object")]),e._v("直接继承的，所以"),t("code",[e._v("clone()")]),e._v("方法会保持"),t("code",[e._v("protected")]),e._v("（受保护）属性，不能够使用它（强行使用会造成编译期错误）。然而，假如我们是从一个类结构中继承，那个结构已经重载了"),t("code",[e._v("clone()")]),e._v("方法，使其具有"),t("code",[e._v("public")]),e._v("属性，并实现了"),t("code",[e._v("Cloneable")]),e._v("，那么为了禁止克隆，需要重载"),t("code",[e._v("clone()")]),e._v("，并抛出一个"),t("code",[e._v("CloneNotSupportedException")]),e._v("（不支持克隆异常），就象第12章介绍的那样。亦可重载"),t("code",[e._v("clone()")]),e._v("，并简单地返回"),t("code",[e._v("this")]),e._v("。那样做会造成一定的混淆，因为客户程序员可能错误地认为对象尚未克隆，仍然操纵的是原来的那个。")]),e._v(" "),t("p",[e._v("注意我们并不限于只能创建一个对象。亦可利用该技术创建一个有限的对象池。但在那种情况下，可能需要解决池内对象的共享问题。如果不幸真的遇到这个问题，可以自己设计一套方案，实现共享对象的登记与撤消登记。")]),e._v(" "),t("h2",{attrs:{id:"_16-1-2-模式分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-1-2-模式分类"}},[e._v("#")]),e._v(" 16.1.2 模式分类")]),e._v(" "),t("p",[e._v("《设计模式》一书讨论了23种不同的模式，并依据三个标准分类（所有标准都涉及那些可能发生变化的方面）。这三个标准是：")]),e._v(" "),t("p",[e._v("(1) 创建：对象的创建方式。这通常涉及对象创建细节的隔离，这样便不必依赖具体类型的对象，所以在新添一种对象类型时也不必改动代码。")]),e._v(" "),t("p",[e._v("(2) 结构：设计对象，满足特定的项目限制。这涉及对象与其他对象的连接方式，以保证系统内的改变不会影响到这些连接。")]),e._v(" "),t("p",[e._v("(3) 行为：对程序中特定类型的行动进行操纵的对象。这要求我们将希望采取的操作封装起来，比如解释一种语言、实现一个请求、在一个序列中遍历（就象在迭代器中那样）或者实现一种算法。本章提供了“观察器”（"),t("code",[e._v("Observer")]),e._v("）和“访问器”（"),t("code",[e._v("Visitor")]),e._v("）的模式的例子。")]),e._v(" "),t("p",[e._v("《设计模式》为所有这23种模式都分别使用了一节，随附的还有大量示例，但大多是用C++编写的，少数用Smalltalk编写（如看过这本书，就知道这实际并不是个大问题，因为很容易即可将基本概念从两种语言翻译到Java里）。现在这本书并不打算重复《设计模式》介绍的所有模式，因为那是一本独立的书，大家应该单独阅读。相反，本章只准备给出一些例子，让大家先对模式有个大致的印象，并理解它们的重要性到底在哪里。")])])}),[],!1,null,null,null);n.default=a.exports}}]);