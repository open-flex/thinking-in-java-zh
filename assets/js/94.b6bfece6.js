(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{492:function(e,n,t){"use strict";t.r(n);var s=t(56),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_16-5-抽象的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-5-抽象的应用"}},[e._v("#")]),e._v(" 16.5 抽象的应用")]),e._v(" "),t("p",[e._v("走到这一步，接下来该考虑一下设计模式剩下的部分了——在哪里使用类？既然归类到垃圾箱的办法非常不雅且过于暴露，为什么不隔离那个过程，把它隐藏到一个类里呢？这就是著名的“如果必须做不雅的事情，至少应将其本地化到一个类里”规则。看起来就象下面这样：")]),e._v(" "),t("p",[t("img",{attrs:{src:"16-1.gif",alt:""}})]),e._v(" "),t("p",[e._v("现在，只要一种新类型的"),t("code",[e._v("Trash")]),e._v("加入方法，对"),t("code",[e._v("TrashSorter")]),e._v("对象的初始化就必须变动。可以想象，"),t("code",[e._v("TrashSorter")]),e._v("类看起来应该象下面这个样子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class TrashSorter extends Vector {\nvoid sort(Trash t) { /* ... */ }\n}\n")])])]),t("p",[e._v("也就是说，"),t("code",[e._v("TrashSorter")]),e._v("是由一系列引用构成的"),t("code",[e._v("Vector")]),e._v("（系列），而那些引用指向的又是由"),t("code",[e._v("Trash")]),e._v("引用构成的"),t("code",[e._v("Vector")]),e._v("；利用"),t("code",[e._v("addElement()")]),e._v("，可以安装新的"),t("code",[e._v("TrashSorter")]),e._v("，如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("TrashSorter ts = new TrashSorter();\nts.addElement(new Vector());\n")])])]),t("p",[e._v("但是现在，"),t("code",[e._v("sort()")]),e._v("却成为一个问题。用静态方式编码的方法如何应付一种新类型加入的事实呢？为解决这个问题，必须从"),t("code",[e._v("sort()")]),e._v("里将类型信息删除，使其需要做的所有事情就是调用一个通用方法，用它照料涉及类型处理的所有细节。这当然是对一个动态绑定方法进行描述的另一种方式。所以"),t("code",[e._v("sort()")]),e._v("会在序列中简单地遍历，并为每个"),t("code",[e._v("Vector")]),e._v("都调用一个动态绑定方法。由于这个方法的任务是收集它感兴趣的垃圾片，所以称之为"),t("code",[e._v("grab(Trash)")]),e._v("。结构现在变成了下面这样：")]),e._v(" "),t("p",[t("img",{attrs:{src:"16-2.gif",alt:""}})]),e._v(" "),t("p",[e._v("其中，"),t("code",[e._v("TrashSorter")]),e._v("需要调用每个"),t("code",[e._v("grab()")]),e._v("方法；然后根据当前"),t("code",[e._v("Vector")]),e._v("容纳的是什么类型，会获得一个不同的结果。也就是说，"),t("code",[e._v("Vector")]),e._v("必须留意自己容纳的类型。解决这个问题的传统方法是创建一个基础“Trash bin”（垃圾筒）类，并为希望容纳的每个不同的类型都继承一个新的派生类。若Java有一个参数化的类型机制，那就也许是最直接的方法。但对于这种机制应该为我们构建的各个类，我们不应该进行麻烦的手工编码，以后的“观察”方式提供了一种更好的编码方式。")]),e._v(" "),t("p",[e._v("OOP设计一条基本的准则是“为状态的变化使用数据成员，为行为的变化使用多性形”。对于容纳"),t("code",[e._v("Paper")]),e._v("（纸张）的"),t("code",[e._v("Vector")]),e._v("，以及容纳"),t("code",[e._v("Glass")]),e._v("（玻璃）的"),t("code",[e._v("Vector")]),e._v("，大家最开始或许会认为分别用于它们的"),t("code",[e._v("grab()")]),e._v("方法肯定会产生不同的行为。但具体如何却完全取决于类型，而不是其他什么东西。可将其解释成一种不同的状态，而且由于Java有一个类可表示类型（"),t("code",[e._v("Class")]),e._v("），所以可用它判断特定的"),t("code",[e._v("Tbin")]),e._v("要容纳什么类型的"),t("code",[e._v("Trash")]),e._v("。")]),e._v(" "),t("p",[e._v("用于Tbin的构造器要求我们为其传递自己选择的一个"),t("code",[e._v("Class")]),e._v("。这样做可告诉"),t("code",[e._v("Vector")]),e._v("它希望容纳的是什么类型。随后，"),t("code",[e._v("grab()")]),e._v("方法用"),t("code",[e._v("Class BinType")]),e._v("和RTTI来检查我们传递给它的"),t("code",[e._v("Trash")]),e._v("对象是否与它希望收集的类型相符。\n下面列出完整的解决方案。设定为注释的编号（如"),t("em",[e._v("1")]),e._v("）便于大家对照程序后面列出的说明。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: RecycleB.java\n// Adding more objects to the recycling problem\npackage c16.recycleb;\nimport c16.trash.*;\nimport java.util.*;\n\n// A vector that admits only the right type:\nclass Tbin extends Vector {\n  Class binType;\n  Tbin(Class binType) {\n    this.binType = binType;\n  }\n  boolean grab(Trash t) {\n    // Comparing class types:\n    if(t.getClass().equals(binType)) {\n      addElement(t);\n      return true; // Object grabbed\n    }\n    return false; // Object not grabbed\n  }\n}\n\nclass TbinList extends Vector { //(*1*)\n  boolean sort(Trash t) {\n    Enumeration e = elements();\n    while(e.hasMoreElements()) {\n      Tbin bin = (Tbin)e.nextElement();\n      if(bin.grab(t)) return true;\n    }\n    return false; // bin not found for t\n  }\n  void sortBin(Tbin bin) { // (*2*)\n    Enumeration e = bin.elements();\n    while(e.hasMoreElements())\n      if(!sort((Trash)e.nextElement()))\n        System.out.println("Bin not found");\n  }\n}\n\npublic class RecycleB {\n  static Tbin bin = new Tbin(Trash.class);\n  public static void main(String[] args) {\n    // Fill up the Trash bin:\n    ParseTrash.fillBin("Trash.dat", bin);\n\n    TbinList trashBins = new TbinList();\n    trashBins.addElement(\n      new Tbin(Aluminum.class));\n    trashBins.addElement(\n      new Tbin(Paper.class));\n    trashBins.addElement(\n      new Tbin(Glass.class));\n    // add one line here: (*3*)\n    trashBins.addElement(\n      new Tbin(Cardboard.class));\n\n    trashBins.sortBin(bin); // (*4*)\n\n    Enumeration e = trashBins.elements();\n    while(e.hasMoreElements()) {\n      Tbin b = (Tbin)e.nextElement();\n      Trash.sumValue(b);\n    }\n    Trash.sumValue(bin);\n  }\n} ///:~\n')])])]),t("p",[e._v("(1) "),t("code",[e._v("TbinList")]),e._v("容纳一系列"),t("code",[e._v("Tbin")]),e._v("引用，所以在查找与我们传递给它的"),t("code",[e._v("Trash")]),e._v("对象相符的情况时，"),t("code",[e._v("sort()")]),e._v("能通过"),t("code",[e._v("Tbin")]),e._v("继承。")]),e._v(" "),t("p",[e._v("(2) "),t("code",[e._v("sortBin()")]),e._v("允许我们将一个完整的"),t("code",[e._v("Tbin")]),e._v("传递进去，而且它会在"),t("code",[e._v("Tbin")]),e._v("里遍历，挑选出每种"),t("code",[e._v("Trash")]),e._v("，并将其归类到特定的"),t("code",[e._v("Tbin")]),e._v("中。请注意这些代码的通用性：新类型加入时，它本身不需要任何改动。只要新类型加入（或发生其他事件）时大量代码都不需要变化，就表明我们设计的是一个容易扩展的系统。")]),e._v(" "),t("p",[e._v("(3) 现在可以体会添加新类型有多么容易了。为支持添加，只需要改动几行代码。如确实有必要，甚至可以进一步地改进设计，使更多的代码都保持“固定”。")]),e._v(" "),t("p",[e._v("(4) 一个方法调用使"),t("code",[e._v("bin")]),e._v("的内容归类到对应的、特定类型的垃圾筒里。")])])}),[],!1,null,null,null);n.default=a.exports}}]);