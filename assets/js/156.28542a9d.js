(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{552:function(n,e,t){"use strict";t.r(e);var a=t(56),i=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"_7-6-内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-内部类"}},[n._v("#")]),n._v(" 7.6 内部类")]),n._v(" "),t("p",[n._v("在Java 1.1中，可将一个类定义置入另一个类定义中。这就叫作“内部类”。内部类对我们非常有用，因为利用它可对那些逻辑上相互联系的类进行分组，并可控制一个类在另一个类里的“可见性”。然而，我们必须认识到内部类与以前讲述的“组合”方法存在着根本的区别。")]),n._v(" "),t("p",[n._v("通常，对内部类的需要并不是特别明显的，至少不会立即感觉到自己需要使用内部类。在本章的末尾，介绍完内部类的所有语法之后，大家会发现一个特别的例子。通过它应该可以清晰地认识到内部类的好处。")]),n._v(" "),t("p",[n._v("创建内部类的过程是平淡无奇的：将类定义置入一个用于封装它的类内部（若执行这个程序遇到麻烦，请参见第3章的3.1.2小节“赋值”）：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel1.java\n// Creating inner classes\npackage c07.parcel1;\n\npublic class Parcel1 {\n  class Contents {\n    private int i = 11;\n    public int value() { return i; }\n  }\n  class Destination {\n    private String label;\n    Destination(String whereTo) {\n      label = whereTo;\n    }\n    String readLabel() { return label; }\n  }\n  // Using inner classes looks just like\n  // using any other class, within Parcel1:\n  public void ship(String dest) {\n    Contents c = new Contents();\n    Destination d = new Destination(dest);\n  }  \n  public static void main(String[] args) {\n    Parcel1 p = new Parcel1();\n    p.ship("Tanzania");\n  }\n} ///:~\n')])])]),t("p",[n._v("若在"),t("code",[n._v("ship()")]),n._v("内部使用，内部类的使用看起来和其他任何类都没什么分别。在这里，唯一明显的区别就是它的名字嵌套在"),t("code",[n._v("Parcel1")]),n._v("里面。但大家不久就会知道，这其实并非唯一的区别。")]),n._v(" "),t("p",[n._v("更典型的一种情况是，一个外部类拥有一个特殊的方法，它会返回指向一个内部类的引用。就象下面这样：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel2.java\n// Returning a handle to an inner class\npackage c07.parcel2;\n\npublic class Parcel2 {\n  class Contents {\n    private int i = 11;\n    public int value() { return i; }\n  }\n  class Destination {\n    private String label;\n    Destination(String whereTo) {\n      label = whereTo;\n    }\n    String readLabel() { return label; }\n  }\n  public Destination to(String s) {\n    return new Destination(s);\n  }\n  public Contents cont() {\n    return new Contents();\n  }\n  public void ship(String dest) {\n    Contents c = cont();\n    Destination d = to(dest);\n  }  \n  public static void main(String[] args) {\n    Parcel2 p = new Parcel2();\n    p.ship("Tanzania");\n    Parcel2 q = new Parcel2();\n    // Defining handles to inner classes:\n    Parcel2.Contents c = q.cont();\n    Parcel2.Destination d = q.to("Borneo");\n  }\n} ///:~\n')])])]),t("p",[n._v("若想在除外部类非"),t("code",[n._v("static")]),n._v("方法内部之外的任何地方生成内部类的一个对象，必须将那个对象的类型设为"),t("code",[n._v("外部类名.内部类名")]),n._v("，就象"),t("code",[n._v("main()")]),n._v("中展示的那样。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-1-内部类和向上转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-1-内部类和向上转换"}},[n._v("#")]),n._v(" 7.6.1 内部类和向上转换")]),n._v(" "),t("p",[n._v("迄今为止，内部类看起来仍然没什么特别的地方。毕竟，用它实现隐藏显得有些大题小做。Java已经有一个非常优秀的隐藏机制——只允许类成为“友好的”（只在一个包内可见），而不是把它创建成一个内部类。")]),n._v(" "),t("p",[n._v("然而，当我们准备向上转换到一个基类（特别是到一个接口）的时候，内部类就开始发挥其关键作用（从用于实现的对象生成一个接口引用具有与向上转换至一个基类相同的效果）。这是由于内部类随后可完全进入不可见或不可用状态——对任何人都将如此。所以我们可以非常方便地隐藏实现细节。我们得到的全部回报就是一个基类或者接口的引用，而且甚至有可能不知道准确的类型。就象下面这样：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel3.java\n// Returning a handle to an inner class\npackage c07.parcel3;\n\nabstract class Contents {\n  abstract public int value();\n}\n\ninterface Destination {\n  String readLabel();\n}\n\npublic class Parcel3 {\n  private class PContents extends Contents {\n    private int i = 11;\n    public int value() { return i; }\n  }\n  protected class PDestination\n      implements Destination {\n    private String label;\n    private PDestination(String whereTo) {\n      label = whereTo;\n    }\n    public String readLabel() { return label; }\n  }\n  public Destination dest(String s) {\n    return new PDestination(s);\n  }\n  public Contents cont() {\n    return new PContents();\n  }\n}\n\nclass Test {\n  public static void main(String[] args) {\n    Parcel3 p = new Parcel3();\n    Contents c = p.cont();\n    Destination d = p.dest("Tanzania");\n    // Illegal -- can\'t access private class:\n    //! Parcel3.PContents c = p.new PContents();\n  }\n} ///:~\n')])])]),t("p",[n._v("现在，"),t("code",[n._v("Contents")]),n._v("和"),t("code",[n._v("Destination")]),n._v("代表可由客户程序员使用的接口（记住接口会将自己的所有成员都变成"),t("code",[n._v("public")]),n._v("属性）。为方便起见，它们置于单独一个文件里，但原始的"),t("code",[n._v("Contents")]),n._v("和"),t("code",[n._v("Destination")]),n._v("在它们自己的文件中是相互"),t("code",[n._v("public")]),n._v("的。")]),n._v(" "),t("p",[n._v("在"),t("code",[n._v("Parcel3")]),n._v("中，一些新东西已经加入：内部类"),t("code",[n._v("PContents")]),n._v("被设为"),t("code",[n._v("private")]),n._v("，所以除了"),t("code",[n._v("Parcel3")]),n._v("之外，其他任何东西都不能访问它。"),t("code",[n._v("PDestination")]),n._v("被设为"),t("code",[n._v("protected")]),n._v("，所以除了"),t("code",[n._v("Parcel3")]),n._v("，"),t("code",[n._v("Parcel3")]),n._v("包内的类（因为"),t("code",[n._v("protected")]),n._v("也为包赋予了访问权；也就是说，"),t("code",[n._v("protected")]),n._v("也是“友好的”），以及"),t("code",[n._v("Parcel3")]),n._v("的继承者之外，其他任何东西都不能访问"),t("code",[n._v("PDestination")]),n._v("。这意味着客户程序员对这些成员的认识与访问将会受到限制。事实上，我们甚至不能向下转换到一个"),t("code",[n._v("private")]),n._v("内部类（或者一个"),t("code",[n._v("protected")]),n._v("内部类，除非自己本身便是一个继承者），因为我们不能访问名字，就象在"),t("code",[n._v("classTest")]),n._v("里看到的那样。所以，利用"),t("code",[n._v("private")]),n._v("内部类，类设计人员可完全禁止其他人依赖类型编码，并可将具体的实现细节完全隐藏起来。除此以外，从客户程序员的角度来看，一个接口的范围没有意义的，因为他们不能访问不属于公共接口类的任何额外方法。这样一来，Java编译器也有机会生成效率更高的代码。")]),n._v(" "),t("p",[n._v("普通（非内部）类不可设为"),t("code",[n._v("private")]),n._v("或"),t("code",[n._v("protected")]),n._v("——只允许public或者“友好的”。")]),n._v(" "),t("p",[n._v("注意"),t("code",[n._v("Contents")]),n._v("不必成为一个抽象类。在这儿也可以使用一个普通类，但这种设计最典型的起点依然是一个“接口”。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-2-方法和作用域中的内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-2-方法和作用域中的内部类"}},[n._v("#")]),n._v(" 7.6.2 方法和作用域中的内部类")]),n._v(" "),t("p",[n._v("至此，我们已基本理解了内部类的典型用途。对那些涉及内部类的代码，通常表达的都是“单纯”的内部类，非常简单，且极易理解。然而，内部类的设计非常全面，不可避免地会遇到它们的其他大量用法——假若我们在一个方法甚至一个任意的作用域内创建内部类。有两方面的原因促使我们这样做：")]),n._v(" "),t("p",[n._v("(1) 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个引用。")]),n._v(" "),t("p",[n._v("(2) 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。")]),n._v(" "),t("p",[n._v("在下面这个例子里，将修改前面的代码，以便使用：")]),n._v(" "),t("p",[n._v("(1) 在一个方法内定义的类")]),n._v(" "),t("p",[n._v("(2) 在方法的一个作用域内定义的类")]),n._v(" "),t("p",[n._v("(3) 一个匿名类，用于实现一个接口")]),n._v(" "),t("p",[n._v("(4) 一个匿名类，用于扩展拥有非默认构造器的一个类")]),n._v(" "),t("p",[n._v("(5) 一个匿名类，用于执行字段初始化")]),n._v(" "),t("p",[n._v("(6) 一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构造器）")]),n._v(" "),t("p",[n._v("所有这些都在"),t("code",[n._v("innerscopes")]),n._v("包内发生。首先，来自前述代码的通用接口会在它们自己的文件里获得定义，使它们能在所有的例子里使用：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Destination.java\npackage c07.innerscopes;\n\ninterface Destination {\n  String readLabel();\n} ///:~\n")])])]),t("p",[n._v("由于我们已认为"),t("code",[n._v("Contents")]),n._v("可能是一个抽象类，所以可采取下面这种更自然的形式，就象一个接口那样：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Contents.java\npackage c07.innerscopes;\n\ninterface Contents {\n  int value();\n} ///:~\n")])])]),t("p",[n._v("尽管是含有具体实现细节的一个普通类，但"),t("code",[n._v("Wrapping")]),n._v("也作为它所有派生类的一个通用“接口”使用：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Wrapping.java\npackage c07.innerscopes;\n\npublic class Wrapping {\n  private int i;\n  public Wrapping(int x) { i = x; }\n  public int value() { return i; }\n} ///:~\n")])])]),t("p",[n._v("在上面的代码中，我们注意到"),t("code",[n._v("Wrapping")]),n._v("有一个要求使用参数的构造器，这就使情况变得更加有趣了。")]),n._v(" "),t("p",[n._v("第一个例子展示了如何在一个方法的作用域（而不是另一个类的作用域）中创建一个完整的类：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel4.java\n// Nesting a class within a method\npackage c07.innerscopes;\n\npublic class Parcel4 {\n  public Destination dest(String s) {\n    class PDestination\n        implements Destination {\n      private String label;\n      private PDestination(String whereTo) {\n        label = whereTo;\n      }\n      public String readLabel() { return label; }\n    }\n    return new PDestination(s);\n  }\n  public static void main(String[] args) {\n    Parcel4 p = new Parcel4();\n    Destination d = p.dest("Tanzania");\n  }\n} ///:~\n')])])]),t("p",[t("code",[n._v("PDestination")]),n._v("类属于"),t("code",[n._v("dest()")]),n._v("的一部分，而不是"),t("code",[n._v("Parcel4")]),n._v("的一部分（同时注意可为相同目录内每个类内部的一个内部类使用类标识符"),t("code",[n._v("PDestination")]),n._v("，这样做不会发生命名的冲突）。因此，"),t("code",[n._v("PDestination")]),n._v("不可从"),t("code",[n._v("dest()")]),n._v("的外部访问。请注意在返回语句中发生的向上转换——除了指向基类"),t("code",[n._v("Destination")]),n._v("的一个引用之外，没有任何东西超出"),t("code",[n._v("dest()")]),n._v("的边界之外。当然，不能由于类"),t("code",[n._v("PDestination")]),n._v("的名字置于"),t("code",[n._v("dest()")]),n._v("内部，就认为在"),t("code",[n._v("dest()")]),n._v("返回之后"),t("code",[n._v("PDestination")]),n._v("不是一个有效的对象。")]),n._v(" "),t("p",[n._v("下面这个例子展示了如何在任意作用域内嵌套一个内部类：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel5.java\n// Nesting a class within a scope\npackage c07.innerscopes;\n\npublic class Parcel5 {\n  private void internalTracking(boolean b) {\n    if(b) {\n      class TrackingSlip {\n        private String id;\n        TrackingSlip(String s) {\n          id = s;\n        }\n        String getSlip() { return id; }\n      }\n      TrackingSlip ts = new TrackingSlip("slip");\n      String s = ts.getSlip();\n    }\n    // Can\'t use it here! Out of scope:\n    //! TrackingSlip ts = new TrackingSlip("x");\n  }\n  public void track() { internalTracking(true); }\n  public static void main(String[] args) {\n    Parcel5 p = new Parcel5();\n    p.track();\n  }\n} ///:~\n')])])]),t("p",[t("code",[n._v("TrackingSlip")]),n._v("类嵌套于一个"),t("code",[n._v("if")]),n._v("语句的作用域内。这并不意味着类是有条件创建的——它会随同其他所有东西得到编译。然而，在定义它的那个作用域之外，它是不可使用的。除这些以外，它看起来和一个普通类并没有什么区别。")]),n._v(" "),t("p",[n._v("下面这个例子看起来有些奇怪：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Parcel6.java\n// A method that returns an anonymous inner class\npackage c07.innerscopes;\n\npublic class Parcel6 {\n  public Contents cont() {\n    return new Contents() {\n      private int i = 11;\n      public int value() { return i; }\n    }; // Semicolon required in this case\n  }\n  public static void main(String[] args) {\n    Parcel6 p = new Parcel6();\n    Contents c = p.cont();\n  }\n} ///:~\n")])])]),t("p",[t("code",[n._v("cont()")]),n._v("方法同时合并了返回值的创建代码，以及用于表示那个返回值的类。除此以外，这个类是匿名的——它没有名字。而且看起来似乎更让人摸不着头脑的是，我们准备创建一个"),t("code",[n._v("Contents")]),n._v("对象：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("return new Contents()\n")])])]),t("p",[n._v("但在这之后，在遇到分号之前，我们又说：“等一等，让我先在一个类定义里再耍一下花招”：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("return new Contents() {\nprivate int i = 11;\npublic int value() { return i; }\n};\n")])])]),t("p",[n._v("这种奇怪的语法要表达的意思是：“创建从"),t("code",[n._v("Contents")]),n._v("派生出来的匿名类的一个对象”。由"),t("code",[n._v("new")]),n._v("表达式返回的引用会自动向上转换成一个"),t("code",[n._v("Contents")]),n._v("引用。匿名内部类的语法其实要表达的是：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class MyContents extends Contents {\nprivate int i = 11;\npublic int value() { return i; }\n}\nreturn new MyContents();\n")])])]),t("p",[n._v("在匿名内部类中，"),t("code",[n._v("Contents")]),n._v("是用一个默认构造器创建的。下面这段代码展示了基类需要含有参数的一个构造器时做的事情：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Parcel7.java\n// An anonymous inner class that calls the\n// base-class constructor\npackage c07.innerscopes;\n\npublic class Parcel7 {\n  public Wrapping wrap(int x) {\n    // Base constructor call:\n    return new Wrapping(x) {\n      public int value() {\n        return super.value() * 47;\n      }\n    }; // Semicolon required\n  }\n  public static void main(String[] args) {\n    Parcel7 p = new Parcel7();\n    Wrapping w = p.wrap(10);\n  }\n} ///:~\n")])])]),t("p",[n._v("也就是说，我们将适当的参数简单地传递给基类构造器，在这儿表现为在"),t("code",[n._v("new Wrapping(x)")]),n._v("中传递"),t("code",[n._v("x")]),n._v("。匿名类不能拥有一个构造器，这和在调用"),t("code",[n._v("super()")]),n._v("时的常规做法不同。")]),n._v(" "),t("p",[n._v("在前述的两个例子中，分号并不标志着类主体的结束（和C++不同）。相反，它标志着用于包含匿名类的那个表达式的结束。因此，它完全等价于在其他任何地方使用分号。")]),n._v(" "),t("p",[n._v("若想对匿名内部类的一个对象进行某种形式的初始化，此时会出现什么情况呢？由于它是匿名的，没有名字赋给构造器，所以我们不能拥有一个构造器。然而，我们可在定义自己的字段时进行初始化：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel8.java\n// An anonymous inner class that performs\n// initialization. A briefer version\n// of Parcel5.java.\npackage c07.innerscopes;\n\npublic class Parcel8 {\n  // Argument must be final to use inside\n  // anonymous inner class:\n  public Destination dest(final String dest) {\n    return new Destination() {\n      private String label = dest;\n      public String readLabel() { return label; }\n    };\n  }\n  public static void main(String[] args) {\n    Parcel8 p = new Parcel8();\n    Destination d = p.dest("Tanzania");\n  }\n} ///:~\n')])])]),t("p",[n._v("若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为"),t("code",[n._v("final")]),n._v("属性。这正是我们将"),t("code",[n._v("dest()")]),n._v("的参数设为"),t("code",[n._v("final")]),n._v("的原因。如果忘记这样做，就会得到一条编译期出错提示。")]),n._v(" "),t("p",[n._v("只要自己只是想分配一个字段，上述方法就肯定可行。但假如需要采取一些类似于构造器的行动，又应怎样操作呢？通过Java 1.1的实例初始化，我们可以有效地为一个匿名内部类创建一个构造器：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel9.java\n// Using "instance initialization" to perform\n// construction on an anonymous inner class\npackage c07.innerscopes;\n\npublic class Parcel9 {\n  public Destination\n  dest(final String dest, final float price) {\n    return new Destination() {\n      private int cost;\n      // Instance initialization for each object:\n      {\n        cost = Math.round(price);\n        if(cost > 100)\n          System.out.println("Over budget!");\n      }\n      private String label = dest;\n      public String readLabel() { return label; }\n    };\n  }\n  public static void main(String[] args) {\n    Parcel9 p = new Parcel9();\n    Destination d = p.dest("Tanzania", 101.395F);\n  }\n} ///:~\n')])])]),t("p",[n._v("在实例初始化模块中，我们可看到代码不能作为类初始化模块（即"),t("code",[n._v("if")]),n._v("语句）的一部分执行。所以实际上，一个实例初始化模块就是一个匿名内部类的构造器。当然，它的功能是有限的；我们不能对实例初始化模块进行重载处理，所以只能拥有这些构造器的其中一个。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-3-链接到外部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-3-链接到外部类"}},[n._v("#")]),n._v(" 7.6.3 链接到外部类")]),n._v(" "),t("p",[n._v("迄今为止，我们见到的内部类好象仅仅是一种名字隐藏以及代码组织方案。尽管这些功能非常有用，但似乎并不特别引人注目。然而，我们还忽略了另一个重要的事实。创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。下面这个例子阐示了这个问题：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Sequence.java\n// Holds a sequence of Objects\n\ninterface Selector {\n  boolean end();\n  Object current();\n  void next();\n}\n\npublic class Sequence {\n  private Object[] o;\n  private int next = 0;\n  public Sequence(int size) {\n    o = new Object[size];\n  }\n  public void add(Object x) {\n    if(next < o.length) {\n      o[next] = x;\n      next++;\n    }\n  }\n  private class SSelector implements Selector {\n    int i = 0;\n    public boolean end() {\n      return i == o.length;\n    }\n    public Object current() {\n      return o[i];\n    }\n    public void next() {\n      if(i < o.length) i++;\n    }\n  }\n  public Selector getSelector() {\n    return new SSelector();\n  }\n  public static void main(String[] args) {\n    Sequence s = new Sequence(10);\n    for(int i = 0; i < 10; i++)\n      s.add(Integer.toString(i));\n    Selector sl = s.getSelector();    \n    while(!sl.end()) {\n      System.out.println((String)sl.current());\n      sl.next();\n    }\n  }\n} ///:~\n")])])]),t("p",[n._v("②：这与C++“嵌套类”的设计颇有不同，后者只是一种单纯的名字隐藏机制。在C++中，没有指向一个封装对象的链接，也不存在默认的访问权限。")]),n._v(" "),t("p",[n._v("其中，"),t("code",[n._v("Sequence")]),n._v("只是一个大小固定的对象数组，有一个类将其封装在内部。我们调用"),t("code",[n._v("add()")]),n._v("，以便将一个新对象添加到"),t("code",[n._v("Sequence")]),n._v("末尾（如果还有地方的话）。为了取得"),t("code",[n._v("Sequence")]),n._v("中的每一个对象，要使用一个名为"),t("code",[n._v("Selector")]),n._v("的接口，它使我们能够知道自己是否位于最末尾（"),t("code",[n._v("end()")]),n._v("），能观看当前对象（"),t("code",[n._v("current() Object")]),n._v("），以及能够移至"),t("code",[n._v("Sequence")]),n._v("内的下一个对象（"),t("code",[n._v("next() Object")]),n._v("）。由于"),t("code",[n._v("Selector")]),n._v("是一个接口，所以其他许多类都能用它们自己的方式实现接口，而且许多方法都能将接口作为一个参数使用，从而创建一般的代码。")]),n._v(" "),t("p",[n._v("在这里，"),t("code",[n._v("SSelector")]),n._v("是一个私有类，它提供了"),t("code",[n._v("Selector")]),n._v("功能。在"),t("code",[n._v("main()")]),n._v("中，大家可看到"),t("code",[n._v("Sequence")]),n._v("的创建过程，在它后面是一系列字符串对象的添加。随后，通过对"),t("code",[n._v("getSelector()")]),n._v("的一个调用生成一个"),t("code",[n._v("Selector")]),n._v("。并用它在"),t("code",[n._v("Sequence")]),n._v("中移动，同时选择每一个项目。")]),n._v(" "),t("p",[n._v("从表面看，"),t("code",[n._v("SSelector")]),n._v("似乎只是另一个内部类。但不要被表面现象迷惑。请注意观察"),t("code",[n._v("end()")]),n._v("，"),t("code",[n._v("current()")]),n._v("以及"),t("code",[n._v("next()")]),n._v("，它们每个方法都引用了"),t("code",[n._v("o")]),n._v("。"),t("code",[n._v("o")]),n._v("是个不属于"),t("code",[n._v("SSelector")]),n._v("一部分的引用，而是位于封装类里的一个"),t("code",[n._v("private")]),n._v("字段。然而，内部类可以从封装类访问方法与字段，就象已经拥有了它们一样。这一特征对我们来说是非常方便的，就象在上面的例子中看到的那样。")]),n._v(" "),t("p",[n._v("因此，我们现在知道一个内部类可以访问封装类的成员。这是如何实现的呢？内部类必须拥有对封装类的特定对象的一个引用，而封装类的作用就是创建这个内部类。随后，当我们引用封装类的一个成员时，就利用那个（隐藏）的引用来选择那个成员。幸运的是，编译器会帮助我们照管所有这些细节。但我们现在也可以理解内部类的一个对象只能与封装类的一个对象联合创建。在这个创建过程中，要求对封装类对象的引用进行初始化。若不能访问那个引用，编译器就会报错。进行所有这些操作的时候，大多数时候都不要求程序员的任何介入。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-4-static内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-4-static内部类"}},[n._v("#")]),n._v(" 7.6.4 "),t("code",[n._v("static")]),n._v("内部类")]),n._v(" "),t("p",[n._v("为正确理解"),t("code",[n._v("static")]),n._v("在应用于内部类时的含义，必须记住内部类的对象默认持有创建它的那个封装类的一个对象的引用。然而，假如我们说一个内部类是"),t("code",[n._v("static")]),n._v("的，这种说法却是不成立的。"),t("code",[n._v("static")]),n._v("内部类意味着：")]),n._v(" "),t("p",[n._v("(1) 为创建一个"),t("code",[n._v("static")]),n._v("内部类的对象，我们不需要一个外部类对象。")]),n._v(" "),t("p",[n._v("(2) 不能从"),t("code",[n._v("static")]),n._v("内部类的一个对象中访问一个外部类对象。")]),n._v(" "),t("p",[n._v("但在存在一些限制：由于"),t("code",[n._v("static")]),n._v("成员只能位于一个类的外部级别，所以内部类不可拥有"),t("code",[n._v("static")]),n._v("数据或"),t("code",[n._v("static")]),n._v("内部类。")]),n._v(" "),t("p",[n._v("倘若为了创建内部类的对象而不需要创建外部类的一个对象，那么可将所有东西都设为"),t("code",[n._v("static")]),n._v("。为了能正常工作，同时也必须将内部类设为"),t("code",[n._v("static")]),n._v("。如下所示：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel10.java\n// Static inner classes\npackage c07.parcel10;\n\nabstract class Contents {\n  abstract public int value();\n}\n\ninterface Destination {\n  String readLabel();\n}\n\npublic class Parcel10 {\n  private static class PContents\n  extends Contents {\n    private int i = 11;\n    public int value() { return i; }\n  }\n  protected static class PDestination\n      implements Destination {\n    private String label;\n    private PDestination(String whereTo) {\n      label = whereTo;\n    }\n    public String readLabel() { return label; }\n  }\n  public static Destination dest(String s) {\n    return new PDestination(s);\n  }\n  public static Contents cont() {\n    return new PContents();\n  }\n  public static void main(String[] args) {\n    Contents c = cont();\n    Destination d = dest("Tanzania");\n  }\n} ///:~\n')])])]),t("p",[n._v("在"),t("code",[n._v("main()")]),n._v("中，我们不需要"),t("code",[n._v("Parcel10")]),n._v("的对象；相反，我们用常规的语法来选择一个"),t("code",[n._v("static")]),n._v("成员，以便调用将引用返回"),t("code",[n._v("Contents")]),n._v("和"),t("code",[n._v("Destination")]),n._v("的方法。")]),n._v(" "),t("p",[n._v("通常，我们不在一个接口里设置任何代码，但"),t("code",[n._v("static")]),n._v("内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——"),t("code",[n._v("static")]),n._v("内部类只位于接口的命名空间内部：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: IInterface.java\n// Static inner classes inside interfaces\n\ninterface IInterface {\n  static class Inner {\n    int i, j, k;\n    public Inner() {}\n    void f() {}\n  }\n} ///:~\n")])])]),t("p",[n._v("在本书早些时候，我建议大家在每个类里都设置一个"),t("code",[n._v("main()")]),n._v("，将其作为那个类的测试床使用。这样做的一个缺点就是额外代码的数量太多。若不愿如此，可考虑用一个"),t("code",[n._v("static")]),n._v("内部类容纳自己的测试代码。如下所示：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: TestBed.java\n// Putting test code in a static inner class\n\nclass TestBed {\n  TestBed() {}\n  void f() { System.out.println("f()"); }\n  public static class Tester {\n    public static void main(String[] args) {\n      TestBed t = new TestBed();\n      t.f();\n    }\n  }\n} ///:~\n')])])]),t("p",[n._v("这样便生成一个独立的、名为"),t("code",[n._v("TestBed$Tester")]),n._v("的类（为运行程序，请使用"),t("code",[n._v("java TestBed$Tester")]),n._v("命令）。可将这个类用于测试，但不需在自己的最终发行版本中包含它。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-5-引用外部类对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-5-引用外部类对象"}},[n._v("#")]),n._v(" 7.6.5 引用外部类对象")]),n._v(" "),t("p",[n._v("若想生成外部类对象的引用，就要用一个点号以及一个"),t("code",[n._v("this")]),n._v("来命名外部类。举个例子来说，在"),t("code",[n._v("Sequence.SSelector")]),n._v("类中，它的所有方法都能产生外部类"),t("code",[n._v("Sequence")]),n._v("的存储引用，方法是采用"),t("code",[n._v("Sequence.this")]),n._v("的形式。结果获得的引用会自动具备正确的类型（这会在编译期间检查并核实，所以不会出现运行期的开销）。")]),n._v(" "),t("p",[n._v("有些时候，我们想告诉其他某些对象创建它某个内部类的一个对象。为达到这个目的，必须在"),t("code",[n._v("new")]),n._v("表达式中提供指向其他外部类对象的一个引用，就象下面这样：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: Parcel11.java\n// Creating inner classes\npackage c07.parcel11;\n\npublic class Parcel11 {\n  class Contents {\n    private int i = 11;\n    public int value() { return i; }\n  }\n  class Destination {\n    private String label;\n    Destination(String whereTo) {\n      label = whereTo;\n    }\n    String readLabel() { return label; }\n  }\n  public static void main(String[] args) {\n    Parcel11 p = new Parcel11();\n    // Must use instance of outer class\n    // to create an instances of the inner class:\n    Parcel11.Contents c = p.new Contents();\n    Parcel11.Destination d =\n      p.new Destination("Tanzania");\n  }\n} ///:~\n')])])]),t("p",[n._v("为直接创建内部类的一个对象，不能象大家或许猜想的那样——采用相同的形式，并引用外部类名"),t("code",[n._v("Parcel11")]),n._v("。此时，必须利用外部类的一个对象生成内部类的一个对象：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Parcel11.Contents c = p.new Contents();\n")])])]),t("p",[n._v("因此，除非已拥有外部类的一个对象，否则不可能创建内部类的一个对象。这是由于内部类的对象已同创建它的外部类的对象“默默”地连接到一起。然而，如果生成一个"),t("code",[n._v("static")]),n._v("内部类，就不需要指向外部类对象的一个引用。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-6-从内部类继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-6-从内部类继承"}},[n._v("#")]),n._v(" 7.6.6 从内部类继承")]),n._v(" "),t("p",[n._v("由于内部类构造器必须同封装类对象的一个引用联系到一起，所以从一个内部类继承的时候，情况会稍微变得有些复杂。这儿的问题是封装类的“秘密”引用必须获得初始化，而且在派生类中不再有一个默认的对象可以连接。解决这个问题的办法是采用一种特殊的语法，明确建立这种关联：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: InheritInner.java\n// Inheriting an inner class\n\nclass WithInner {\n  class Inner {}\n}\n\npublic class InheritInner\n    extends WithInner.Inner {\n  //! InheritInner() {} // Won't compile\n  InheritInner(WithInner wi) {\n    wi.super();\n  }\n  public static void main(String[] args) {\n    WithInner wi = new WithInner();\n    InheritInner ii = new InheritInner(wi);\n  }\n} ///:~\n")])])]),t("p",[n._v("从中可以看到，"),t("code",[n._v("InheritInner")]),n._v("只对内部类进行了扩展，没有扩展外部类。但在需要创建一个构造器的时候，默认对象已经没有意义，我们不能只是传递封装对象的一个引用。此外，必须在构造器中采用下述语法：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("enclosingClassHandle.super();\n")])])]),t("p",[n._v("它提供了必要的引用，以便程序正确编译。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-7-内部类可以覆盖吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-7-内部类可以覆盖吗"}},[n._v("#")]),n._v(" 7.6.7 内部类可以覆盖吗？")]),n._v(" "),t("p",[n._v("若创建一个内部类，然后从封装类继承，并重新定义内部类，那么会出现什么情况呢？也就是说，我们有可能覆盖一个内部类吗？这看起来似乎是一个非常有用的概念，但“覆盖”一个内部类——好象它是外部类的另一个方法——这一概念实际不能做任何事情：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: BigEgg.java\n// An inner class cannot be overriden\n// like a method\n\nclass Egg {\n  protected class Yolk {\n    public Yolk() {\n      System.out.println("Egg.Yolk()");\n    }\n  }\n  private Yolk y;\n  public Egg() {\n    System.out.println("New Egg()");\n    y = new Yolk();\n  }\n}\n\npublic class BigEgg extends Egg {\n  public class Yolk {\n    public Yolk() {\n      System.out.println("BigEgg.Yolk()");\n    }\n  }\n  public static void main(String[] args) {\n    new BigEgg();\n  }\n} ///:~\n')])])]),t("p",[n._v("默认构造器是由编译器自动组合的，而且会调用基类的默认构造器。大家或许会认为由于准备创建一个"),t("code",[n._v("BigEgg")]),n._v("，所以会使用"),t("code",[n._v("Yolk")]),n._v("的“被覆盖”版本。但实际情况并非如此。输出如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("New Egg()\nEgg.Yolk()\n")])])]),t("p",[n._v("这个例子简单地揭示出当我们从外部类继承的时候，没有任何额外的内部类继续下去。然而，仍然有可能“明确”地从内部类继承：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: BigEgg2.java\n// Proper inheritance of an inner class\n\nclass Egg2 {\n  protected class Yolk {\n    public Yolk() {\n      System.out.println("Egg2.Yolk()");\n    }\n    public void f() {\n      System.out.println("Egg2.Yolk.f()");\n    }\n  }\n  private Yolk y = new Yolk();\n  public Egg2() {\n    System.out.println("New Egg2()");\n  }\n  public void insertYolk(Yolk yy) { y = yy; }\n  public void g() { y.f(); }\n}\n\npublic class BigEgg2 extends Egg2 {\n  public class Yolk extends Egg2.Yolk {\n    public Yolk() {\n      System.out.println("BigEgg2.Yolk()");\n    }\n    public void f() {\n      System.out.println("BigEgg2.Yolk.f()");\n    }\n  }\n  public BigEgg2() { insertYolk(new Yolk()); }\n  public static void main(String[] args) {\n    Egg2 e2 = new BigEgg2();\n    e2.g();\n  }\n} ///:~\n')])])]),t("p",[n._v("现在，"),t("code",[n._v("BigEgg2.Yolk")]),n._v("明确地扩展了"),t("code",[n._v("Egg2.Yolk")]),n._v("，而且覆盖了它的方法。方法"),t("code",[n._v("insertYolk()")]),n._v("允许"),t("code",[n._v("BigEgg2")]),n._v("将它自己的某个"),t("code",[n._v("Yolk")]),n._v("对象向上转换至"),t("code",[n._v("Egg2")]),n._v("的"),t("code",[n._v("y")]),n._v("引用。所以当"),t("code",[n._v("g()")]),n._v("调用"),t("code",[n._v("y.f()")]),n._v("的时候，就会使用"),t("code",[n._v("f()")]),n._v("被覆盖版本。输出结果如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Egg2.Yolk()\nNew Egg2()\nEgg2.Yolk()\nBigEgg2.Yolk()\nBigEgg2.Yolk.f()\n")])])]),t("p",[n._v("对"),t("code",[n._v("Egg2.Yolk()")]),n._v("的第二个调用是"),t("code",[n._v("BigEgg2.Yolk")]),n._v("构造器的基类构造器调用。调用\n"),t("code",[n._v("g()")]),n._v("的时候，可发现使用的是"),t("code",[n._v("f()")]),n._v("的被覆盖版本。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-8-内部类标识符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-8-内部类标识符"}},[n._v("#")]),n._v(" 7.6.8 内部类标识符")]),n._v(" "),t("p",[n._v("由于每个类都会生成一个"),t("code",[n._v(".class")]),n._v("文件，用于容纳与如何创建这个类型的对象有关的所有信息（这种信息产生了一个名为"),t("code",[n._v("Class")]),n._v("对象的元类），所以大家或许会猜到内部类也必须生成相应的"),t("code",[n._v(".class")]),n._v("文件，用来容纳与它们的"),t("code",[n._v("Class")]),n._v("对象有关的信息。这些文件或类的名字遵守一种严格的形式：先是封装类的名字，再跟随一个"),t("code",[n._v("$")]),n._v("，再跟随内部类的名字。例如，由"),t("code",[n._v("InheritInner.java")]),n._v("创建的"),t("code",[n._v(".class")]),n._v("文件包括：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("InheritInner.class\nWithInner$Inner.class\nWithInner.class\n")])])]),t("p",[n._v("如果内部类是匿名的，那么编译器会简单地生成数字，把它们作为内部类标识符使用。若内部类嵌套于其他内部类中，则它们的名字简单地追加在一个"),t("code",[n._v("$")]),n._v("以及外部类标识符的后面。")]),n._v(" "),t("p",[n._v("这种生成内部名称的方法除了非常简单和直观以外，也非常“健壮”，可适应大多数场合的要求（注释③）。由于它是Java的标准命名机制，所以产生的文件会自动具备“与平台无关”的能力（注意Java编译器会根据情况改变内部类，使其在不同的平台中能正常工作）。")]),n._v(" "),t("p",[n._v("③：但在另一方面，由于"),t("code",[n._v("$")]),n._v("也是Unix外壳的一个元字符，所以有时会在列出"),t("code",[n._v(".class")]),n._v("文件时遇到麻烦。对一家以Unix为基础的公司——Sun——来说，采取这种方案显得有些奇怪。我的猜测是他们根本没有仔细考虑这方面的问题，而是认为我们会将全部注意力自然地放在源码文件上。")]),n._v(" "),t("h2",{attrs:{id:"_7-6-9-为什么要用内部类-控制框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-9-为什么要用内部类-控制框架"}},[n._v("#")]),n._v(" 7.6.9 为什么要用内部类：控制框架")]),n._v(" "),t("p",[n._v("到目前为止，大家已接触了对内部类的运作进行描述的大量语法与概念。但这些并不能真正说明内部类存在的原因。为什么Sun要如此麻烦地在Java 1.1里添加这样的一种基本语言特性呢？答案就在于我们在这里要学习的“控制框架”。")]),n._v(" "),t("p",[n._v("一个“应用程序框架”是指一个或一系列类，它们专门设计用来解决特定类型的问题。为应用应用程序框架，我们可从一个或多个类继承，并覆盖其中的部分方法。我们在覆盖方法中编写的代码用于定制由那些应用程序框架提供的常规方案，以便解决自己的实际问题。“控制框架”属于应用程序框架的一种特殊类型，受到对事件响应的需要的支配；主要用来响应事件的一个系统叫作“由事件驱动的系统”。在应用程序设计语言中，最重要的问题之一便是“图形用户界面”（GUI），它几乎完全是由事件驱动的。正如大家会在第13章学习的那样，Java 1.1 AWT属于一种控制框架，它通过内部类完美地解决了GUI的问题。")]),n._v(" "),t("p",[n._v("为理解内部类如何简化控制框架的创建与使用，可认为一个控制框架的工作就是在事件“就绪”以后执行它们。尽管“就绪”的意思很多，但在目前这种情况下，我们却是以计算机时钟为基础。随后，请认识到针对控制框架需要控制的东西，框架内并未包含任何特定的信息。首先，它是一个特殊的接口，描述了所有控制事件。它可以是一个抽象类，而非一个实际的接口。由于默认行为是根据时间控制的，所以部分实现细节可能包括：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Event.java\n// The common methods for any control event\npackage c07.controller;\n\nabstract public class Event {\n  private long evtTime;\n  public Event(long eventTime) {\n    evtTime = eventTime;\n  }\n  public boolean ready() {\n    return System.currentTimeMillis() >= evtTime;\n  }\n  abstract public void action();\n  abstract public String description();\n} ///:~\n")])])]),t("p",[n._v("希望"),t("code",[n._v("Event")]),n._v("（事件）运行的时候，构造器即简单地捕获时间。同时"),t("code",[n._v("ready()")]),n._v("告诉我们何时该运行它。当然，"),t("code",[n._v("ready()")]),n._v("也可以在一个派生类中被覆盖，将事件建立在除时间以外的其他东西上。")]),n._v(" "),t("p",[t("code",[n._v("action()")]),n._v("是事件就绪后需要调用的方法，而"),t("code",[n._v("description()")]),n._v("提供了与事件有关的文字信息。")]),n._v(" "),t("p",[n._v("下面这个文件包含了实际的控制框架，用于管理和触发事件。第一个类实际只是一个“助手”类，它的职责是容纳"),t("code",[n._v("Event")]),n._v("对象。可用任何适当的集合替换它。而且通过第8章的学习，大家会知道另一些集合可简化我们的工作，不需要我们编写这些额外的代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//: Controller.java\n// Along with Event, the generic\n// framework for all control systems:\npackage c07.controller;\n\n// This is just a way to hold Event objects.\nclass EventSet {\n  private Event[] events = new Event[100];\n  private int index = 0;\n  private int next = 0;\n  public void add(Event e) {\n    if(index >= events.length)\n      return; // (In real life, throw exception)\n    events[index++] = e;\n  }\n  public Event getNext() {\n    boolean looped = false;\n    int start = next;\n    do {\n      next = (next + 1) % events.length;\n      // See if it has looped to the beginning:\n      if(start == next) looped = true;\n      // If it loops past start, the list\n      // is empty:\n      if((next == (start + 1) % events.length)\n         && looped)\n        return null;\n    } while(events[next] == null);\n    return events[next];\n  }\n  public void removeCurrent() {\n    events[next] = null;\n  }\n}\n\npublic class Controller {\n  private EventSet es = new EventSet();\n  public void addEvent(Event c) { es.add(c); }\n  public void run() {\n    Event e;\n    while((e = es.getNext()) != null) {\n      if(e.ready()) {\n        e.action();\n        System.out.println(e.description());\n        es.removeCurrent();\n      }\n    }\n  }\n} ///:~\n")])])]),t("p",[t("code",[n._v("EventSet")]),n._v("可容纳100个事件（若在这里使用来自第8章的一个“真实”集合，就不必担心它的最大尺寸，因为它会根据情况自动改变大小）。"),t("code",[n._v("index")]),n._v("（索引）在这里用于跟踪下一个可用的空间，而"),t("code",[n._v("next")]),n._v("（下一个）帮助我们寻找列表中的下一个事件，了解自己是否已经循环到头。在对"),t("code",[n._v("getNext()")]),n._v("的调用中，这一点是至关重要的，因为一旦运行，"),t("code",[n._v("Event")]),n._v("对象就会从列表中删去（使用"),t("code",[n._v("removeCurrent()")]),n._v("）。所以"),t("code",[n._v("getNext()")]),n._v("会在列表中向前移动时遇到“空洞”。")]),n._v(" "),t("p",[n._v("注意"),t("code",[n._v("removeCurrent()")]),n._v("并不只是指示一些标志，指出对象不再使用。相反，它将引用设为"),t("code",[n._v("null")]),n._v("。这一点是非常重要的，因为假如垃圾收集器发现一个引用仍在使用，就不会清除对象。若认为自己的引用可能象现在这样被挂起，那么最好将其设为"),t("code",[n._v("null")]),n._v("，使垃圾收集器能够正常地清除它们。")]),n._v(" "),t("p",[t("code",[n._v("Controller")]),n._v("是进行实际工作的地方。它用一个"),t("code",[n._v("EventSet")]),n._v("容纳自己的"),t("code",[n._v("Event")]),n._v("对象，而且"),t("code",[n._v("addEvent()")]),n._v("允许我们向这个列表加入新事件。但最重要的方法是"),t("code",[n._v("run()")]),n._v("。该方法会在"),t("code",[n._v("EventSet")]),n._v("中遍历，搜索一个准备运行的"),t("code",[n._v("Event")]),n._v("对象——"),t("code",[n._v("ready()")]),n._v("。对于它发现"),t("code",[n._v("ready()")]),n._v("的每一个对象，都会调用"),t("code",[n._v("action()")]),n._v("方法，打印出"),t("code",[n._v("description()")]),n._v("，然后将事件从列表中删去。")]),n._v(" "),t("p",[n._v("注意在迄今为止的所有设计中，我们仍然不能准确地知道一个“事件”要做什么。这正是整个设计的关键；它怎样“将发生变化的东西同没有变化的东西区分开”？或者用我的话来讲，“改变的意图”造成了各类"),t("code",[n._v("Event")]),n._v("对象的不同行动。我们通过创建不同的"),t("code",[n._v("Event")]),n._v("子类，从而表达出不同的行动。")]),n._v(" "),t("p",[n._v("这里正是内部类大显身手的地方。它们允许我们做两件事情：")]),n._v(" "),t("p",[n._v("(1) 在单独一个类里表达一个控制框架应用的全部实现细节，从而完整地封装与那个实现有关的所有东西。内部类用于表达多种不同类型的"),t("code",[n._v("action()")]),n._v("，它们用于解决实际的问题。除此以外，后续的例子使用了"),t("code",[n._v("private")]),n._v("内部类，所以实现细节会完全隐藏起来，可以安全地修改。")]),n._v(" "),t("p",[n._v("(2) 内部类使我们具体的实现变得更加巧妙，因为能方便地访问外部类的任何成员。若不具备这种能力，代码看起来就可能没那么使人舒服，最后不得不寻找其他方法解决。")]),n._v(" "),t("p",[n._v("现在要请大家思考控制框架的一种具体实现方式，它设计用来控制温室（"),t("code",[n._v("Greenhouse")]),n._v("）功能（注释④）。每个行动都是完全不同的：控制灯光、供水以及温度自动调节的开与关，控制响铃，以及重新启动系统。但控制框架的设计宗旨是将不同的代码方便地隔离开。对每种类型的行动，都要继承一个新的"),t("code",[n._v("Event")]),n._v("内部类，并在"),t("code",[n._v("action()")]),n._v("内编写相应的控制代码。")]),n._v(" "),t("p",[n._v("④：由于某些特殊原因，这对我来说是一个经常需要解决的、非常有趣的问题；原来的例子在《C++ Inside & Out》一书里也出现过，但Java提供了一种更令人舒适的解决方案。")]),n._v(" "),t("p",[n._v("作为应用程序框架的一种典型行为，"),t("code",[n._v("GreenhouseControls")]),n._v("类是从"),t("code",[n._v("Controller")]),n._v("继承的：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//: GreenhouseControls.java\n// This produces a specific application of the\n// control system, all in a single class. Inner\n// classes allow you to encapsulate different\n// functionality for each type of event.\npackage c07.controller;\n\npublic class GreenhouseControls\n    extends Controller {\n  private boolean light = false;\n  private boolean water = false;\n  private String thermostat = "Day";\n  private class LightOn extends Event {\n    public LightOn(long eventTime) {\n      super(eventTime);\n    }\n    public void action() {\n      // Put hardware control code here to\n      // physically turn on the light.\n      light = true;\n    }\n    public String description() {\n      return "Light is on";\n    }\n  }\n  private class LightOff extends Event {\n    public LightOff(long eventTime) {\n      super(eventTime);\n    }\n    public void action() {\n      // Put hardware control code here to\n      // physically turn off the light.\n      light = false;\n    }\n    public String description() {\n      return "Light is off";\n    }\n  }\n  private class WaterOn extends Event {\n    public WaterOn(long eventTime) {\n      super(eventTime);\n    }\n    public void action() {\n      // Put hardware control code here\n      water = true;\n    }\n    public String description() {\n      return "Greenhouse water is on";\n    }\n  }\n  private class WaterOff extends Event {\n    public WaterOff(long eventTime) {\n      super(eventTime);\n    }\n    public void action() {\n      // Put hardware control code here\n      water = false;\n    }\n    public String description() {\n      return "Greenhouse water is off";\n    }\n  }\n  private class ThermostatNight extends Event {\n    public ThermostatNight(long eventTime) {\n      super(eventTime);\n    }\n    public void action() {\n      // Put hardware control code here\n      thermostat = "Night";\n    }\n    public String description() {\n      return "Thermostat on night setting";\n    }\n  }\n  private class ThermostatDay extends Event {\n    public ThermostatDay(long eventTime) {\n      super(eventTime);\n    }\n    public void action() {\n      // Put hardware control code here\n      thermostat = "Day";\n    }\n    public String description() {\n      return "Thermostat on day setting";\n    }\n  }\n  // An example of an action() that inserts a\n  // new one of itself into the event list:\n  private int rings;\n  private class Bell extends Event {\n    public Bell(long eventTime) {\n      super(eventTime);\n    }\n    public void action() {\n      // Ring bell every 2 seconds, rings times:\n      System.out.println("Bing!");\n      if(--rings > 0)\n        addEvent(new Bell(\n          System.currentTimeMillis() + 2000));\n    }\n    public String description() {\n      return "Ring bell";\n    }\n  }\n  private class Restart extends Event {\n    public Restart(long eventTime) {\n      super(eventTime);\n    }\n    public void action() {\n      long tm = System.currentTimeMillis();\n      // Instead of hard-wiring, you could parse\n      // configuration information from a text\n      // file here:\n      rings = 5;\n      addEvent(new ThermostatNight(tm));\n      addEvent(new LightOn(tm + 1000));\n      addEvent(new LightOff(tm + 2000));\n      addEvent(new WaterOn(tm + 3000));\n      addEvent(new WaterOff(tm + 8000));\n      addEvent(new Bell(tm + 9000));\n      addEvent(new ThermostatDay(tm + 10000));\n      // Can even add a Restart object!\n      addEvent(new Restart(tm + 20000));\n    }\n    public String description() {\n      return "Restarting system";\n    }\n  }\n  public static void main(String[] args) {\n    GreenhouseControls gc =\n      new GreenhouseControls();\n    long tm = System.currentTimeMillis();\n    gc.addEvent(gc.new Restart(tm));\n    gc.run();\n  }\n} ///:~\n')])])]),t("p",[n._v("注意"),t("code",[n._v("light")]),n._v("（灯光）、"),t("code",[n._v("water")]),n._v("（供水）、"),t("code",[n._v("thermostat")]),n._v("（调温）以及"),t("code",[n._v("rings")]),n._v("都隶属于外部类"),t("code",[n._v("GreenhouseControls")]),n._v("，所以内部类可以毫无阻碍地访问那些字段。此外，大多数"),t("code",[n._v("action()")]),n._v("方法也涉及到某些形式的硬件控制，这通常都要求发出对非Java代码的调用。")]),n._v(" "),t("p",[n._v("大多数"),t("code",[n._v("Event")]),n._v("类看起来都是相似的，但"),t("code",[n._v("Bell")]),n._v("（铃）和"),t("code",[n._v("Restart")]),n._v("（重启）属于特殊情况。"),t("code",[n._v("Bell")]),n._v("会发出响声，若尚未响铃足够的次数，它会在事件列表里添加一个新的"),t("code",[n._v("Bell")]),n._v("对象，所以以后会再度响铃。请注意内部类看起来为什么总是类似于多重继承："),t("code",[n._v("Bell")]),n._v("拥有"),t("code",[n._v("Event")]),n._v("的所有方法，而且也拥有外部类"),t("code",[n._v("GreenhouseControls")]),n._v("的所有方法。")]),n._v(" "),t("p",[t("code",[n._v("Restart")]),n._v("负责对系统进行初始化，所以会添加所有必要的事件。当然，一种更灵活的做法是避免进行“硬编码”，而是从一个文件里读入它们（第10章的一个练习会要求大家修改这个例子，从而达到这个目标）。由于"),t("code",[n._v("Restart()")]),n._v("仅仅是另一个"),t("code",[n._v("Event")]),n._v("对象，所以也可以在"),t("code",[n._v("Restart.action()")]),n._v("里添加一个"),t("code",[n._v("Restart")]),n._v("对象，使系统能够定期重启。在"),t("code",[n._v("main()")]),n._v("中，我们需要做的全部事情就是创建一个"),t("code",[n._v("GreenhouseControls")]),n._v("对象，并添加一个"),t("code",[n._v("Restart")]),n._v("对象，令其工作起来。")]),n._v(" "),t("p",[n._v("这个例子应该使大家对内部类的价值有一个更加深刻的认识，特别是在一个控制框架里使用它们的时候。此外，在第13章的后半部分，大家还会看到如何巧妙地利用内部类描述一个图形用户界面的行为。完成那里的学习后，对内部类的认识将上升到一个前所未有的新高度。")])])}),[],!1,null,null,null);e.default=i.exports}}]);