(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{494:function(i,t,a){"use strict";a.r(t);var s=a(56),n=Object(s.a)({},(function(){var i=this,t=i.$createElement,a=i._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[a("h1",{attrs:{id:"_16-7-访问器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-7-访问器模式"}},[i._v("#")]),i._v(" 16.7 访问器模式")]),i._v(" "),a("p",[i._v("接下来，让我们思考如何将具有完全不同目标的一个设计模式应用到垃圾归类系统。")]),i._v(" "),a("p",[i._v("对这个模式，我们不再关心在系统中加入新型"),a("code",[i._v("Trash")]),i._v("时的优化。事实上，这个模式使新型"),a("code",[i._v("Trash")]),i._v("的添加显得更加复杂。假定我们有一个基本类结构，它是固定不变的；它或许来自另一个开发者或公司，我们无权对那个结构进行任何修改。然而，我们又希望在那个结构里加入新的多态性方法。这意味着我们一般必须在基类的接口里添加某些东西。因此，我们目前面临的困境是一方面需要向基类添加方法，另一方面又不能改动基类。怎样解决这个问题呢？")]),i._v(" "),a("p",[i._v("“访问器”（"),a("code",[i._v("Visitor")]),i._v("）模式使我们能扩展基本类型的接口，方法是创建类型为"),a("code",[i._v("Visitor")]),i._v("的一个独立的类结构，对以后需对基本类型采取的操作进行虚拟。基本类型的任务就是简单地“接收”访问器，然后调用访问器的动态绑定方法。看起来就象下面这样：")]),i._v(" "),a("p",[a("img",{attrs:{src:"16-4.gif",alt:""}})]),i._v(" "),a("p",[i._v("现在，假如v是一个指向"),a("code",[i._v("Aluminum")]),i._v("（铝制品）的"),a("code",[i._v("Visitable")]),i._v("引用，那么下述代码：")]),i._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v("PriceVisitor pv = new PriceVisitor();\nv.accept(pv);\n")])])]),a("p",[i._v("会造成两个多态性方法调用：第一个会选择"),a("code",[i._v("accept()")]),i._v("的"),a("code",[i._v("Aluminum")]),i._v("版本；第二个则在"),a("code",[i._v("accept()")]),i._v("里——用基类"),a("code",[i._v("Visitor")]),i._v("引用"),a("code",[i._v("v")]),i._v("动态调用"),a("code",[i._v("visit()")]),i._v("的特定版本时。")]),i._v(" "),a("p",[i._v("这种配置意味着可采取"),a("code",[i._v("Visitor")]),i._v("的新子类的形式将新的功能添加到系统里，没必要接触"),a("code",[i._v("Trash")]),i._v("结构。这就是“访问器”模式最主要的优点：可为一个类结构添加新的多态性功能，同时不必改动结构——只要安装好了"),a("code",[i._v("accept()")]),i._v("方法。注意这个优点在这儿是有用的，但并不一定是我们在任何情况下的首选方案。所以在最开始的时候，就要判断这到底是不是自己需要的方案。")]),i._v(" "),a("p",[i._v("现在注意一件没有做成的事情：访问器方案防止了从主控"),a("code",[i._v("Trash")]),i._v("序列向单独类型序列的归类。所以我们可将所有东西都留在单主控序列中，只需用适当的访问器通过那个序列传递，即可达到希望的目标。尽管这似乎并非访问器模式的本意，但确实让我们达到了很希望达到的一个目标（避免使用RTTI）。")]),i._v(" "),a("p",[i._v("访问器模式中的双生分发负责同时判断"),a("code",[i._v("Trash")]),i._v("以及"),a("code",[i._v("Visitor")]),i._v("的类型。在下面的例子中，大家可看到"),a("code",[i._v("Visitor")]),i._v("的两种实现方式："),a("code",[i._v("PriceVisitor")]),i._v("用于判断总计及价格，而"),a("code",[i._v("WeightVisitor")]),i._v("用于跟踪重量。")]),i._v(" "),a("p",[i._v("可以看到，所有这些都是用回收程序一个新的、改进过的版本实现的。而且和"),a("code",[i._v("DoubleDispatch.java")]),i._v("一样，"),a("code",[i._v("Trash")]),i._v("类被保持孤立，并创建一个新接口来添加"),a("code",[i._v("accept()")]),i._v("方法：")]),i._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v("//: Visitable.java\n// An interface to add visitor functionality to\n// the Trash hierarchy without modifying the\n// base class.\npackage c16.trashvisitor;\nimport c16.trash.*;\n\ninterface Visitable {\n  // The new method:\n  void accept(Visitor v);\n} ///:~\n")])])]),a("p",[a("code",[i._v("Aluminum")]),i._v("，"),a("code",[i._v("Paper")]),i._v("，"),a("code",[i._v("Glass")]),i._v("以及"),a("code",[i._v("Cardboard")]),i._v("的子类型实现了"),a("code",[i._v("accept()")]),i._v("方法：")]),i._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v("//: VAluminum.java\n// Aluminum for the visitor pattern\npackage c16.trashvisitor;\nimport c16.trash.*;\n\npublic class VAluminum extends Aluminum\n    implements Visitable {\n  public VAluminum(double wt) { super(wt); }\n  public void accept(Visitor v) {\n    v.visit(this);\n  }\n} ///:~\n//: VPaper.java\n// Paper for the visitor pattern\npackage c16.trashvisitor;\nimport c16.trash.*;\n\npublic class VPaper extends Paper\n    implements Visitable {\n  public VPaper(double wt) { super(wt); }\n  public void accept(Visitor v) {\n    v.visit(this);\n  }\n} ///:~\n//: VGlass.java\n// Glass for the visitor pattern\npackage c16.trashvisitor;\nimport c16.trash.*;\n\npublic class VGlass extends Glass\n    implements Visitable {\n  public VGlass(double wt) { super(wt); }\n  public void accept(Visitor v) {\n    v.visit(this);\n  }\n} ///:~\n//: VCardboard.java\n// Cardboard for the visitor pattern\npackage c16.trashvisitor;\nimport c16.trash.*;\n\npublic class VCardboard extends Cardboard\n    implements Visitable {\n  public VCardboard(double wt) { super(wt); }\n  public void accept(Visitor v) {\n    v.visit(this);\n  }\n} ///:~\n")])])]),a("p",[i._v("由于"),a("code",[i._v("Visitor")]),i._v("基类没有什么需要实在的东西，可将其创建成一个接口：")]),i._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v("//: Visitor.java\n// The base interface for visitors\npackage c16.trashvisitor;\nimport c16.trash.*;\n\ninterface Visitor {\n  void visit(VAluminum a);\n  void visit(VPaper p);\n  void visit(VGlass g);\n  void visit(VCardboard c);\n} ///:~\n\nc16.TrashVisitor.VGlass:54\nc16.TrashVisitor.VPaper:22\nc16.TrashVisitor.VPaper:11\nc16.TrashVisitor.VGlass:17\nc16.TrashVisitor.VAluminum:89\nc16.TrashVisitor.VPaper:88\nc16.TrashVisitor.VAluminum:76\nc16.TrashVisitor.VCardboard:96\nc16.TrashVisitor.VAluminum:25\nc16.TrashVisitor.VAluminum:34\nc16.TrashVisitor.VGlass:11\nc16.TrashVisitor.VGlass:68\nc16.TrashVisitor.VGlass:43\nc16.TrashVisitor.VAluminum:27\nc16.TrashVisitor.VCardboard:44\nc16.TrashVisitor.VAluminum:18\nc16.TrashVisitor.VPaper:91\nc16.TrashVisitor.VGlass:63\nc16.TrashVisitor.VGlass:50\nc16.TrashVisitor.VGlass:80\nc16.TrashVisitor.VAluminum:81\nc16.TrashVisitor.VCardboard:12\nc16.TrashVisitor.VGlass:12\nc16.TrashVisitor.VGlass:54\nc16.TrashVisitor.VAluminum:36\nc16.TrashVisitor.VAluminum:93\nc16.TrashVisitor.VGlass:93\nc16.TrashVisitor.VPaper:80\nc16.TrashVisitor.VGlass:36\nc16.TrashVisitor.VGlass:12\nc16.TrashVisitor.VGlass:60\nc16.TrashVisitor.VPaper:66\nc16.TrashVisitor.VAluminum:36\nc16.TrashVisitor.VCardboard:22\n")])])]),a("p",[i._v("程序剩余的部分将创建特定的"),a("code",[i._v("Visitor")]),i._v("类型，并通过一个"),a("code",[i._v("Trash")]),i._v("对象列表发送它们：")]),i._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v('//: TrashVisitor.java\n// The "visitor" pattern\npackage c16.trashvisitor;\nimport c16.trash.*;\nimport java.util.*;\n\n// Specific group of algorithms packaged\n// in each implementation of Visitor:\nclass PriceVisitor implements Visitor {\n  private double alSum; // Aluminum\n  private double pSum; // Paper\n  private double gSum; // Glass\n  private double cSum; // Cardboard\n  public void visit(VAluminum al) {\n    double v = al.weight() * al.value();\n    System.out.println(\n      "value of Aluminum= " + v);\n    alSum += v;\n  }\n  public void visit(VPaper p) {\n    double v = p.weight() * p.value();\n    System.out.println(\n      "value of Paper= " + v);\n    pSum += v;\n  }\n  public void visit(VGlass g) {\n    double v = g.weight() * g.value();\n    System.out.println(\n      "value of Glass= " + v);\n    gSum += v;\n  }\n  public void visit(VCardboard c) {\n    double v = c.weight() * c.value();\n    System.out.println(\n      "value of Cardboard = " + v);\n    cSum += v;\n  }\n  void total() {\n    System.out.println(\n      "Total Aluminum: $" + alSum + "\\n" +\n      "Total Paper: $" + pSum + "\\n" +\n      "Total Glass: $" + gSum + "\\n" +\n      "Total Cardboard: $" + cSum);\n  }\n}\n\nclass WeightVisitor implements Visitor {\n  private double alSum; // Aluminum\n  private double pSum; // Paper\n  private double gSum; // Glass\n  private double cSum; // Cardboard\n  public void visit(VAluminum al) {\n    alSum += al.weight();\n    System.out.println("weight of Aluminum = "\n        + al.weight());\n  }\n  public void visit(VPaper p) {\n    pSum += p.weight();\n    System.out.println("weight of Paper = "\n        + p.weight());\n  }\n  public void visit(VGlass g) {\n    gSum += g.weight();\n    System.out.println("weight of Glass = "\n        + g.weight());\n  }\n  public void visit(VCardboard c) {\n    cSum += c.weight();\n    System.out.println("weight of Cardboard = "\n        + c.weight());\n  }\n  void total() {\n    System.out.println("Total weight Aluminum:"\n        + alSum);\n    System.out.println("Total weight Paper:"\n        + pSum);\n    System.out.println("Total weight Glass:"\n        + gSum);\n    System.out.println("Total weight Cardboard:"\n        + cSum);\n  }\n}\n\npublic class TrashVisitor {\n  public static void main(String[] args) {\n    Vector bin = new Vector();\n    // ParseTrash still works, without changes:\n    ParseTrash.fillBin("VTrash.dat", bin);\n    // You could even iterate through\n    // a list of visitors!\n    PriceVisitor pv = new PriceVisitor();\n    WeightVisitor wv = new WeightVisitor();\n    Enumeration it = bin.elements();\n    while(it.hasMoreElements()) {\n      Visitable v = (Visitable)it.nextElement();\n      v.accept(pv);\n      v.accept(wv);\n    }\n    pv.total();\n    wv.total();\n  }\n} ///:~\n')])])]),a("p",[i._v("注意"),a("code",[i._v("main()")]),i._v("的形状已再次发生了变化。现在只有一个垃圾（"),a("code",[i._v("Trash")]),i._v("）筒。两个"),a("code",[i._v("Visitor")]),i._v("对象被接收到序列中的每个元素内，它们会完成自己份内的工作。"),a("code",[i._v("Visitor")]),i._v("跟踪它们自己的内部数据，计算出总重和价格。")]),i._v(" "),a("p",[i._v("最好，将东西从序列中取出的时候，除了不可避免地向"),a("code",[i._v("Trash")]),i._v("转换以外，再没有运行期的类型验证。若在Java里实现了参数化类型，甚至那个转换操作也可以避免。")]),i._v(" "),a("p",[i._v("对比之前介绍过的双重分发方案，区分这两种方案的一个办法是：在双重分发方案中，每个子类创建时只会重载其中的一个重载方法，即"),a("code",[i._v("add()")]),i._v("。而在这里，每个重载的"),a("code",[i._v("visit()")]),i._v("方法都必须在"),a("code",[i._v("Visitor")]),i._v("的每个子类中进行重载。")]),i._v(" "),a("p",[i._v("(1) 更多的结合？")]),i._v(" "),a("p",[i._v("这里还有其他许多代码，"),a("code",[i._v("Trash")]),i._v("结构和"),a("code",[i._v("Visitor")]),i._v("结构之间存在着明显的“结合”（"),a("code",[i._v("Coupling")]),i._v("）关系。然而，在它们所代表的类集内部，也存在着高度的凝聚力：都只做一件事情（"),a("code",[i._v("Trash")]),i._v("描述垃圾或废品，而"),a("code",[i._v("Visitor")]),i._v("描述对垃圾采取什么行动）。作为一套优秀的设计模式，这无疑是个良好的开端。当然就目前的情况来说，只有在我们添加新的"),a("code",[i._v("Visitor")]),i._v("类型时才能体会到它的好处。但在添加新类型的"),a("code",[i._v("Trash")]),i._v("时，它却显得有些碍手碍脚。")]),i._v(" "),a("p",[i._v("类与类之间低度的结合与类内高度的凝聚无疑是一个重要的设计目标。但只要稍不留神，就可能妨碍我们得到一个本该更出色的设计。从表面看，有些类不可避免地相互间存在着一些“亲密”关系。这种关系通常是成对发生的，可以叫作“对联”（"),a("code",[i._v("Couplet")]),i._v("）——比如集合和迭代器（"),a("code",[i._v("Enumeration")]),i._v("）。前面的"),a("code",[i._v("Trash-Visitor")]),i._v("对似乎也是这样的一种“对联”。")])])}),[],!1,null,null,null);t.default=n.exports}}]);