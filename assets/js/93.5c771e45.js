(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{491:function(a,e,n){"use strict";n.r(e);var t=n(56),s=Object(t.a)({},(function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"_16-4-改进设计"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-4-改进设计"}},[a._v("#")]),a._v(" 16.4 改进设计")]),a._v(" "),n("p",[a._v("《设计模式》书内所有方案的组织都围绕“程序进化时会发生什么变化”这个问题展开。对于任何设计来说，这都可能是最重要的一个问题。若根据对这个问题的回答来构造自己的系统，就可以得到两个方面的结果：系统不仅更易维护（而且更廉价），而且能产生一些能够重复使用的对象，进而使其他相关系统的构造也变得更廉价。这正是面向对象程序设计的优势所在，但这一优势并不是自动体现出来的。它要求对我们对需要解决的问题有全面而且深入的理解。在这一节中，我们准备在系统的逐步改进过程中向大家展示如何做到这一点。")]),a._v(" "),n("p",[a._v("就目前这个回收系统来说，对“什么会变化”这个问题的回答是非常普通的：更多的类型会加入系统。因此，设计的目标就是尽可能简化这种类型的添加。在回收程序中，我们准备把涉及特定类型信息的所有地方都封装起来。这样一来（如果没有别的原因），所有变化对那些封装来说都是在本地进行的。这种处理方式也使代码剩余的部分显得特别清爽。")]),a._v(" "),n("h2",{attrs:{id:"_16-4-1-制作更多的对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-4-1-制作更多的对象"}},[a._v("#")]),a._v(" 16.4.1 “制作更多的对象”")]),a._v(" "),n("p",[a._v("这样便引出了面向对象程序设计时一条常规的准则，我最早是在Grady Booch那里听说的：“若设计过于复杂，就制作更多的对象”。尽管听起来有些暧昧，且简单得可笑，但这确实是我知道的最有用一条准则（大家以后会注意到“制作更多的对象”经常等同于“添加另一个层次的迂回”）。一般情况下，如果发现一个地方充斥着大量繁复的代码，就需要考虑什么类能使它显得清爽一些。用这种方式整理系统，往往会得到一个更好的结构，也使程序更加灵活。")]),a._v(" "),n("p",[a._v("首先考虑Trash对象首次创建的地方，这是"),n("code",[a._v("main()")]),a._v("里的一个"),n("code",[a._v("switch")]),a._v("语句：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("    for(int i = 0; i < 30; i++)\n      switch((int)(Math.random() * 3)) {\n        case 0 :\n          bin.addElement(new\n            Aluminum(Math.random() * 100));\n          break;\n        case 1 :\n          bin.addElement(new\n            Paper(Math.random() * 100));\n          break;\n        case 2 :\n          bin.addElement(new\n            Glass(Math.random() * 100));\n      }\n")])])]),n("p",[a._v("这些代码显然“过于复杂”，也是新类型加入时必须改动代码的场所之一。如果经常都要加入新类型，那么更好的方案就是建立一个独立的方法，用它获取所有必需的信息，并创建一个引用，指向正确类型的一个对象——已经向上转换到一个"),n("code",[a._v("Trash")]),a._v("对象。在《设计模式》中，它被粗略地称呼为“创建模式”。要在这里应用的特殊模式是"),n("code",[a._v("Factory")]),a._v("方法的一种变体。在这里，"),n("code",[a._v("Factory")]),a._v("方法属于"),n("code",[a._v("Trash")]),a._v("的一名"),n("code",[a._v("static")]),a._v("（静态）成员。但更常见的一种情况是：它属于派生类中一个被重载的方法。")]),a._v(" "),n("p",[n("code",[a._v("Factory")]),a._v("方法的基本原理是我们将创建对象所需的基本信息传递给它，然后返回并等候引用（已经向上转换至基类型）作为返回值出现。从这时开始，就可以按多态性的方式对待对象了。因此，我们根本没必要知道所创建对象的准确类型是什么。事实上，"),n("code",[a._v("Factory")]),a._v("方法会把自己隐藏起来，我们是看不见它的。这样做可防止不慎的误用。如果想在没有多态性的前提下使用对象，必须明确地使用RTTI和指定转换。")]),a._v(" "),n("p",[a._v("但仍然存在一个小问题，特别是在基类中使用更复杂的方法（不是在这里展示的那种），且在派生类里重载（覆盖）了它的前提下。如果在派生类里请求的信息要求更多或者不同的参数，那么该怎么办呢？“创建更多的对象”解决了这个问题。为实现"),n("code",[a._v("Factory")]),a._v("方法，"),n("code",[a._v("Trash")]),a._v("类使用了一个新的方法，名为"),n("code",[a._v("factory")]),a._v("。为了将创建数据隐藏起来，我们用一个名为"),n("code",[a._v("Info")]),a._v("的新类包含"),n("code",[a._v("factory")]),a._v("方法创建适当的"),n("code",[a._v("Trash")]),a._v("对象时需要的全部信息。下面是"),n("code",[a._v("Info")]),a._v("一种简单的实现方式：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("class Info {\n  int type;\n  // Must change this to add another type:\n  static final int MAX_NUM = 4;\n  double data;\n  Info(int typeNum, double dat) {\n    type = typeNum % MAX_NUM;\n    data = dat;\n  }\n}\n\n")])])]),n("p",[n("code",[a._v("Info")]),a._v("对象唯一的任务就是容纳用于"),n("code",[a._v("factory()")]),a._v("方法的信息。现在，假如出现了一种特殊情况，"),n("code",[a._v("factory()")]),a._v("需要更多或者不同的信息来新建一种类型的"),n("code",[a._v("Trash")]),a._v("对象，那么再也不需要改动"),n("code",[a._v("factory()")]),a._v("了。通过添加新的数据和构造器，我们可以修改"),n("code",[a._v("Info")]),a._v("类，或者采用子类处理更典型的面向对象形式。")]),a._v(" "),n("p",[a._v("用于这个简单示例的"),n("code",[a._v("factory()")]),a._v("方法如下：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  static Trash factory(Info i) {\n    switch(i.type) {\n      default: // To quiet the compiler\n      case 0:\n        return new Aluminum(i.data);\n      case 1:\n        return new Paper(i.data);\n      case 2:\n        return new Glass(i.data);\n      // Two lines here:\n      case 3:\n        return new Cardboard(i.data);\n    }\n  }\n")])])]),n("p",[a._v("在这里，对象的准确类型很容易即可判断出来。但我们可以设想一些更复杂的情况，"),n("code",[a._v("factory()")]),a._v("将采用一种复杂的算法。无论如何，现在的关键是它已隐藏到某个地方，而且我们在添加新类型时知道去那个地方。")]),a._v(" "),n("p",[a._v("新对象在"),n("code",[a._v("main()")]),a._v("中的创建现在变得非常简单和清爽：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("    for(int i = 0; i < 30; i++)\n      bin.addElement(\n        Trash.factory(\n          new Info(\n            (int)(Math.random() * Info.MAX_NUM),\n            Math.random() * 100)));\n")])])]),n("p",[a._v("我们在这里创建了一个"),n("code",[a._v("Info")]),a._v("对象，用于将数据传入"),n("code",[a._v("factory()")]),a._v("；后者在内存堆中创建某种T"),n("code",[a._v("rash")]),a._v("对象，并返回添加到"),n("code",[a._v("Vector bin")]),a._v("内的引用。当然，如果改变了参数的数量及类型，仍然需要修改这个语句。但假如"),n("code",[a._v("Info")]),a._v("对象的创建是自动进行的，也可以避免那个麻烦。例如，可将参数的一个"),n("code",[a._v("Vector")]),a._v("传递到"),n("code",[a._v("Info")]),a._v("对象的构造器中（或直接传入一个"),n("code",[a._v("factory()")]),a._v("调用）。这要求在运行期间对参数进行分析与检查，但确实提供了非常高的灵活程度。")]),a._v(" "),n("p",[a._v("大家从这个代码可看出"),n("code",[a._v("Factory")]),a._v("要负责解决的“领头变化”问题：如果向系统添加了新类型（发生了变化），唯一需要修改的代码在"),n("code",[a._v("Factory")]),a._v("内部，所以"),n("code",[a._v("Factory")]),a._v("将那种变化的影响隔离出来了。")]),a._v(" "),n("h2",{attrs:{id:"_16-4-2-用于原型创建的一个模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-4-2-用于原型创建的一个模式"}},[a._v("#")]),a._v(" 16.4.2 用于原型创建的一个模式")]),a._v(" "),n("p",[a._v("上述设计模式的一个问题是仍然需要一个中心场所，必须在那里知道所有类型的对象：在"),n("code",[a._v("factory()")]),a._v("方法内部。如果经常都要向系统添加新类型，"),n("code",[a._v("factory()")]),a._v("方法为每种新类型都要修改一遍。若确实对这个问题感到苦恼，可试试再深入一步，将与类型有关的所有信息——包括它的创建过程——都移入代表那种类型的类内部。这样一来，每次新添一种类型的时候，需要做的唯一事情就是从一个类继承。")]),a._v(" "),n("p",[a._v("为将涉及类型创建的信息移入特定类型的Trash里，必须使用“原型”（"),n("code",[a._v("prototype")]),a._v("）模式（来自《设计模式》那本书）。这里最基本的想法是我们有一个主控对象序列，为自己感兴趣的每种类型都制作一个。这个序列中的对象只能用于新对象的创建，采用的操作类似内建到Java根类"),n("code",[a._v("Object")]),a._v("内部的"),n("code",[a._v("clone()")]),a._v("机制。在这种情况下，我们将克隆方法命名为"),n("code",[a._v("tClone()")]),a._v("。准备创建一个新对象时，要事先收集好某种形式的信息，用它建立我们希望的对象类型。然后在主控序列中遍历，将手上的信息与主控序列中原型对象内任何适当的信息作对比。若找到一个符合自己需要的，就克隆它。")]),a._v(" "),n("p",[a._v("采用这种方案，我们不必用硬编码的方式植入任何创建信息。每个对象都知道如何揭示出适当的信息，以及如何对自身进行克隆。所以一种新类型加入系统的时候，"),n("code",[a._v("factory()")]),a._v("方法不需要任何改变。")]),a._v(" "),n("p",[a._v("为解决原型的创建问题，一个方法是添加大量方法，用它们支持新对象的创建。但在Java 1.1中，如果拥有指向"),n("code",[a._v("Class")]),a._v("对象的一个引用，那么它已经提供了对创建新对象的支持。利用Java 1.1的“反射”（已在第11章介绍）技术，即便我们只有指向"),n("code",[a._v("Class")]),a._v("对象的一个引用，亦可正常地调用一个构造器。这对原型问题的解决无疑是个完美的方案。")]),a._v(" "),n("p",[a._v("原型列表将由指向所有想创建的"),n("code",[a._v("Class")]),a._v("对象的一个引用列表间接地表示。除此之外，假如原型处理失败，则"),n("code",[a._v("factory()")]),a._v("方法会认为由于一个特定的"),n("code",[a._v("Class")]),a._v("对象不在列表中，所以会尝试装载它。通过以这种方式动态装载原型，"),n("code",[a._v("Trash")]),a._v("类根本不需要知道自己要操纵的是什么类型。因此，在我们添加新类型时不需要作出任何形式的修改。于是，我们可在本章剩余的部分方便地重复利用它。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('//: Trash.java\n// Base class for Trash recycling examples\npackage c16.trash;\nimport java.util.*;\nimport java.lang.reflect.*;\n\npublic abstract class Trash {\n  private double weight;\n  Trash(double wt) { weight = wt; }\n  Trash() {}\n  public abstract double value();\n  public double weight() { return weight; }\n  // Sums the value of Trash in a bin:\n  public static void sumValue(Vector bin) {\n    Enumeration e = bin.elements();\n    double val = 0.0f;\n    while(e.hasMoreElements()) {\n      // One kind of RTTI:\n      // A dynamically-checked cast\n      Trash t = (Trash)e.nextElement();\n      val += t.weight() * t.value();\n      System.out.println(\n        "weight of " +\n        // Using RTTI to get type\n        // information about the class:\n        t.getClass().getName() +\n        " = " + t.weight());\n    }\n    System.out.println("Total value = " + val);\n  }\n  // Remainder of class provides support for\n  // prototyping:\n  public static class PrototypeNotFoundException\n      extends Exception {}\n  public static class CannotCreateTrashException\n      extends Exception {}\n  private static Vector trashTypes =\n    new Vector();\n  public static Trash factory(Info info)\n      throws PrototypeNotFoundException,\n      CannotCreateTrashException {\n    for(int i = 0; i < trashTypes.size(); i++) {\n      // Somehow determine the new type\n      // to create, and create one:\n      Class tc =\n        (Class)trashTypes.elementAt(i);\n      if (tc.getName().indexOf(info.id) != -1) {\n        try {\n          // Get the dynamic constructor method\n          // that takes a double argument:\n          Constructor ctor =\n            tc.getConstructor(\n              new Class[] {double.class});\n          // Call the constructor to create a\n          // new object:\n          return (Trash)ctor.newInstance(\n            new Object[]{new Double(info.data)});\n        } catch(Exception ex) {\n          ex.printStackTrace();\n          throw new CannotCreateTrashException();\n        }\n      }\n    }\n    // Class was not in the list. Try to load it,\n    // but it must be in your class path!\n    try {\n      System.out.println("Loading " + info.id);\n      trashTypes.addElement(\n        Class.forName(info.id));\n    } catch(Exception e) {\n      e.printStackTrace();\n      throw new PrototypeNotFoundException();\n    }\n    // Loaded successfully. Recursive call\n    // should work this time:\n    return factory(info);\n  }\n  public static class Info {\n    public String id;\n    public double data;\n    public Info(String name, double data) {\n      id = name;\n      this.data = data;\n    }\n  }\n} ///:~\n')])])]),n("p",[a._v("基本"),n("code",[a._v("Trash")]),a._v("类和"),n("code",[a._v("sumValue()")]),a._v("还是象往常一样。这个类剩下的部分支持原型模式。大家首先会看到两个内部类（被设为"),n("code",[a._v("static")]),a._v("属性，使其成为只为代码组织目的而存在的内部类），它们描述了可能出现的异常。在它后面跟随的是一个"),n("code",[a._v("Vector trashTypes")]),a._v("，用于容纳"),n("code",[a._v("Class")]),a._v("引用。")]),a._v(" "),n("p",[a._v("在"),n("code",[a._v("Trash.factory()")]),a._v("中，"),n("code",[a._v("Info")]),a._v("对象"),n("code",[a._v("id")]),a._v("（"),n("code",[a._v("Info")]),a._v("类的另一个版本，与前面讨论的不同）内部的"),n("code",[a._v("String")]),a._v("包含了要创建的那种"),n("code",[a._v("Trash")]),a._v("的类型名称。这个"),n("code",[a._v("String")]),a._v("会与列表中的"),n("code",[a._v("Class")]),a._v("名比较。若存在相符的，那便是要创建的对象。当然，还有很多方法可以决定我们想创建的对象。之所以要采用这种方法，是因为从一个文件读入的信息可以转换成对象。")]),a._v(" "),n("p",[a._v("发现自己要创建的"),n("code",[a._v("Trash")]),a._v("（垃圾）种类后，接下来就轮到“反射”方法大显身手了。"),n("code",[a._v("getConstructor()")]),a._v("方法需要取得自己的参数——由"),n("code",[a._v("Class")]),a._v("引用构成的一个数组。这个数组代表着不同的参数，并按它们正确的顺序排列，以便我们查找的构造器使用。在这儿，该数组是用Java 1.1的数组创建语法动态创建的：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("new Class[] {double.class}\n")])])]),n("p",[a._v("这个代码假定所有"),n("code",[a._v("Trash")]),a._v("类型都有一个需要"),n("code",[a._v("double")]),a._v("数值的构造器（注意"),n("code",[a._v("double.class")]),a._v("与"),n("code",[a._v("Double.class")]),a._v("是不同的）。若考虑一种更灵活的方案，亦可调用"),n("code",[a._v("getConstructors()")]),a._v("，令其返回可用构造器的一个数组。")]),a._v(" "),n("p",[a._v("从"),n("code",[a._v("getConstructors()")]),a._v("返回的是指向一个"),n("code",[a._v("Constructor")]),a._v("对象的引用（该对象是"),n("code",[a._v("java.lang.reflect")]),a._v("的一部分）。我们用方法"),n("code",[a._v("newInstance()")]),a._v("动态地调用构造器。该方法需要获取包含了实际参数的一个"),n("code",[a._v("Object")]),a._v("数组。这个数组同样是按Java 1.1的语法创建的：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("new Object[] {new Double(info.data)}\n")])])]),n("p",[a._v("在这种情况下，"),n("code",[a._v("double")]),a._v("必须置入一个封装（容器）类的内部，使其真正成为这个对象数组的一部分。通过调用"),n("code",[a._v("newInstance()")]),a._v("，会提取出"),n("code",[a._v("double")]),a._v("，但大家可能会觉得稍微有些迷惑——参数既可能是"),n("code",[a._v("double")]),a._v("，也可能是"),n("code",[a._v("Double")]),a._v("，但在调用的时候必须用"),n("code",[a._v("Double")]),a._v("传递。幸运的是，这个问题只存在于基本数据类型中间。")]),a._v(" "),n("p",[a._v("理解了具体的过程后，再来创建一个新对象，并且只为它提供一个"),n("code",[a._v("Class")]),a._v("引用，事情就变得非常简单了。就目前的情况来说，内部循环中的"),n("code",[a._v("return")]),a._v("永远不会执行，我们在终点就会退出。在这儿，程序动态装载"),n("code",[a._v("Class")]),a._v("对象，并把它加入"),n("code",[a._v("trashTypes")]),a._v("（垃圾类型）列表，从而试图纠正这个问题。若仍然找不到真正有问题的地方，同时装载又是成功的，那么就重复调用"),n("code",[a._v("factory")]),a._v("方法，重新试一遍。")]),a._v(" "),n("p",[a._v("正如大家会看到的那样，这种设计模式最大的优点就是不需要改动代码。无论在什么情况下，它都能正常地使用（假定所有"),n("code",[a._v("Trash")]),a._v("子类都包含了一个构造器，用以获取单个"),n("code",[a._v("double")]),a._v("参数）。")]),a._v(" "),n("p",[a._v("(1) Trash子类")]),a._v(" "),n("p",[a._v("为了与原型机制相适应，对"),n("code",[a._v("Trash")]),a._v("每个新子类唯一的要求就是在其中包含了一个构造器，指示它获取一个"),n("code",[a._v("double")]),a._v("参数。Java 1.1的“反射”机制可负责剩下的所有工作。")]),a._v(" "),n("p",[a._v("下面是不同类型的"),n("code",[a._v("Trash")]),a._v("，每种类型都有它们自己的文件里，但都属于"),n("code",[a._v("Trash")]),a._v("包的一部分（同样地，为了方便在本章内重复使用）：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//: Aluminum.java\n// The Aluminum class with prototyping\npackage c16.trash;\n\npublic class Aluminum extends Trash {\n  private static double val = 1.67f;\n  public Aluminum(double wt) { super(wt); }\n  public double value() { return val; }\n  public static void value(double newVal) {\n    val = newVal;\n  }\n} ///:~\n")])])]),n("p",[a._v("下面是一种新的"),n("code",[a._v("Trash")]),a._v("类型：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//: Cardboard.java\n// The Cardboard class with prototyping\npackage c16.trash;\n\npublic class Cardboard extends Trash {\n  private static double val = 0.23f;\n  public Cardboard(double wt) { super(wt); }\n  public double value() { return val; }\n  public static void value(double newVal) {\n    val = newVal;\n  }\n} ///:~\n")])])]),n("p",[a._v("可以看出，除构造器以外，这些类根本没有什么特别的地方。")]),a._v(" "),n("p",[a._v("(2) 从外部文件中解析出"),n("code",[a._v("Trash")])]),a._v(" "),n("p",[a._v("与"),n("code",[a._v("Trash")]),a._v("对象有关的信息将从一个外部文件中读取。针对"),n("code",[a._v("Trash")]),a._v("的每个方面，文件内列出了所有必要的信息——每行都代表一个方面，采用"),n("code",[a._v("垃圾（废品）名称:值")]),a._v("的固定格式。例如：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("c16.Trash.Glass:54\nc16.Trash.Paper:22\nc16.Trash.Paper:11\nc16.Trash.Glass:17\nc16.Trash.Aluminum:89\nc16.Trash.Paper:88\nc16.Trash.Aluminum:76\nc16.Trash.Cardboard:96\nc16.Trash.Aluminum:25\nc16.Trash.Aluminum:34\nc16.Trash.Glass:11\nc16.Trash.Glass:68\nc16.Trash.Glass:43\nc16.Trash.Aluminum:27\nc16.Trash.Cardboard:44\nc16.Trash.Aluminum:18\nc16.Trash.Paper:91\nc16.Trash.Glass:63\nc16.Trash.Glass:50\nc16.Trash.Glass:80\nc16.Trash.Aluminum:81\nc16.Trash.Cardboard:12\nc16.Trash.Glass:12\nc16.Trash.Glass:54\nc16.Trash.Aluminum:36\nc16.Trash.Aluminum:93\nc16.Trash.Glass:93\nc16.Trash.Paper:80\nc16.Trash.Glass:36\nc16.Trash.Glass:12\nc16.Trash.Glass:60\nc16.Trash.Paper:66\nc16.Trash.Aluminum:36\nc16.Trash.Cardboard:22\n\n")])])]),n("p",[a._v("注意在给定类名的时候，类路径必须包含在内，否则就找不到类。")]),a._v(" "),n("p",[a._v("为解析它，每一行内容都会读入，并用字符串方法"),n("code",[a._v("indexOf()")]),a._v("来建立"),n("code",[a._v(":")]),a._v("的一个索引。首先用字符串方法"),n("code",[a._v("substring()")]),a._v("取出垃圾的类型名称，接着用一个静态方法"),n("code",[a._v("Double.valueOf()")]),a._v("取得相应的值，并转换成一个"),n("code",[a._v("double")]),a._v("值。"),n("code",[a._v("trim()")]),a._v("方法则用于删除字符串两头的多余空格。")]),a._v(" "),n("p",[n("code",[a._v("Trash")]),a._v("解析器置入单独的文件中，因为本章将不断地用到它。如下所示：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//: ParseTrash.java\n// Open a file and parse its contents into\n// Trash objects, placing each into a Vector\npackage c16.trash;\nimport java.util.*;\nimport java.io.*;\n\npublic class ParseTrash {\n  public static void\n  fillBin(String filename, Fillable bin) {\n    try {\n      BufferedReader data =\n        new BufferedReader(\n          new FileReader(filename));\n      String buf;\n      while((buf = data.readLine())!= null) {\n        String type = buf.substring(0,\n          buf.indexOf(':')).trim();\n        double weight = Double.valueOf(\n          buf.substring(buf.indexOf(':') + 1)\n          .trim()).doubleValue();\n        bin.addTrash(\n          Trash.factory(\n            new Trash.Info(type, weight)));\n      }\n      data.close();\n    } catch(IOException e) {\n      e.printStackTrace();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n  // Special case to handle Vector:\n  public static void\n  fillBin(String filename, Vector bin) {\n    fillBin(filename, new FillableVector(bin));\n  }\n} ///:~\n\n")])])]),n("p",[a._v("在"),n("code",[a._v("RecycleA.java")]),a._v("中，我们用一个"),n("code",[a._v("Vector")]),a._v("容纳"),n("code",[a._v("Trash")]),a._v("对象。然而，亦可考虑采用其他集合类型。为做到这一点，"),n("code",[a._v("fillBin()")]),a._v("的第一个版本将获取指向一个"),n("code",[a._v("Fillable")]),a._v("的引用。后者是一个接口，用于支持一个名为"),n("code",[a._v("addTrash()")]),a._v("的方法：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//: Fillable.java\n// Any object that can be filled with Trash\npackage c16.trash;\n\npublic interface Fillable {\n  void addTrash(Trash t);\n} ///:~\n")])])]),n("p",[a._v("支持该接口的所有东西都能伴随"),n("code",[a._v("fillBin")]),a._v("使用。当然，"),n("code",[a._v("Vector")]),a._v("并未实现"),n("code",[a._v("Fillable")]),a._v("，所以它不能工作。由于"),n("code",[a._v("Vector")]),a._v("将在大多数例子中应用，所以最好的做法是添加另一个重载的"),n("code",[a._v("fillBin()")]),a._v("方法，令其以一个"),n("code",[a._v("Vector")]),a._v("作为参数。利用一个适配器（"),n("code",[a._v("Adapter")]),a._v("）类，这个"),n("code",[a._v("Vector")]),a._v("可作为一个"),n("code",[a._v("Fillable")]),a._v("对象使用：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//: FillableVector.java\n// Adapter that makes a Vector Fillable\npackage c16.trash;\nimport java.util.*;\n\npublic class FillableVector implements Fillable {\n  private Vector v;\n  public FillableVector(Vector vv) { v = vv; }\n  public void addTrash(Trash t) {\n    v.addElement(t);\n  }\n} ///:~\n")])])]),n("p",[a._v("可以看到，这个类唯一的任务就是负责将"),n("code",[a._v("Fillable")]),a._v("的"),n("code",[a._v("addTrash()")]),a._v("同"),n("code",[a._v("Vector")]),a._v("的"),n("code",[a._v("addElement()")]),a._v("方法连接起来。利用这个类，已重载的"),n("code",[a._v("fillBin()")]),a._v("方法可在"),n("code",[a._v("ParseTrash.java")]),a._v("中伴随一个"),n("code",[a._v("Vector")]),a._v("使用：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  public static void\n  fillBin(String filename, Vector bin) {\n    fillBin(filename, new FillableVector(bin));\n  }\n")])])]),n("p",[a._v("这种方案适用于任何频繁用到的集合类。除此以外，集合类还可提供它自己的适配器类，并实现"),n("code",[a._v("Fillable")]),a._v("（稍后即可看到，在"),n("code",[a._v("DynaTrash.java")]),a._v("中）。")]),a._v(" "),n("p",[a._v("(3) 原型机制的重复应用")]),a._v(" "),n("p",[a._v("现在，大家可以看到采用原型技术的、修订过的"),n("code",[a._v("RecycleA.java")]),a._v("版本了：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('//: RecycleAP.java\n// Recycling with RTTI and Prototypes\npackage c16.recycleap;\nimport c16.trash.*;\nimport java.util.*;\n\npublic class RecycleAP {\n  public static void main(String[] args) {\n    Vector bin = new Vector();\n    // Fill up the Trash bin:\n    ParseTrash.fillBin("Trash.dat", bin);\n    Vector\n      glassBin = new Vector(),\n      paperBin = new Vector(),\n      alBin = new Vector();\n    Enumeration sorter = bin.elements();\n    // Sort the Trash:\n    while(sorter.hasMoreElements()) {\n      Object t = sorter.nextElement();\n      // RTTI to show class membership:\n      if(t instanceof Aluminum)\n        alBin.addElement(t);\n      if(t instanceof Paper)\n        paperBin.addElement(t);\n      if(t instanceof Glass)\n        glassBin.addElement(t);\n    }\n    Trash.sumValue(alBin);\n    Trash.sumValue(paperBin);\n    Trash.sumValue(glassBin);\n    Trash.sumValue(bin);\n  }\n} ///:~\n\n')])])]),n("p",[a._v("所有"),n("code",[a._v("Trash")]),a._v("对象——以及"),n("code",[a._v("ParseTrash")]),a._v("及支撑类——现在都成为名为"),n("code",[a._v("c16.trash")]),a._v("的一个包的一部分，所以它们可以简单地导入。")]),a._v(" "),n("p",[a._v("无论打开包含了"),n("code",[a._v("Trash")]),a._v("描述信息的数据文件，还是对那个文件进行解析，所有涉及到的操作均已封装到"),n("code",[a._v("static")]),a._v("（静态）方法"),n("code",[a._v("ParseTrash.fillBin()")]),a._v("里。所以它现在已经不是我们设计过程中要注意的一个重点。在本章剩余的部分，大家经常都会看到无论添加的是什么类型的新类，"),n("code",[a._v("ParseTrash.fillBin()")]),a._v("都会持续工作，不会发生改变，这无疑是一种优良的设计模式。")]),a._v(" "),n("p",[a._v("提到对象的创建，这一方案确实已将新类型加入系统所需的变动严格地“本地化”了。但在使用RTTI的过程中，却存在着一个严重的问题，这里已明确地显露出来。程序表面上工作得很好，但却永远侦测到不能“硬纸板”（"),n("code",[a._v("Cardboard")]),a._v("）这种新的废品类型——即使列表里确实有一个硬纸板类型！之所以会出现这种情况，完全是由于使用了RTTI的缘故。RTTI只会查找那些我们告诉它查找的东西。RTTI在这里错误的用法是“系统中的每种类型”都进行了测试，而不是仅测试一种类型或者一个类型子集。正如大家以后会看到的那样，在测试每一种类型时可换用其他方式来运用多态性特征。但假如以这种形式过多地使用RTTI，而且又在自己的系统里添加了一种新类型，很容易就会忘记在程序里作出适当的改动，从而埋下以后难以发现的Bug。因此，在这种情况下避免使用RTTI是很有必要的，这并不仅仅是为了表面好看——也是为了产生更易维护的代码。")])])}),[],!1,null,null,null);e.default=s.exports}}]);