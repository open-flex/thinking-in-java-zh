(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{551:function(n,t,e){"use strict";e.r(t);var a=e(56),i=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_7-5-接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-接口"}},[n._v("#")]),n._v(" 7.5 接口")]),n._v(" "),e("p",[e("code",[n._v("interface")]),n._v("（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。它允许创建者规定一个类的基本形式：方法名、参数列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为"),e("code",[n._v("static")]),n._v("和"),e("code",[n._v("final")]),n._v("。接口只提供一种形式，并不提供实现的细节。")]),n._v(" "),e("p",[n._v("接口这样描述自己：“对于实现我的所有类，看起来都应该象我现在这个样子”。因此，采用了一个特定接口的所有代码都知道对于那个接口可能会调用什么方法。这便是接口的全部含义。所以我们常把接口用于建立类和类之间的一个“协议”。有些面向对象的程序设计语言采用了一个名为"),e("code",[n._v("protocol")]),n._v("（协议）的关键字，它做的便是与接口相同的事情。")]),n._v(" "),e("p",[n._v("为创建一个接口，请使用"),e("code",[n._v("interface")]),n._v("关键字，而不要用"),e("code",[n._v("class")]),n._v("。与类相似，我们可在"),e("code",[n._v("interface")]),n._v("关键字的前面增加一个"),e("code",[n._v("public")]),n._v("关键字（但只有接口定义于同名的一个文件内）；或者将其省略，营造一种“友好的”状态。")]),n._v(" "),e("p",[n._v("为了生成与一个特定的接口（或一组接口）相符的类，要使用"),e("code",[n._v("implements")]),n._v("（实现）关键字。我们要表达的意思是“接口看起来就象那个样子，这儿是它具体的工作细节”。除这些之外，我们其他的工作都与继承极为相似。下面是乐器例子的示意图：")]),n._v(" "),e("p",[e("img",{attrs:{src:"7-4.gif",alt:""}})]),n._v(" "),e("p",[n._v("具体实现了一个接口以后，就获得了一个普通的类，可用标准方式对其进行扩展。")]),n._v(" "),e("p",[n._v("可决定将一个接口中的方法声明明确定义为"),e("code",[n._v("public")]),n._v("。但即便不明确定义，它们也会默认为"),e("code",[n._v("public")]),n._v("。所以在实现一个接口的时候，来自接口的方法必须定义成"),e("code",[n._v("public")]),n._v("。否则的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java编译器不允许我们那样做。")]),n._v(" "),e("p",[n._v("在"),e("code",[n._v("Instrument")]),n._v("例子的修改版本中，大家可明确地看出这一点。注意接口中的每个方法都严格地是一个声明，它是编译器唯一允许的。除此以外，"),e("code",[n._v("Instrument5")]),n._v("中没有一个方法被声明为"),e("code",[n._v("public")]),n._v("，但它们都会自动获得"),e("code",[n._v("public")]),n._v("属性。如下所示：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//: Music5.java\n// Interfaces\nimport java.util.*;\n\ninterface Instrument5 {\n  // Compile-time constant:\n  int i = 5; // static & final\n  // Cannot have method definitions:\n  void play(); // Automatically public\n  String what();\n  void adjust();\n}\n\nclass Wind5 implements Instrument5 {\n  public void play() {\n    System.out.println("Wind5.play()");\n  }\n  public String what() { return "Wind5"; }\n  public void adjust() {}\n}\n\nclass Percussion5 implements Instrument5 {\n  public void play() {\n    System.out.println("Percussion5.play()");\n  }\n  public String what() { return "Percussion5"; }\n  public void adjust() {}\n}\n\nclass Stringed5 implements Instrument5 {\n  public void play() {\n    System.out.println("Stringed5.play()");\n  }\n  public String what() { return "Stringed5"; }\n  public void adjust() {}\n}\n\nclass Brass5 extends Wind5 {\n  public void play() {\n    System.out.println("Brass5.play()");\n  }\n  public void adjust() {\n    System.out.println("Brass5.adjust()");\n  }\n}\n\nclass Woodwind5 extends Wind5 {\n  public void play() {\n    System.out.println("Woodwind5.play()");\n  }\n  public String what() { return "Woodwind5"; }\n}\n\npublic class Music5 {\n  // Doesn\'t care about type, so new types\n  // added to the system still work right:\n  static void tune(Instrument5 i) {\n    // ...\n    i.play();\n  }\n  static void tuneAll(Instrument5[] e) {\n    for(int i = 0; i < e.length; i++)\n      tune(e[i]);\n  }\n  public static void main(String[] args) {\n    Instrument5[] orchestra = new Instrument5[5];\n    int i = 0;\n    // Upcasting during addition to the array:\n    orchestra[i++] = new Wind5();\n    orchestra[i++] = new Percussion5();\n    orchestra[i++] = new Stringed5();\n    orchestra[i++] = new Brass5();\n    orchestra[i++] = new Woodwind5();\n    tuneAll(orchestra);\n  }\n} ///:~\n')])])]),e("p",[n._v("代码剩余的部分按相同的方式工作。我们可以自由决定向上转换到一个名为"),e("code",[n._v("Instrument5")]),n._v("的“普通”类，一个名为"),e("code",[n._v("Instrument5")]),n._v("的“抽象”类，或者一个名为"),e("code",[n._v("Instrument5")]),n._v("的“接口”。所有行为都是相同的。事实上，我们在"),e("code",[n._v("tune()方")]),n._v("法中可以发现没有任何证据显示"),e("code",[n._v("Instrument5")]),n._v("到底是个“普通”类、“抽象”类还是一个“接口”。这是做是故意的：每种方法都使程序员能对对象的创建与使用进行不同的控制。")]),n._v(" "),e("h2",{attrs:{id:"_7-5-1-java的-多重继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-1-java的-多重继承"}},[n._v("#")]),n._v(" 7.5.1 Java的“多重继承”")]),n._v(" "),e("p",[n._v("接口只是比抽象类“更纯”的一种形式。它的用途并不止那些。由于接口根本没有具体的实现细节——也就是说，没有与存储空间与“接口”关联在一起——所以没有任何办法可以防止多个接口合并到一起。这一点是至关重要的，因为我们经常都需要表达这样一个意思：“"),e("code",[n._v("x")]),n._v("从属于"),e("code",[n._v("a")]),n._v("，也从属于"),e("code",[n._v("b")]),n._v("，也从属于"),e("code",[n._v("c")]),n._v("”。在C++中，将多个类合并到一起的行动称作“多重继承”，而且操作较为不便，因为每个类都可能有一套自己的实现细节。在Java中，我们可采取同样的行动，但只有其中一个类拥有具体的实现细节。所以在合并多个接口的时候，C++的问题不会在Java中重演。如下所示：")]),n._v(" "),e("p",[e("img",{attrs:{src:"7-5.gif",alt:""}})]),n._v(" "),e("p",[n._v("在一个派生类中，我们并不一定要拥有一个抽象或具体（没有抽象方法）的基类。如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于"),e("code",[n._v("implements")]),n._v("关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行向上转换。下面这个例子展示了一个“具体”类同几个接口合并的情况，它最终生成了一个新类：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//: Adventure.java\n// Multiple interfaces\nimport java.util.*;\n\ninterface CanFight {\n  void fight();\n}\n\ninterface CanSwim {\n  void swim();\n}\n\ninterface CanFly {\n  void fly();\n}\n\nclass ActionCharacter {\n  public void fight() {}\n}\n\nclass Hero extends ActionCharacter\n    implements CanFight, CanSwim, CanFly {\n  public void swim() {}\n  public void fly() {}\n}\n\npublic class Adventure {\n  static void t(CanFight x) { x.fight(); }\n  static void u(CanSwim x) { x.swim(); }\n  static void v(CanFly x) { x.fly(); }\n  static void w(ActionCharacter x) { x.fight(); }\n  public static void main(String[] args) {\n    Hero i = new Hero();\n    t(i); // Treat it as a CanFight\n    u(i); // Treat it as a CanSwim\n    v(i); // Treat it as a CanFly\n    w(i); // Treat it as an ActionCharacter\n  }\n} ///:~\n")])])]),e("p",[n._v("从中可以看到，"),e("code",[n._v("Hero")]),n._v("将具体类"),e("code",[n._v("ActionCharacter")]),n._v("同接口"),e("code",[n._v("CanFight")]),n._v("，"),e("code",[n._v("CanSwim")]),n._v("以及"),e("code",[n._v("CanFly")]),n._v("合并起来。按这种形式合并一个具体类与接口的时候，具体类必须首先出现，然后才是接口（否则编译器会报错）。")]),n._v(" "),e("p",[n._v("请注意"),e("code",[n._v("fight()")]),n._v("的签名在"),e("code",[n._v("CanFight")]),n._v("接口与"),e("code",[n._v("ActionCharacter")]),n._v("类中是相同的，而且没有在"),e("code",[n._v("Hero")]),n._v("中为"),e("code",[n._v("fight()")]),n._v("提供一个具体的定义。接口的规则是：我们可以从它继承（稍后就会看到），但这样得到的将是另一个接口。如果想创建新类型的一个对象，它就必须是已提供所有定义的一个类。尽管"),e("code",[n._v("Hero")]),n._v("没有为"),e("code",[n._v("fight()")]),n._v("明确地提供一个定义，但定义是随同"),e("code",[n._v("ActionCharacter")]),n._v("来的，所以这个定义会自动提供，我们可以创建"),e("code",[n._v("Hero")]),n._v("的对象。")]),n._v(" "),e("p",[n._v("在类"),e("code",[n._v("Adventure")]),n._v("中，我们可看到共有四个方法，它们将不同的接口和具体类作为自己的参数使用。创建一个"),e("code",[n._v("Hero")]),n._v("对象后，它可以传递给这些方法中的任何一个。这意味着它们会依次向上转换到每一个接口。由于接口是用Java设计的，所以这样做不会有任何问题，而且程序员不必对此加以任何特别的关注。")]),n._v(" "),e("p",[n._v("注意上述例子已向我们揭示了接口最关键的作用，也是使用接口最重要的一个原因：能向上转换至多个基类。使用接口的第二个原因与使用抽象基类的原因是一样的：防止客户程序员制作这个类的一个对象，以及规定它仅仅是一个接口。这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？若使用接口，我们可以同时获得抽象类以及接口的好处。所以假如想创建的基类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。事实上，如果事先知道某种东西会成为基类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。")]),n._v(" "),e("h2",{attrs:{id:"_7-5-2-通过继承扩展接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-2-通过继承扩展接口"}},[n._v("#")]),n._v(" 7.5.2 通过继承扩展接口")]),n._v(" "),e("p",[n._v("利用继承技术，可方便地为一个接口添加新的方法声明，也可以将几个接口合并成一个新接口。在这两种情况下，最终得到的都是一个新接口，如下例所示：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//: HorrorShow.java\n// Extending an interface with inheritance\n\ninterface Monster {\n  void menace();\n}\n\ninterface DangerousMonster extends Monster {\n  void destroy();\n}\n\ninterface Lethal {\n  void kill();\n}\n\nclass DragonZilla implements DangerousMonster {\n  public void menace() {}\n  public void destroy() {}\n}\n\ninterface Vampire\n    extends DangerousMonster, Lethal {\n  void drinkBlood();\n}\n\nclass HorrorShow {\n  static void u(Monster b) { b.menace(); }\n  static void v(DangerousMonster d) {\n    d.menace();\n    d.destroy();\n  }\n  public static void main(String[] args) {\n    DragonZilla if2 = new DragonZilla();\n    u(if2);\n    v(if2);\n  }\n} ///:~\n")])])]),e("p",[e("code",[n._v("DangerousMonster")]),n._v("是对"),e("code",[n._v("Monster")]),n._v("的一个简单的扩展，最终生成了一个新接口。这是在"),e("code",[n._v("DragonZilla")]),n._v("里实现的。")]),n._v(" "),e("p",[e("code",[n._v("Vampire")]),n._v("的语法仅在继承接口时才可使用。通常，我们只能对单独一个类应用"),e("code",[n._v("extends")]),n._v("（扩展）关键字。但由于接口可能由多个其他接口构成，所以在构建一个新接口时，"),e("code",[n._v("extends")]),n._v("可能引用多个基础接口。正如大家看到的那样，接口的名字只是简单地使用逗号分隔。")]),n._v(" "),e("h2",{attrs:{id:"_7-5-3-常数分组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-3-常数分组"}},[n._v("#")]),n._v(" 7.5.3 常数分组")]),n._v(" "),e("p",[n._v("由于置入一个接口的所有字段都自动具有"),e("code",[n._v("static")]),n._v("和"),e("code",[n._v("final")]),n._v("属性，所以接口是对常数值进行分组的一个好工具，它具有与C或C++的"),e("code",[n._v("enum")]),n._v("非常相似的效果。如下例所示：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//: Months.java\n// Using interfaces to create groups of constants\npackage c07;\n\npublic interface Months {\n  int\n    JANUARY = 1, FEBRUARY = 2, MARCH = 3,\n    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,\n    AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,\n    NOVEMBER = 11, DECEMBER = 12;\n} ///:~\n")])])]),e("p",[n._v("注意根据Java命名规则，拥有固定标识符的"),e("code",[n._v("static final")]),n._v("基本数据类型（亦即编译期常数）都全部采用大写字母（用下划线分隔单个标识符里的多个单词）。")]),n._v(" "),e("p",[n._v("接口中的字段会自动具备"),e("code",[n._v("public")]),n._v("属性，所以没必要专门指定。")]),n._v(" "),e("p",[n._v("现在，通过导入 "),e("code",[n._v("c07.*")]),n._v(" 或 "),e("code",[n._v("c07.Months")]),n._v(" ，我们可以从包的外部使用常数——就象对其他任何包进行的操作那样。此外，也可以用类似"),e("code",[n._v("Months.JANUARY")]),n._v("的表达式对值进行引用。当然，我们获得的只是一个"),e("code",[n._v("int")]),n._v("，所以不象C++的"),e("code",[n._v("enum")]),n._v("那样拥有额外的类型安全性。但与将数字强行编码（硬编码）到自己的程序中相比，这种（常用的）技术无疑已经是一个巨大的进步。我们通常把“硬编码”数字的行为称为“魔术数字”，它产生的代码是非常难以维护的。")]),n._v(" "),e("p",[n._v("如确实不想放弃额外的类型安全性，可构建象下面这样的一个类（注释①）：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//: Month2.java\n// A more robust enumeration system\npackage c07;\n\npublic final class Month2 {\n  private String name;\n  private Month2(String nm) { name = nm; }\n  public String toString() { return name; }\n  public final static Month2\n    JAN = new Month2("January"),\n    FEB = new Month2("February"),\n    MAR = new Month2("March"),\n    APR = new Month2("April"),\n    MAY = new Month2("May"),\n    JUN = new Month2("June"),\n    JUL = new Month2("July"),\n    AUG = new Month2("August"),\n    SEP = new Month2("September"),\n    OCT = new Month2("October"),\n    NOV = new Month2("November"),\n    DEC = new Month2("December");\n  public final static Month2[] month =  {\n    JAN, JAN, FEB, MAR, APR, MAY, JUN,\n    JUL, AUG, SEP, OCT, NOV, DEC\n  };\n  public static void main(String[] args) {\n    Month2 m = Month2.JAN;\n    System.out.println(m);\n    m = Month2.month[12];\n    System.out.println(m);\n    System.out.println(m == Month2.DEC);\n    System.out.println(m.equals(Month2.DEC));\n  }\n} ///:~\n')])])]),e("p",[n._v("①：是Rich Hoffarth的一封E-mail触发了我这样编写程序的灵感。")]),n._v(" "),e("p",[n._v("这个类叫作"),e("code",[n._v("Month2")]),n._v("，因为标准Java库里已经有一个"),e("code",[n._v("Month")]),n._v("。它是一个"),e("code",[n._v("final")]),n._v("类，并含有一个"),e("code",[n._v("private")]),n._v("构造器，所以没有人能从它继承，或制作它的一个实例。唯一的实例就是那些"),e("code",[n._v("final static")]),n._v("对象，它们是在类本身内部创建的，包括："),e("code",[n._v("JAN")]),n._v("，"),e("code",[n._v("FEB")]),n._v("，"),e("code",[n._v("MAR")]),n._v("等等。这些对象也在"),e("code",[n._v("month")]),n._v("数组中使用，后者让我们能够按数字挑选月份，而不是按名字（注意数组中提供了一个多余的"),e("code",[n._v("JAN")]),n._v("，使偏移量增加了1，也使"),e("code",[n._v("December")]),n._v("确实成为12月）。在"),e("code",[n._v("main()")]),n._v("中，我们可注意到类型的安全性："),e("code",[n._v("m")]),n._v("是一个"),e("code",[n._v("Month2")]),n._v("对象，所以只能将其分配给"),e("code",[n._v("Month2")]),n._v("。在前面的"),e("code",[n._v("Months.java")]),n._v("例子中，只提供了"),e("code",[n._v("int")]),n._v("值，所以本来想用来代表一个月份的"),e("code",[n._v("int")]),n._v("变量可能实际获得一个整数值，那样做可能不十分安全。")]),n._v(" "),e("p",[n._v("这儿介绍的方法也允许我们交换使用"),e("code",[n._v("==")]),n._v("或者"),e("code",[n._v("equals()")]),n._v("，就象"),e("code",[n._v("main()")]),n._v("尾部展示的那样。")]),n._v(" "),e("h2",{attrs:{id:"_7-5-4-初始化接口中的字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-4-初始化接口中的字段"}},[n._v("#")]),n._v(" 7.5.4 初始化接口中的字段")]),n._v(" "),e("p",[n._v("接口中定义的字段会自动具有"),e("code",[n._v("static")]),n._v("和"),e("code",[n._v("final")]),n._v("属性。它们不能是“空白"),e("code",[n._v("final")]),n._v("”，但可初始化成非常数表达式。例如：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//: RandVals.java\n// Initializing interface fields with\n// non-constant initializers\nimport java.util.*;\n\npublic interface RandVals {\n  int rint = (int)(Math.random() * 10);\n  long rlong = (long)(Math.random() * 10);\n  float rfloat = (float)(Math.random() * 10);\n  double rdouble = Math.random() * 10;\n} ///:~\n")])])]),e("p",[n._v("由于字段是"),e("code",[n._v("static")]),n._v("的，所以它们会在首次装载类之后、以及首次访问任何字段之前获得初始化。下面是一个简单的测试：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//: TestRandVals.java\n\npublic class TestRandVals {\n  public static void main(String[] args) {\n    System.out.println(RandVals.rint);\n    System.out.println(RandVals.rlong);\n    System.out.println(RandVals.rfloat);\n    System.out.println(RandVals.rdouble);\n  }\n} ///:~\n")])])]),e("p",[n._v("当然，字段并不是接口的一部分，而是保存于那个接口的"),e("code",[n._v("static")]),n._v("存储区域中。")])])}),[],!1,null,null,null);t.default=i.exports}}]);