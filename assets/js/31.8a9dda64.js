(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{429:function(e,t,n){"use strict";n.r(t);var a=n(56),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_10-7-java-1-1的io流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-7-java-1-1的io流"}},[e._v("#")]),e._v(" 10.7 Java 1.1的IO流")]),e._v(" "),n("p",[e._v("到这个时候，大家或许会陷入一种困境之中，怀疑是否存在IO流的另一种设计模式，并可能要求更大的代码量。还有人能提出一种更古怪的设计吗？事实上，Java 1.1对IO流库进行了一些重大的改进。看到"),n("code",[e._v("Reader")]),e._v("和"),n("code",[e._v("Writer")]),e._v("类时，大多数人的第一个印象（就象我一样）就是它们用来替换原来的"),n("code",[e._v("InputStream")]),e._v("和"),n("code",[e._v("OutputStream")]),e._v("类。但实情并非如此。尽管不建议使用原始数据流库的某些功能（如使用它们，会从编译器收到一条警告消息），但原来的数据流依然得到了保留，以便维持向后兼容，而且：")]),e._v(" "),n("p",[e._v("(1) 在老式层次结构里加入了新类，所以Sun公司明显不会放弃老式数据流。")]),e._v(" "),n("p",[e._v("(2) 在许多情况下，我们需要与新结构中的类联合使用老结构中的类。为达到这个目的，需要使用一些“桥”类：")]),e._v(" "),n("p",[n("code",[e._v("InputStreamReader")]),e._v("将一个"),n("code",[e._v("InputStream")]),e._v("转换成"),n("code",[e._v("Reader")]),e._v("，"),n("code",[e._v("OutputStreamWriter")]),e._v("将一个"),n("code",[e._v("OutputStream")]),e._v("转换成"),n("code",[e._v("Writer")]),e._v("。\n所以与原来的IO流库相比，经常都要对新IO流进行层次更多的封装。同样地，这也属于装饰器方案的一个缺点——需要为额外的灵活性付出代价。")]),e._v(" "),n("p",[e._v("之所以在Java 1.1里添加了"),n("code",[e._v("Reader")]),e._v("和"),n("code",[e._v("Writer")]),e._v("层次，最重要的原因便是国际化的需求。老式IO流层次结构只支持8位字节流，不能很好地控制16位Unicode字符。由于Unicode主要面向的是国际化支持（Java内含的"),n("code",[e._v("char")]),e._v("是16位的Unicode），所以添加了"),n("code",[e._v("Reader")]),e._v("和"),n("code",[e._v("Writer")]),e._v("层次，以提供对所有IO操作中的Unicode的支持。除此之外，新库也对速度进行了优化，可比旧库更快地运行。")]),e._v(" "),n("p",[e._v("与本书其他地方一样，我会试着提供对类的一个概述，但假定你会利用联机文档搞定所有的细节，比如方法的详尽列表等。")]),e._v(" "),n("h2",{attrs:{id:"_10-7-1-数据的发起与接收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-7-1-数据的发起与接收"}},[e._v("#")]),e._v(" 10.7.1 数据的发起与接收")]),e._v(" "),n("p",[e._v("Java 1.0的几乎所有IO流类都有对应的Java 1.1类，用于提供内建的Unicode管理。似乎最容易的事情就是“全部使用新类，再也不要用旧的”，但实际情况并没有这么简单。有些时候，由于受到库设计的一些限制，我们不得不使用Java 1.0的IO流类。特别要指出的是，在旧流库的基础上新加了"),n("code",[e._v("java.util.zip")]),e._v("库，它们依赖旧的流组件。所以最明智的做法是“尝试性”地使用"),n("code",[e._v("Reader")]),e._v("和"),n("code",[e._v("Writer")]),e._v("类。若代码不能通过编译，便知道必须换回老式库。")]),e._v(" "),n("p",[e._v("下面这张表格分旧库与新库分别总结了信息发起与接收之间的对应关系。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Sources & Sinks:\nJava 1.0 class\n\nCorresponding Java 1.1 class\n\nInputStream\n\nReader\nconverter: InputStreamReader\n\nOutputStream\n\nWriter\nconverter: OutputStreamWriter\n\nFileInputStream\n\nFileReader\n\nFileOutputStream\n\nFileWriter\n\nStringBufferInputStream\n\nStringReader\n\n(no corresponding class)\n\nStringWriter\n\nByteArrayInputStream\n\nCharArrayReader\n\nByteArrayOutputStream\n\nCharArrayWriter\n\nPipedInputStream\n\nPipedReader\n\nPipedOutputStream\n\nPipedWriter\n\n")])])]),n("p",[e._v("我们发现即使不完全一致，但旧库组件中的接口与新接口通常也是类似的。")]),e._v(" "),n("h2",{attrs:{id:"_10-7-2-修改数据流的行为"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-7-2-修改数据流的行为"}},[e._v("#")]),e._v(" 10.7.2 修改数据流的行为")]),e._v(" "),n("p",[e._v("在Java 1.0中，数据流通过"),n("code",[e._v("FilterInputStream")]),e._v("和"),n("code",[e._v("FilterOutputStream")]),e._v("的“装饰器”（Decorator）子类适应特定的需求。Java 1.1的IO流沿用了这一思想，但没有继续采用所有装饰器都从相同"),n("code",[e._v("filter")]),e._v("（过滤器）基类中派生这一做法。若通过观察类的层次结构来理解它，这可能令人出现少许的困惑。")]),e._v(" "),n("p",[e._v("在下面这张表格中，对应关系比上一张表要粗糙一些。之所以会出现这个差别，是由类的组织造成的：尽管"),n("code",[e._v("BufferedOutputStream")]),e._v("是"),n("code",[e._v("FilterOutputStream")]),e._v("的一个子类，但是"),n("code",[e._v("BufferedWriter")]),e._v("并不是"),n("code",[e._v("FilterWriter")]),e._v("的子类（对后者来说，尽管它是一个抽象类，但没有自己的子类或者近似子类的东西，也没有一个“占位符”可用，所以不必费心地寻找）。然而，两个类的接口是非常相似的，而且不管在什么情况下，显然应该尽可能地使用新版本，而不应考虑旧版本（也就是说，除非在一些类中必须生成一个"),n("code",[e._v("Stream")]),e._v("，不可生成"),n("code",[e._v("Reader")]),e._v("或者"),n("code",[e._v("Writer")]),e._v("）。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Filters:\nJava 1.0 class\n\nCorresponding Java 1.1 class\n\nFilterInputStream\n\nFilterReader\n\nFilterOutputStream\n\nFilterWriter (abstract class with no subclasses)\n\nBufferedInputStream\n\nBufferedReader\n(also has readLine( ))\n\nBufferedOutputStream\n\nBufferedWriter\n\nDataInputStream\n\nuse DataInputStream\n(Except when you need to use readLine( ), when you should use a BufferedReader)\n\nPrintStream\n\nPrintWriter\n\nLineNumberInputStream\n\nLineNumberReader\n\nStreamTokenizer\n\nStreamTokenizer\n(use constructor that takes a Reader instead)\n\nPushBackInputStream\n\nPushBackReader\n")])])]),n("p",[e._v("过滤器：Java 1.0类 对应的Java 1.1类")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("FilterInputStream FilterReader\nFilterOutputStream FilterWriter（没有子类的抽象类）\nBufferedInputStream BufferedReader（也有readLine()）\nBufferedOutputStream BufferedWriter\nDataInputStream 使用DataInputStream（除非要使用readLine()，那时需要使用一个BufferedReader）\nPrintStream PrintWriter\nLineNumberInputStream LineNumberReader\nStreamTokenizer StreamTokenizer（用构造器取代Reader）\nPushBackInputStream PushBackReader\n")])])]),n("p",[e._v("有一条规律是显然的：若想使用"),n("code",[e._v("readLine()")]),e._v("，就不要再用一个"),n("code",[e._v("DataInputStream")]),e._v("来实现（否则会在编译期得到一条出错消息），而应使用一个"),n("code",[e._v("BufferedReader")]),e._v("。但除这种情况以外，"),n("code",[e._v("DataInputStream")]),e._v("仍是Java 1.1 IO库的“首选”成员。")]),e._v(" "),n("p",[e._v("为了将向"),n("code",[e._v("PrintWriter")]),e._v("的过渡变得更加自然，它提供了能采用任何"),n("code",[e._v("OutputStream")]),e._v("对象的构造器。"),n("code",[e._v("PrintWriter")]),e._v("提供的格式化支持没有"),n("code",[e._v("PrintStream")]),e._v("那么多；但接口几乎是相同的。")]),e._v(" "),n("h2",{attrs:{id:"_10-7-3-未改变的类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-7-3-未改变的类"}},[e._v("#")]),e._v(" 10.7.3 未改变的类")]),e._v(" "),n("p",[e._v("显然，Java库的设计人员觉得以前的一些类毫无问题，所以没有对它们作任何修改，可象以前那样继续使用它们：")]),e._v(" "),n("p",[e._v("没有对应Java 1.1类的Java 1.0类")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("DataOutputStream\nFile\nRandomAccessFile\nSequenceInputStream\n")])])]),n("p",[e._v("特别未加改动的是"),n("code",[e._v("DataOutputStream")]),e._v("，所以为了用一种可转移的格式保存和获取数据，必须沿用"),n("code",[e._v("InputStream")]),e._v("和"),n("code",[e._v("OutputStream")]),e._v("层次结构。")]),e._v(" "),n("h2",{attrs:{id:"_10-7-4-一个例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-7-4-一个例子"}},[e._v("#")]),e._v(" 10.7.4 一个例子")]),e._v(" "),n("p",[e._v("为体验新类的效果，下面让我们看看如何修改"),n("code",[e._v("IOStreamDemo.java")]),e._v("示例的相应区域，以便使用"),n("code",[e._v("Reader")]),e._v("和"),n("code",[e._v("Writer")]),e._v("类：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: NewIODemo.java\n// Java 1.1 IO typical usage\nimport java.io.*;\n\npublic class NewIODemo {\n  public static void main(String[] args) {\n    try {\n      // 1. Reading input by lines:\n      BufferedReader in =\n        new BufferedReader(\n          new FileReader(args[0]));\n      String s, s2 = new String();\n      while((s = in.readLine())!= null)\n        s2 += s + "\\n";\n      in.close();\n\n      // 1b. Reading standard input:\n      BufferedReader stdin =\n        new BufferedReader(\n          new InputStreamReader(System.in));      \n      System.out.print("Enter a line:");\n      System.out.println(stdin.readLine());\n\n      // 2. Input from memory\n      StringReader in2 = new StringReader(s2);\n      int c;\n      while((c = in2.read()) != -1)\n        System.out.print((char)c);\n\n      // 3. Formatted memory input\n      try {\n        DataInputStream in3 =\n          new DataInputStream(\n            // Oops: must use deprecated class:\n            new StringBufferInputStream(s2));\n        while(true)\n          System.out.print((char)in3.readByte());\n      } catch(EOFException e) {\n        System.out.println("End of stream");\n      }\n\n      // 4. Line numbering & file output\n      try {\n        LineNumberReader li =\n          new LineNumberReader(\n            new StringReader(s2));\n        BufferedReader in4 =\n          new BufferedReader(li);\n        PrintWriter out1 =\n          new PrintWriter(\n            new BufferedWriter(\n              new FileWriter("IODemo.out")));\n        while((s = in4.readLine()) != null )\n          out1.println(\n            "Line " + li.getLineNumber() + s);\n        out1.close();\n      } catch(EOFException e) {\n        System.out.println("End of stream");\n      }\n\n      // 5. Storing & recovering data\n      try {\n        DataOutputStream out2 =\n          new DataOutputStream(\n            new BufferedOutputStream(\n              new FileOutputStream("Data.txt")));\n        out2.writeDouble(3.14159);\n        out2.writeBytes("That was pi");\n        out2.close();\n        DataInputStream in5 =\n          new DataInputStream(\n            new BufferedInputStream(\n              new FileInputStream("Data.txt")));\n        BufferedReader in5br =\n          new BufferedReader(\n            new InputStreamReader(in5));\n        // Must use DataInputStream for data:\n        System.out.println(in5.readDouble());\n        // Can now use the "proper" readLine():\n        System.out.println(in5br.readLine());\n      } catch(EOFException e) {\n        System.out.println("End of stream");\n      }\n\n      // 6. Reading and writing random access\n      // files is the same as before.\n      // (not repeated here)\n\n    } catch(FileNotFoundException e) {\n      System.out.println(\n        "File Not Found:" + args[1]);\n    } catch(IOException e) {\n      System.out.println("IO Exception");\n    }\n  }\n} ///:~\n')])])]),n("p",[e._v("大家一般看见的是转换过程非常直观，代码看起来也颇相似。但这些都不是重要的区别。最重要的是，由于随机访问文件已经改变，所以第6节未再重复。")]),e._v(" "),n("p",[e._v("第1节收缩了一点儿，因为假如要做的全部事情就是读取行输入，那么只需要将一个"),n("code",[e._v("FileReader")]),e._v("封装到"),n("code",[e._v("BufferedReader")]),e._v("之内即可。第"),n("code",[e._v("1b")]),e._v("节展示了封装"),n("code",[e._v("System.in")]),e._v("，以便读取控制台输入的新方法。这里的代码量增多了一些，因为"),n("code",[e._v("System.in")]),e._v("是一个"),n("code",[e._v("DataInputStream")]),e._v("，而且"),n("code",[e._v("BufferedReader")]),e._v("需要一个"),n("code",[e._v("Reader")]),e._v("参数，所以要用"),n("code",[e._v("InputStreamReader")]),e._v("来进行转换。")]),e._v(" "),n("p",[e._v("在2节，可以看到如果有一个字符串，而且想从中读取数据，只需用一个"),n("code",[e._v("StringReader")]),e._v("替换"),n("code",[e._v("StringBufferInputStream")]),e._v("，剩下的代码是完全相同的。")]),e._v(" "),n("p",[e._v("第3节揭示了新IO流库设计中的一个错误。如果有一个字符串，而且想从中读取数据，那么不能再以任何形式使用"),n("code",[e._v("StringBufferInputStream")]),e._v("。若编译一个涉及"),n("code",[e._v("StringBufferInputStream")]),e._v("的代码，会得到一条“反对”消息，告诉我们不要用它。此时最好换用一个"),n("code",[e._v("StringReader")]),e._v("。但是，假如要象第3节这样进行格式化的内存输入，就必须使用"),n("code",[e._v("DataInputStream")]),e._v("——没有什么"),n("code",[e._v("DataReader")]),e._v("可以代替它——而"),n("code",[e._v("DataInputStream")]),e._v("很不幸地要求用到一个"),n("code",[e._v("InputStream")]),e._v("参数。所以我们没有选择的余地，只好使用编译器不赞成的"),n("code",[e._v("StringBufferInputStream")]),e._v("类。编译器同样会发出反对信息，但我们对此束手无策（注释②）。\n"),n("code",[e._v("StringReader")]),e._v("替换"),n("code",[e._v("StringBufferInputStream")]),e._v("，剩下的代码是完全相同的。")]),e._v(" "),n("p",[e._v("②：到你现在正式使用的时候，这个错误可能已经修正。")]),e._v(" "),n("p",[e._v("第4节明显是从老式数据流到新数据流的一个直接转换，没有需要特别指出的。在第5节中，我们被强迫使用所有的老式数据流，因为"),n("code",[e._v("DataOutputStream")]),e._v("和"),n("code",[e._v("DataInputStream")]),e._v("要求用到它们，而且没有可供替换的东西。然而，编译期间不会产生任何“反对”信息。若不赞成一种数据流，通常是由于它的构造器产生了一条反对消息，禁止我们使用整个类。但在"),n("code",[e._v("DataInputStream")]),e._v("的情况下，只有"),n("code",[e._v("readLine()")]),e._v("是不赞成使用的，因为我们最好为"),n("code",[e._v("readLine()")]),e._v("使用一个"),n("code",[e._v("BufferedReader")]),e._v("（但为其他所有格式化输入都使用一个"),n("code",[e._v("DataInputStream")]),e._v("）。")]),e._v(" "),n("p",[e._v("若比较第5节和"),n("code",[e._v("IOStreamDemo.java")]),e._v("中的那一小节，会注意到在这个版本中，数据是在文本之前写入的。那是由于Java 1.1本身存在一个错误，如下述代码所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: IOBug.java\n// Java 1.1 (and higher?) IO Bug\nimport java.io.*;\n\npublic class IOBug {\n  public static void main(String[] args)\n  throws Exception {\n    DataOutputStream out =\n      new DataOutputStream(\n        new BufferedOutputStream(\n          new FileOutputStream("Data.txt")));\n    out.writeDouble(3.14159);\n    out.writeBytes("That was the value of pi\\n");\n    out.writeBytes("This is pi/2:\\n");\n    out.writeDouble(3.14159/2);\n    out.close();\n\n    DataInputStream in =\n      new DataInputStream(\n        new BufferedInputStream(\n          new FileInputStream("Data.txt")));\n    BufferedReader inbr =\n      new BufferedReader(\n        new InputStreamReader(in));\n    // The doubles written BEFORE the line of text\n    // read back correctly:\n    System.out.println(in.readDouble());\n    // Read the lines of text:\n    System.out.println(inbr.readLine());\n    System.out.println(inbr.readLine());\n    // Trying to read the doubles after the line\n    // produces an end-of-file exception:\n    System.out.println(in.readDouble());\n  }\n} ///:~\n')])])]),n("p",[e._v("看起来，我们在对一个"),n("code",[e._v("writeBytes()")]),e._v("的调用之后写入的任何东西都不是能够恢复的。这是一个十分有限的错误，希望在你读到本书的时候已获得改正。为检测是否改正，请运行上述程序。若没有得到一个异常，而且值都能正确打印出来，就表明已经改正。")]),e._v(" "),n("h2",{attrs:{id:"_10-7-5-重导向标准io"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-7-5-重导向标准io"}},[e._v("#")]),e._v(" 10.7.5 重导向标准IO")]),e._v(" "),n("p",[e._v("Java 1.1在"),n("code",[e._v("System")]),e._v("类中添加了特殊的方法，允许我们重新定向标准输入、输出以及错误IO流。此时要用到下述简单的静态方法调用：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("setIn(InputStream)\nsetOut(PrintStream)\nsetErr(PrintStream)\n")])])]),n("p",[e._v("如果突然要在屏幕上生成大量输出，而且滚动的速度快于人们的阅读速度，输出的重定向就显得特别有用。在一个命令行程序中，如果想重复测试一个特定的用户输入序列，输入的重定向也显得特别有价值。下面这个简单的例子展示了这些方法的使用：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: Redirecting.java\n// Demonstrates the use of redirection for\n// standard IO in Java 1.1\nimport java.io.*;\n\nclass Redirecting {\n  public static void main(String[] args) {\n    try {\n      BufferedInputStream in =\n        new BufferedInputStream(\n          new FileInputStream(\n            "Redirecting.java"));\n      // Produces deprecation message:\n      PrintStream out =\n        new PrintStream(\n          new BufferedOutputStream(\n            new FileOutputStream("test.out")));\n      System.setIn(in);\n      System.setOut(out);\n      System.setErr(out);\n\n      BufferedReader br =\n        new BufferedReader(\n          new InputStreamReader(System.in));\n      String s;\n      while((s = br.readLine()) != null)\n        System.out.println(s);\n      out.close(); // Remember this!\n    } catch(IOException e) {\n      e.printStackTrace();\n    }\n  }\n} ///:~\n\n')])])]),n("p",[e._v("这个程序的作用是将标准输入同一个文件连接起来，并将标准输出和错误重定向至另一个文件。\n这是不可避免会遇到“反对”消息的另一个例子。用"),n("code",[e._v("-deprecation")]),e._v("标志编译时得到的消息如下：")]),e._v(" "),n("blockquote",[n("p",[e._v("Note:The constructor "),n("code",[e._v("java.io.PrintStream(java.io.OutputStream)")]),e._v(" has been deprecated.\n注意：不推荐使用构造器"),n("code",[e._v("java.io.PrintStream（java.io.OutputStream）")]),e._v("。")])]),e._v(" "),n("p",[e._v("然而，无论"),n("code",[e._v("System.setOut()")]),e._v("还是"),n("code",[e._v("System.setErr()")]),e._v("都要求用一个"),n("code",[e._v("PrintStream")]),e._v("作为参数使用，所以必须调用"),n("code",[e._v("PrintStream")]),e._v("构造器。所以大家可能会觉得奇怪，既然Java 1.1通过反对构造器而反对了整个"),n("code",[e._v("PrintStream")]),e._v("，为什么库的设计人员在添加这个反对的同时，依然为"),n("code",[e._v("System")]),e._v("添加了新方法，且指明要求用"),n("code",[e._v("PrintStream")]),e._v("，而不是用"),n("code",[e._v("PrintWriter")]),e._v("呢？毕竟，后者是一个崭新和首选的替换措施呀？这真令人费解。")])])}),[],!1,null,null,null);t.default=r.exports}}]);