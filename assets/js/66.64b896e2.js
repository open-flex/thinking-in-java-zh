(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{464:function(e,t,n){"use strict";n.r(t);var l=n(56),a=Object(l.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_13-7-标签"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_13-7-标签"}},[e._v("#")]),e._v(" 13.7 标签")]),e._v(" "),n("p",[e._v("标签准确地运作：安放一个标签到窗体上。这对没有标签的"),n("code",[e._v("TextFields")]),e._v("和"),n("code",[e._v("Text areas")]),e._v(" 来说非常的重要，如果我们简单地想安放文字的信息在窗体上也能同样的使用。我们能像本章中第一个例程中演示的那样，使用"),n("code",[e._v("drawString()")]),e._v("里边的"),n("code",[e._v("paint()")]),e._v("在确定的位置去安置一个文字。当我们使用的标签允许我们通过布局管理加入其它的文字组件。（在这章的后面我们将进入讨论。）")]),e._v(" "),n("p",[e._v("使用构造器我们能创建一条包括初始化文字的标签（这是我们典型的作法），一个标签包括一行"),n("code",[e._v("CENTER")]),e._v("（中间）、"),n("code",[e._v("LEFT")]),e._v("（左）和"),n("code",[e._v("RIGHT")]),e._v("(右）（静态的结果取整定义在类标签里）。如果我们忘记了可以用"),n("code",[e._v("getText()")]),e._v("和"),n("code",[e._v("getalignment()")]),e._v("读取值，我们同样可以用"),n("code",[e._v("setText()")]),e._v("和"),n("code",[e._v("setAlignment()")]),e._v("来改变和调整。下面的例子将演示标签的特点：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: Label1.java\n// Using labels\nimport java.awt.*;\nimport java.applet.*;\n\npublic class Label1 extends Applet {\n  TextField t1 = new TextField("t1", 10);\n  Label labl1 = new Label("TextField t1");\n  Label labl2 = new Label("                   ");\n  Label labl3 = new Label("                    ",\n    Label.RIGHT);\n  Button b1 = new Button("Test 1");\n  Button b2 = new Button("Test 2");\n  public void init() {\n    add(labl1); add(t1);\n    add(b1); add(labl2);\n    add(b2); add(labl3);\n  }\n  public boolean action (Event evt, Object arg) {\n    if(evt.target.equals(b1))\n      labl2.setText("Text set into Label");\n    else if(evt.target.equals(b2)) {\n      if(labl3.getText().trim().length() == 0)\n        labl3.setText("labl3");\n      if(labl3.getAlignment() == Label.LEFT)\n        labl3.setAlignment(Label.CENTER);\n      else if(labl3.getAlignment()==Label.CENTER)\n        labl3.setAlignment(Label.RIGHT);\n      else if(labl3.getAlignment() == Label.RIGHT)\n        labl3.setAlignment(Label.LEFT);\n    }\n    else\n      return super.action(evt, arg);\n    return true;\n  }\n} ///:~\n')])])]),n("p",[e._v("首先是标签的最典型的用途：标记一个文本字段或文本区域。在例程的第二部分，当我们按下"),n("code",[e._v("test 1")]),e._v("按钮通过"),n("code",[e._v("setText()")]),e._v("将一串空的空格插入到的字段里。因为空的空格数不等于同样的字符数（在一个等比例间隔的字库里），当插入文字到标签里时我们会看到文字将被省略掉。在例子的第三部分保留的空的空格在我们第一次按下"),n("code",[e._v("test 2")]),e._v("会发现标签是空的（"),n("code",[e._v("trim()")]),e._v("删除了每个字符串结尾部分的空格）并且在开头的左列插入了一个短的标签。在工作的其余时间中我们按下按钮进行调整，因此就能看到效果。")]),e._v(" "),n("p",[e._v("我们可能会认为我们可以创建一个空的标签，然后用"),n("code",[e._v("setText()")]),e._v("安放文字在里面。然而我们不能在一个空标签内加入文字－这大概是因为空标签没有宽度－所以创建一个没有文字的空标签是没有用处的。在上面的例子里，"),n("code",[e._v("blank")]),e._v("标签里充满空的空格，所以它足够容纳后面加入的文字。")]),e._v(" "),n("p",[e._v("同样的，"),n("code",[e._v("setAlignment()")]),e._v("在我们用构造器创建的典型的文字标签上没有作用。这个标签的宽度就是文字的宽度，所以不能对它进行任何的调整。但是，如果我们启动一个长标签，然后把它变成短的，我们就可以看到调整的效果。")]),e._v(" "),n("p",[e._v("这些导致事件连同它们最小化的尺寸被挤压的状况被程序片使用的默认布局管理器所发现。有关布局管理器的部分包含在本章的后面。")])])}),[],!1,null,null,null);t.default=a.exports}}]);