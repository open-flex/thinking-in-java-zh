(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{500:function(e,n,t){"use strict";t.r(n);var a=t(56),i=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_17-3-复杂性理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-3-复杂性理论"}},[e._v("#")]),e._v(" 17.3 复杂性理论")]),e._v(" "),t("p",[e._v("下面要介绍的程序的前身是由Larry O'Brien原创的一些代码，并以由Craig Reynolds于1986年编制的“Boids”程序为基础，当时是为了演示复杂性理论的一个特殊问题，名为“凸显”（Emergence）。")]),e._v(" "),t("p",[e._v("这儿要达到的目标是通过为每种动物都规定少许简单的规则，从而逼真地再现动物的群聚行为。每个动物都能看到看到整个环境以及环境中的其他动物，但它只与一系列附近的“群聚伙伴”打交道。动物的移动基于三个简单的引导行为：")]),e._v(" "),t("p",[e._v("(1) 分隔：避免本地群聚伙伴过于拥挤。")]),e._v(" "),t("p",[e._v("(2) 方向：遵从本地群聚伙伴的普遍方向。")]),e._v(" "),t("p",[e._v("(3) 聚合：朝本地群聚伙伴组的中心移动。")]),e._v(" "),t("p",[e._v("更复杂的模型甚至可以包括障碍物的因素，动物能预知和避免与障碍冲突的能力，所以它们能围绕环境中的固定物体自由活动。除此以外，动物也可能有自己的特殊目标，这也许会造成群体按特定的路径前进。为简化讨论，避免障碍以及目标搜寻的因素并未包括到这里建立的模型中。")]),e._v(" "),t("p",[e._v("尽管计算机本身比较简陋，而且采用的规则也相当简单，但结果看起来是真实的。也就是说，相当逼真的行为从这个简单的模型中“凸显”出来了。")]),e._v(" "),t("p",[e._v("程序以组合到一起的应用程序／程序片的形式提供：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: FieldOBeasts.java\n// Demonstration of complexity theory; simulates\n// herding behavior in animals. Adapted from\n// a program by Larry O\'Brien lobrien@msn.com\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.applet.*;\nimport java.util.*;\n\nclass Beast {\n  int\n    x, y,            // Screen position\n    currentSpeed;    // Pixels per second\n  float currentDirection;  // Radians\n  Color color;      // Fill color\n  FieldOBeasts field; // Where the Beast roams\n  static final int GSIZE = 10; // Graphic size\n\n  public Beast(FieldOBeasts f, int x, int y,\n      float cD, int cS, Color c) {\n    field = f;\n    this.x = x;\n    this.y = y;\n    currentDirection = cD;\n    currentSpeed = cS;\n    color = c;\n  }\n  public void step() {\n    // You move based on those within your sight:\n    Vector seen = field.beastListInSector(this);\n    // If you\'re not out in front\n    if(seen.size() > 0) {\n      // Gather data on those you see\n      int totalSpeed = 0;\n      float totalBearing = 0.0f;\n      float distanceToNearest = 100000.0f;\n      Beast nearestBeast =\n        (Beast)seen.elementAt(0);\n      Enumeration e = seen.elements();\n      while(e.hasMoreElements()) {\n        Beast aBeast = (Beast) e.nextElement();\n        totalSpeed += aBeast.currentSpeed;\n        float bearing =\n          aBeast.bearingFromPointAlongAxis(\n            x, y, currentDirection);\n        totalBearing += bearing;\n        float distanceToBeast =\n          aBeast.distanceFromPoint(x, y);\n        if(distanceToBeast < distanceToNearest) {\n          nearestBeast = aBeast;\n          distanceToNearest = distanceToBeast;\n        }\n      }\n      // Rule 1: Match average speed of those\n      // in the list:\n      currentSpeed = totalSpeed / seen.size();\n      // Rule 2: Move towards the perceived\n      // center of gravity of the herd:\n      currentDirection =\n        totalBearing / seen.size();\n      // Rule 3: Maintain a minimum distance\n      // from those around you:\n      if(distanceToNearest <=\n         field.minimumDistance) {\n        currentDirection =\n          nearestBeast.currentDirection;\n        currentSpeed = nearestBeast.currentSpeed;\n        if(currentSpeed > field.maxSpeed) {\n          currentSpeed = field.maxSpeed;\n        }\n      }\n    }\n    else {  // You are in front, so slow down\n      currentSpeed =\n        (int)(currentSpeed * field.decayRate);\n    }\n    // Make the beast move:\n    x += (int)(Math.cos(currentDirection)\n               * currentSpeed);\n    y += (int)(Math.sin(currentDirection)\n               * currentSpeed);\n    x %= field.xExtent;\n    y %= field.yExtent;\n    if(x < 0)\n      x += field.xExtent;\n    if(y < 0)\n      y += field.yExtent;\n  }\n  public float bearingFromPointAlongAxis (\n      int originX, int originY, float axis) {\n    // Returns bearing angle of the current Beast\n    // in the world coordiante system\n    try {\n      double bearingInRadians =\n        Math.atan(\n          (this.y - originY) /\n          (this.x - originX));\n      // Inverse tan has two solutions, so you\n      // have to correct for other quarters:\n      if(x < originX) {  \n        if(y < originY) {\n          bearingInRadians += - (float)Math.PI;\n        }\n        else {\n          bearingInRadians =\n            (float)Math.PI - bearingInRadians;\n        }\n      }\n      // Just subtract the axis (in radians):\n      return (float) (axis - bearingInRadians);\n    } catch(ArithmeticException aE) {\n      // Divide by 0 error possible on this\n      if(x > originX) {\n          return 0;\n      }\n      else\n        return (float) Math.PI;\n    }\n  }\n  public float distanceFromPoint(int x1, int y1){\n    return (float) Math.sqrt(\n      Math.pow(x1 - x, 2) +\n      Math.pow(y1 - y, 2));\n  }\n  public Point position() {\n    return new Point(x, y);\n  }\n  // Beasts know how to draw themselves:\n  public void draw(Graphics g) {\n    g.setColor(color);\n    int directionInDegrees = (int)(\n      (currentDirection * 360) / (2 * Math.PI));\n    int startAngle = directionInDegrees -\n      FieldOBeasts.halfFieldOfView;\n    int endAngle = 90;\n    g.fillArc(x, y, GSIZE, GSIZE,\n      startAngle, endAngle);\n  }\n}\n\npublic class FieldOBeasts extends Applet\n    implements Runnable {\n  private Vector beasts;\n  static float\n    fieldOfView =\n      (float) (Math.PI / 4), // In radians\n    // Deceleration % per second:\n    decayRate = 1.0f,\n    minimumDistance = 10f; // In pixels\n  static int\n    halfFieldOfView = (int)(\n      (fieldOfView * 360) / (2 * Math.PI)),\n    xExtent = 0,\n    yExtent = 0,\n    numBeasts = 50,\n    maxSpeed = 20; // Pixels/second\n  boolean uniqueColors = true;\n  Thread thisThread;\n  int delay = 25;\n  public void init() {\n    if (xExtent == 0 && yExtent == 0) {\n      xExtent = Integer.parseInt(\n        getParameter("xExtent"));\n      yExtent = Integer.parseInt(\n        getParameter("yExtent"));\n    }\n    beasts =\n      makeBeastVector(numBeasts, uniqueColors);\n    // Now start the beasts a-rovin\':\n    thisThread = new Thread(this);\n    thisThread.start();\n  }\n  public void run() {\n    while(true) {\n      for(int i = 0; i < beasts.size(); i++){\n        Beast b = (Beast) beasts.elementAt(i);\n        b.step();\n      }\n      try {\n        thisThread.sleep(delay);\n      } catch(InterruptedException ex){}\n      repaint(); // Otherwise it won\'t update\n    }\n  }\n  Vector makeBeastVector(\n      int quantity, boolean uniqueColors) {\n    Vector newBeasts = new Vector();\n    Random generator = new Random();\n    // Used only if uniqueColors is on:\n    double cubeRootOfBeastNumber =\n      Math.pow((double)numBeasts, 1.0 / 3.0);\n    float colorCubeStepSize =\n      (float) (1.0 / cubeRootOfBeastNumber);\n    float r = 0.0f;\n    float g = 0.0f;\n    float b = 0.0f;\n    for(int i = 0; i < quantity; i++) {\n      int x =\n        (int) (generator.nextFloat() * xExtent);\n      if(x > xExtent - Beast.GSIZE)\n        x -= Beast.GSIZE;\n      int y =\n        (int) (generator.nextFloat() * yExtent);\n      if(y > yExtent - Beast.GSIZE)\n        y -= Beast.GSIZE;\n      float direction = (float)(\n        generator.nextFloat() * 2 * Math.PI);\n      int speed = (int)(\n        generator.nextFloat() * (float)maxSpeed);\n      if(uniqueColors) {\n        r += colorCubeStepSize;\n        if(r > 1.0) {\n          r -= 1.0f;\n          g += colorCubeStepSize;\n          if( g > 1.0) {\n            g -= 1.0f;\n            b += colorCubeStepSize;\n            if(b > 1.0)\n              b -= 1.0f;\n          }\n        }\n      }\n      newBeasts.addElement(\n        new Beast(this, x, y, direction, speed,\n          new Color(r,g,b)));\n    }\n    return newBeasts;\n  }\n  public Vector beastListInSector(Beast viewer) {\n    Vector output = new Vector();\n    Enumeration e = beasts.elements();\n    Beast aBeast = (Beast)beasts.elementAt(0);\n    int counter = 0;\n    while(e.hasMoreElements()) {\n      aBeast = (Beast) e.nextElement();\n      if(aBeast != viewer) {\n        Point p = aBeast.position();\n        Point v = viewer.position();\n        float bearing =\n          aBeast.bearingFromPointAlongAxis(\n            v.x, v.y, viewer.currentDirection);\n        if(Math.abs(bearing) < fieldOfView / 2)\n         output.addElement(aBeast);\n      }\n    }\n    return output;\n  }\n  public void paint(Graphics g)  {\n    Enumeration e = beasts.elements();\n    while(e.hasMoreElements()) {\n      ((Beast)e.nextElement()).draw(g);\n    }\n  }\n  public static void main(String[] args)   {\n    FieldOBeasts field = new FieldOBeasts();\n    field.xExtent = 640;\n    field.yExtent = 480;\n    Frame frame = new Frame("Field \'O Beasts");\n    // Optionally use a command-line argument\n    // for the sleep time:\n    if(args.length >= 1)\n      field.delay = Integer.parseInt(args[0]);\n    frame.addWindowListener(\n      new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n          System.exit(0);\n        }\n      });\n    frame.add(field, BorderLayout.CENTER);\n    frame.setSize(640,480);\n    field.init();\n    field.start();\n    frame.setVisible(true);\n  }\n} ///:~\n')])])]),t("p",[e._v("尽管这并非对Craig Reynold的“Boids”例子中的行为完美重现，但它却展现出了自己独有的迷人之外。通过对数字进行调整，即可进行全面的修改。至于与这种群聚行为有关的更多的情况，大家可以访问Craig Reynold的主页——在那个地方，甚至还提供了Boids一个公开的3D展示版本：")]),e._v(" "),t("p",[e._v("http://www.hmt.com/cwr/boids.html")]),e._v(" "),t("p",[e._v("为了将这个程序作为一个程序片运行，请在HTML文件中设置下述程序片标志：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<applet\ncode=FieldOBeasts\nwidth=640\nheight=480>\n<param name=xExtent value = "640">\n<param name=yExtent value = "480">\n</applet>\n')])])])])}),[],!1,null,null,null);n.default=i.exports}}]);