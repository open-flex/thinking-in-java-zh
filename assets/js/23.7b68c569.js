(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{421:function(t,e,n){"use strict";n.r(e);var r=n(56),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_10-1-输入和输出"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-输入和输出"}},[t._v("#")]),t._v(" 10.1 输入和输出")]),t._v(" "),n("p",[t._v("可将Java库的IO类分割为输入与输出两个部分，这一点在用Web浏览器阅读联机Java类文档时便可知道。通过继承，从"),n("code",[t._v("InputStream")]),t._v("（输入流）派生的所有类都拥有名为"),n("code",[t._v("read()")]),t._v("的基本方法，用于读取单个字节或者字节数组。类似地，从"),n("code",[t._v("OutputStream")]),t._v("派生的所有类都拥有基本方法"),n("code",[t._v("write()")]),t._v("，用于写入单个字节或者字节数组。然而，我们通常不会用到这些方法；它们之所以存在，是因为更复杂的类可以利用它们，以便提供一个更有用的接口。因此，我们很少用单个类创建自己的系统对象。一般情况下，我们都是将多个对象重叠在一起，提供自己期望的功能。我们之所以感到Java的流库（Stream Library）异常复杂，正是由于为了创建单独一个结果流，却需要创建多个对象的缘故。")]),t._v(" "),n("p",[t._v("很有必要按照功能对类进行分类。库的设计者首先决定与输入有关的所有类都从"),n("code",[t._v("InputStream")]),t._v("继承，而与输出有关的所有类都从"),n("code",[t._v("OutputStream")]),t._v("继承。")]),t._v(" "),n("h2",{attrs:{id:"_10-1-1-inputstream的类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-1-inputstream的类型"}},[t._v("#")]),t._v(" 10.1.1 "),n("code",[t._v("InputStream")]),t._v("的类型")]),t._v(" "),n("p",[n("code",[t._v("InputStream")]),t._v("的作用是标志那些从不同起源地产生输入的类。这些起源地包括（每个都有一个相关的"),n("code",[t._v("InputStream")]),t._v("子类）：")]),t._v(" "),n("p",[t._v("(1) 字节数组")]),t._v(" "),n("p",[t._v("(2) "),n("code",[t._v("String")]),t._v("对象")]),t._v(" "),n("p",[t._v("(3) 文件")]),t._v(" "),n("p",[t._v("(4) “管道”，它的工作原理与现实生活中的管道类似：将一些东西置入一端，它们在另一端出来。 (5) 一系列其他流，以便我们将其统一收集到单独一个流内。")]),t._v(" "),n("p",[t._v("(6) 其他起源地，如Internet连接等（将在本书后面的部分讲述）。")]),t._v(" "),n("p",[t._v("除此以外，"),n("code",[t._v("FilterInputStream")]),t._v("也属于"),n("code",[t._v("InputStream")]),t._v("的一种类型，用它可为“析构器”类提供一个基类，以便将属性或者有用的接口同输入流连接到一起。这将在以后讨论。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Class\n\nFunction\n\nConstructor Arguments\n\nHow to use it\n\nByteArray-InputStream\n\nAllows a buffer in memory to be used as an InputStream.\n\nThe buffer from which to extract the bytes.\n\nAs a source of data. Connect it to a FilterInputStream object to provide a useful interface.\n\nStringBuffer-InputStream\n\nConverts a String into an InputStream.\n\nA String. The underlying implementation actually uses a StringBuffer.\n\nAs a source of data. Connect it to a FilterInputStream object to provide a useful interface.\n\nFile-InputStream\n\nFor reading information from a file.\n\nA String representing the file name, or a File or FileDescriptor object.\n\nAs a source of data. Connect it to a FilterInputStream object to provide a useful interface.\n")])])]),n("table",[n("thead",[n("tr",[n("th",[t._v("类")]),t._v(" "),n("th",[t._v("功能")]),t._v(" "),n("th",[t._v("构造器参数／如何使用")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[n("code",[t._v("ByteArrayInputStream |")]),t._v(" 允许内存中的一个缓冲区作为"),n("code",[t._v("InputStream")]),t._v("使用")]),t._v(" "),n("td",[t._v("从中提取字节的缓冲区／作为一个数据源使用。通过将其同一个"),n("code",[t._v("FilterInputStream")]),t._v("对象连接，可提供一个有用的接口")]),t._v(" "),n("td")]),t._v(" "),n("tr",[n("td",[n("code",[t._v("StringBufferInputStream")])]),t._v(" "),n("td",[t._v("将一个"),n("code",[t._v("String")]),t._v("转换成"),n("code",[t._v("InputStream")])]),t._v(" "),n("td",[t._v("一个"),n("code",[t._v("String")]),t._v("（字符串）。基础的实现方案实际采用一个")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("StringBuffer")]),t._v("（字符串缓冲）／作为一个数据源使用。")]),t._v(" "),n("td",[t._v("通过将其同一个FilterInputStream对象连接，可提供一个有用的接口")]),t._v(" "),n("td")]),t._v(" "),n("tr",[n("td",[n("code",[t._v("FileInputStream")])]),t._v(" "),n("td",[t._v("用于从文件读取信息")]),t._v(" "),n("td",[t._v("代表文件名的一个"),n("code",[t._v("String")]),t._v("，或者一个"),n("code",[t._v("File")]),t._v("或"),n("code",[t._v("FileDescriptor")]),t._v("对象／作为一个数据源使用。通过将其同一个"),n("code",[t._v("FilterInputStream")]),t._v("对象连接，可提供一个有用的接口")])])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Piped-InputStream\n\nProduces the data that’s being written to the associated PipedOutput-Stream. Implements the “piping” concept.\n\nPipedOutputStream\n\nAs a source of data in multithreading. Connect it to a FilterInputStream object to provide a useful interface.\n\nSequence-InputStream\n\nCoverts two or more InputStream objects into a single InputStream.\n\nTwo InputStream objects or an Enumeration for a container of InputStream objects.\n\nAs a source of data. Connect it to a FilterInputStream object to provide a useful interface.\n\nFilter-InputStream\n\nAbstract class which is an interface for decorators that provide useful functionality to the other InputStream classes. See Table 10-3.\n\nSee Table 10-3.\n\nSee Table 10-3.\n")])])]),n("table",[n("thead",[n("tr",[n("th",[t._v("类")]),t._v(" "),n("th",[t._v("功能")]),t._v(" "),n("th",[t._v("构造器参数／如何使用")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[n("code",[t._v("PipedInputString")])]),t._v(" "),n("td",[t._v("产生为相关的"),n("code",[t._v("PipedOutputStream")]),t._v("写的数据。实现了“管道化”的概念")]),t._v(" "),n("td",[n("code",[t._v("PipedOutputStream")]),t._v("／作为一个数据源使用。通过将其同一个"),n("code",[t._v("FilterInputStream")]),t._v("对象连接，可提供一个有用的接口")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("SequenceInputStream")])]),t._v(" "),n("td",[t._v("将两个或更多的"),n("code",[t._v("InputStream")]),t._v("对象转换成单个"),n("code",[t._v("InputStream")]),t._v("使用")]),t._v(" "),n("td",[t._v("两个"),n("code",[t._v("InputStream")]),t._v("对象或者一个"),n("code",[t._v("Enumeration")]),t._v("，用于"),n("code",[t._v("InputStream")]),t._v("对象的一个容器／作为一个数据源使用。通过将其同一个"),n("code",[t._v("FilterInputStream")]),t._v("对象连接，可提供一个有用的接口")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("FilterInputStream")])]),t._v(" "),n("td",[t._v("对作为析构器接口使用的类进行抽象；那个析构器为其他"),n("code",[t._v("InputStream")]),t._v("类提供了有用的功能。参见表10.3")]),t._v(" "),n("td",[t._v("参见表10.3／参见表10.3")])])])]),t._v(" "),n("h2",{attrs:{id:"_10-1-2-outputstream的类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-2-outputstream的类型"}},[t._v("#")]),t._v(" 10.1.2 "),n("code",[t._v("OutputStream")]),t._v("的类型")]),t._v(" "),n("p",[t._v("这一类别包括的类决定了我们的输入往何处去：一个字节数组（但没有"),n("code",[t._v("String")]),t._v("；假定我们可用字节数组创建一个）；一个文件；或者一个“管道”。")]),t._v(" "),n("p",[t._v("除此以外，"),n("code",[t._v("FilterOutputStream")]),t._v("为“析构器”类提供了一个基类，它将属性或者有用的接口同输出流连接起来。这将在以后讨论。")]),t._v(" "),n("p",[t._v("表10.2 "),n("code",[t._v("OutputStream")]),t._v("的类型")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Class\n\nFunction\n\nConstructor Arguments\n\nHow to use it\n\nByteArray-OutputStream\n\nCreates a buffer in memory. All the data that you send to the stream is placed in this buffer.\n\nOptional initial size of the buffer.\n\nTo designate the destination of your data. Connect it to a FilterOutputStream object to provide a useful interface.\n\nFile-OutputStream\n\nFor sending information to a file.\n\nA String representing the file name, or a File or FileDescriptor object.\n\nTo designate the destination of your data. Connect it to a FilterOutputStream object to provide a useful interface.\n\nPiped-OutputStream\n\nAny information you write to this automatically ends up as input for the associated PipedInput-Stream. Implements the “piping” concept.\n\nPipedInputStream\n\nTo designate the destination of your data for multithreading. Connect it to a FilterOutputStream object to provide a useful interface.\n\nFilter-OutputStream\n\nAbstract class which is an interface for decorators that provide useful functionality to the other OutputStream classes. See Table\n10-4.\n\nSee Table 10-4.\n\nSee Table 10-4.\n")])])]),n("table",[n("thead",[n("tr",[n("th",[t._v("类")]),t._v(" "),n("th",[t._v("功能")]),t._v(" "),n("th",[t._v("构造器参数 / 如何使用")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[n("code",[t._v("ByteArrayOutputStream")])]),t._v(" "),n("td",[t._v("在内存中创建一个缓冲区。我们发送给流的所有数据都会置入这个缓冲区。")]),t._v(" "),n("td",[t._v("可选缓冲区的初始大小 / 用于指出数据的目的地。若将其同"),n("code",[t._v("FilterOutputStream")]),t._v("对象连接到一起，可提供一个有用的接口")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("FileOutputStream")])]),t._v(" "),n("td",[t._v("将信息发给一个文件")]),t._v(" "),n("td",[t._v("用一个String代表文件名，或选用一个"),n("code",[t._v("File")]),t._v("或"),n("code",[t._v("FileDescriptor")]),t._v("对象 / 用于指出数据的目的地。若将其同"),n("code",[t._v("FilterOutputStream")]),t._v("对象连接到一起，可提供一个有用的接口")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("PipedOutputStream")])]),t._v(" "),n("td",[t._v("我们写给它的任何信息都会自动成为相关的"),n("code",[t._v("PipedInputStream")]),t._v("的输出。实现了“管道化”的概念")]),t._v(" "),n("td",[n("code",[t._v("PipedInputStream")]),t._v("／为多线程处理指出自己数据的目的地 / 将其同"),n("code",[t._v("FilterOutputStream")]),t._v("对象连接到一起，便可提供一个有用的接口")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("FilterOutputStream")])]),t._v(" "),n("td",[t._v("对作为析构器接口使用的类进行抽象处理；那个析构器为其他"),n("code",[t._v("OutputStream")]),t._v("类提供了有用的功能。参见表10.4")]),t._v(" "),n("td",[t._v("参见表10.4")])])])])])}),[],!1,null,null,null);e.default=a.exports}}]);