(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{472:function(e,o,n){"use strict";n.r(o);var r=n(56),t=Object(r.a)({},(function(){var e=this,o=e.$createElement,n=e._self._c||o;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_14-5-回顾runnable"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_14-5-回顾runnable"}},[e._v("#")]),e._v(" 14.5 回顾runnable")]),e._v(" "),n("p",[e._v("在本章早些时候，我曾建议大家在将一个程序片或主"),n("code",[e._v("Frame")]),e._v("当作"),n("code",[e._v("Runnable")]),e._v("的实现形式之前，一定要好好地想一想。若采用那种方式，就只能在自己的程序中使用其中的一个线程。这便限制了灵活性，一旦需要用到属于那种类型的多个线程，就会遇到不必要的麻烦。")]),e._v(" "),n("p",[e._v("当然，如果必须从一个类继承，而且想使类具有线程处理能力，则"),n("code",[e._v("Runnable")]),e._v("是一种正确的方案。本章最后一个例子对这一点进行了剖析，制作了一个"),n("code",[e._v("RunnableCanvas")]),e._v("类，用于为自己描绘不同的颜色（"),n("code",[e._v("Canvas")]),e._v("是“画布”的意思）。这个应用被设计成从命令行获得参数值，以决定颜色网格有多大，以及颜色发生变化之间的"),n("code",[e._v("sleep()")]),e._v("有多长。通过运用这些值，大家能体验到线程一些有趣而且可能令人费解的特性：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: ColorBoxes.java\n// Using the Runnable interface\nimport java.awt.*;\nimport java.awt.event.*;\n\nclass CBox extends Canvas implements Runnable {\n  private Thread t;\n  private int pause;\n  private static final Color[] colors = {\n    Color.black, Color.blue, Color.cyan,\n    Color.darkGray, Color.gray, Color.green,\n    Color.lightGray, Color.magenta,\n    Color.orange, Color.pink, Color.red,\n    Color.white, Color.yellow\n  };\n  private Color cColor = newColor();\n  private static final Color newColor() {\n    return colors[\n      (int)(Math.random() * colors.length)\n    ];\n  }\n  public void paint(Graphics  g) {\n    g.setColor(cColor);\n    Dimension s = getSize();\n    g.fillRect(0, 0, s.width, s.height);\n  }\n  public CBox(int pause) {\n    this.pause = pause;\n    t = new Thread(this);\n    t.start();\n  }\n  public void run() {\n    while(true) {\n      cColor = newColor();\n      repaint();\n      try {\n        t.sleep(pause);\n      } catch(InterruptedException e) {}\n    }\n  }\n}\n\npublic class ColorBoxes extends Frame {\n  public ColorBoxes(int pause, int grid) {\n    setTitle("ColorBoxes");\n    setLayout(new GridLayout(grid, grid));\n    for (int i = 0; i < grid * grid; i++)\n      add(new CBox(pause));\n    addWindowListener(new WindowAdapter() {\n      public void windowClosing(WindowEvent e) {\n        System.exit(0);\n      }\n    });\n  }   \n  public static void main(String[] args) {\n    int pause = 50;\n    int grid = 8;\n    if(args.length > 0)\n      pause = Integer.parseInt(args[0]);\n    if(args.length > 1)\n      grid = Integer.parseInt(args[1]);\n    Frame f = new ColorBoxes(pause, grid);\n    f.setSize(500, 400);\n    f.setVisible(true);  \n  }\n} ///:~\n')])])]),n("p",[n("code",[e._v("ColorBoxes")]),e._v("是一个典型的应用（程序），有一个构造器用于设置GUI。这个构造器采用"),n("code",[e._v("int grid")]),e._v("的一个参数，用它设置"),n("code",[e._v("GridLayout")]),e._v("（网格布局），使每一维里都有一个"),n("code",[e._v("grid")]),e._v("单元。随后，它添加适当数量的"),n("code",[e._v("CBox")]),e._v("对象，用它们填充网格，并为每一个都传递"),n("code",[e._v("pause")]),e._v("值。在"),n("code",[e._v("main()")]),e._v("中，我们可看到如何对"),n("code",[e._v("pause")]),e._v("和"),n("code",[e._v("grid")]),e._v("的默认值进行修改（如果用命令行参数传递）。")]),e._v(" "),n("p",[n("code",[e._v("CBox")]),e._v("是进行正式工作的地方。它是从"),n("code",[e._v("Canvas")]),e._v("继承的，并实现了"),n("code",[e._v("Runnable")]),e._v("接口，使每个"),n("code",[e._v("Canvas")]),e._v("也能是一个"),n("code",[e._v("Thread")]),e._v("。记住在实现"),n("code",[e._v("Runnable")]),e._v("的时候，并没有实际产生一个"),n("code",[e._v("Thread")]),e._v("对象，只是一个拥有"),n("code",[e._v("run()")]),e._v("方法的类。因此，我们必须明确地创建一个"),n("code",[e._v("Thread")]),e._v("对象，并将"),n("code",[e._v("Runnable")]),e._v("对象传递给构造器，随后调用"),n("code",[e._v("start()")]),e._v("（在构造器里进行）。在"),n("code",[e._v("CBox")]),e._v("里，这个线程的名字叫作"),n("code",[e._v("t")]),e._v("。")]),e._v(" "),n("p",[e._v("请留意数组"),n("code",[e._v("colors")]),e._v("，它对"),n("code",[e._v("Color")]),e._v("类中的所有颜色进行了列举（枚举）。它在"),n("code",[e._v("newColor()")]),e._v("中用于产生一种随机选择的颜色。当前的单元（格）颜色是"),n("code",[e._v("cColor")]),e._v("。")]),e._v(" "),n("p",[n("code",[e._v("paint()")]),e._v("则相当简单——只是将颜色设为"),n("code",[e._v("cColor")]),e._v("，然后用那种颜色填充整张画布（"),n("code",[e._v("Canvas")]),e._v("）。")]),e._v(" "),n("p",[e._v("在"),n("code",[e._v("run()")]),e._v("中，我们看到一个无限循环，它将"),n("code",[e._v("cColor")]),e._v("设为一种随机颜色，然后调用"),n("code",[e._v("repaint()")]),e._v("把它显示出来。随后，对线程执行"),n("code",[e._v("sleep()")]),e._v("，使其“休眠”由命令行指定的时间长度。")]),e._v(" "),n("p",[e._v("由于这种设计模式非常灵活，而且线程处理同每个"),n("code",[e._v("Canvas")]),e._v("元素都紧密结合在一起，所以在理论上可以生成任意多的线程（但在实际应用中，这要受到JVM能够从容对付的线程数量的限制）。")]),e._v(" "),n("p",[e._v("这个程序也为我们提供了一个有趣的评测基准，因为它揭示了不同JVM机制在速度上造成的戏剧性的差异。")]),e._v(" "),n("h2",{attrs:{id:"_14-5-1-过多的线程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_14-5-1-过多的线程"}},[e._v("#")]),e._v(" 14.5.1 过多的线程")]),e._v(" "),n("p",[e._v("有些时候，我们会发现"),n("code",[e._v("ColorBoxes")]),e._v("几乎陷于停顿状态。在我自己的机器上，这一情况在产生了"),n("code",[e._v("10×10")]),e._v("的网格之后发生了。为什么会这样呢？自然地，我们有理由怀疑AWT对它做了什么事情。所以这里有一个例子能够测试那个猜测，它产生了较少的线程。代码经过了重新组织，使一个"),n("code",[e._v("Vector")]),e._v("实现了"),n("code",[e._v("Runnable")]),e._v("，而且那个"),n("code",[e._v("Vector")]),e._v("容纳了数量众多的色块，并随机挑选一些进行更新。随后，我们创建大量这些"),n("code",[e._v("Vector")]),e._v("对象，数量大致取决于我们挑选的网格维数。结果便是我们得到比色块少得多的线程。所以假如有一个速度的加快，我们就能立即知道，因为前例的线程数量太多了。如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: ColorBoxes2.java\n// Balancing thread use\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\n\nclass CBox2 extends Canvas {\n  private static final Color[] colors = {\n    Color.black, Color.blue, Color.cyan,\n    Color.darkGray, Color.gray, Color.green,\n    Color.lightGray, Color.magenta,\n    Color.orange, Color.pink, Color.red,\n    Color.white, Color.yellow\n  };\n  private Color cColor = newColor();\n  private static final Color newColor() {\n    return colors[\n      (int)(Math.random() * colors.length)\n    ];\n  }\n  void nextColor() {\n    cColor = newColor();\n    repaint();\n  }\n  public void paint(Graphics  g) {\n    g.setColor(cColor);\n    Dimension s = getSize();\n    g.fillRect(0, 0, s.width, s.height);\n  }\n}\n\nclass CBoxVector\n  extends Vector implements Runnable {\n  private Thread t;\n  private int pause;\n  public CBoxVector(int pause) {\n    this.pause = pause;\n    t = new Thread(this);\n  }\n  public void go() { t.start(); }\n  public void run() {\n    while(true) {\n      int i = (int)(Math.random() * size());\n      ((CBox2)elementAt(i)).nextColor();\n      try {\n        t.sleep(pause);\n      } catch(InterruptedException e) {}\n    }\n  }\n}\n\npublic class ColorBoxes2 extends Frame {\n  private CBoxVector[] v;\n  public ColorBoxes2(int pause, int grid) {\n    setTitle("ColorBoxes2");\n    setLayout(new GridLayout(grid, grid));\n    v = new CBoxVector[grid];\n    for(int i = 0; i < grid; i++)\n      v[i] = new CBoxVector(pause);\n    for (int i = 0; i < grid * grid; i++) {\n      v[i % grid].addElement(new CBox2());\n      add((CBox2)v[i % grid].lastElement());\n    }\n    for(int i = 0; i < grid; i++)\n      v[i].go();\n    addWindowListener(new WindowAdapter() {\n      public void windowClosing(WindowEvent e) {\n        System.exit(0);\n      }\n    });\n  }   \n  public static void main(String[] args) {\n    // Shorter default pause than ColorBoxes:\n    int pause = 5;\n    int grid = 8;\n    if(args.length > 0)\n      pause = Integer.parseInt(args[0]);\n    if(args.length > 1)\n      grid = Integer.parseInt(args[1]);\n    Frame f = new ColorBoxes2(pause, grid);\n    f.setSize(500, 400);\n    f.setVisible(true);  \n  }\n} ///:~\n')])])]),n("p",[e._v("在"),n("code",[e._v("ColorBoxes2")]),e._v("中，我们创建了"),n("code",[e._v("CBoxVector")]),e._v("的一个数组，并对其初始化，使其容下各个"),n("code",[e._v("CBoxVector")]),e._v("网格。每个网格都知道自己该“睡眠”多长的时间。随后为每个"),n("code",[e._v("CBoxVector")]),e._v("都添加等量的"),n("code",[e._v("Cbox2")]),e._v("对象，而且将每个"),n("code",[e._v("Vector")]),e._v("都告诉给"),n("code",[e._v("go()")]),e._v("，用它来启动自己的线程。")]),e._v(" "),n("p",[n("code",[e._v("CBox2")]),e._v("类似"),n("code",[e._v("CBox")]),e._v("——能用一种随机选择的颜色描绘自己。但那就是"),n("code",[e._v("CBox2")]),e._v("能够做的全部工作。所有涉及线程的处理都已移至"),n("code",[e._v("CBoxVector")]),e._v("进行。")]),e._v(" "),n("p",[n("code",[e._v("CBoxVector")]),e._v("也可以拥有继承的"),n("code",[e._v("Thread")]),e._v("，并有一个类型为"),n("code",[e._v("Vector")]),e._v("的成员对象。这样设计的好处就是"),n("code",[e._v("addElement()")]),e._v("和"),n("code",[e._v("elementAt()")]),e._v("方法可以获得特定的参数以及返回值类型，而不是只能获得常规Object（它们的名字也可以变得更短）。然而，这里采用的设计表面上看需要较少的代码。除此以外，它会自动保留一个"),n("code",[e._v("Vector")]),e._v("的其他所有行为。由于"),n("code",[e._v("elementAt()")]),e._v("需要大量进行“封闭”工作，用到许多括号，所以随着代码主体的扩充，最终仍有可能需要大量代码。")]),e._v(" "),n("p",[e._v("和以前一样，在我们实现"),n("code",[e._v("Runnable")]),e._v("的时候，并没有获得与"),n("code",[e._v("Thread")]),e._v("配套提供的所有功能，所以必须创建一个新的"),n("code",[e._v("Thread")]),e._v("，并将自己传递给它的构造器，以便正式“启动”——"),n("code",[e._v("start()")]),e._v("——一些东西。大家在"),n("code",[e._v("CBoxVector")]),e._v("构造器和"),n("code",[e._v("go()")]),e._v("里都可以体会到这一点。"),n("code",[e._v("run()")]),e._v("方法简单地选择"),n("code",[e._v("Vector")]),e._v("里的一个随机元素编号，并为那个元素调用"),n("code",[e._v("nextColor()")]),e._v("，令其挑选一种新的随机颜色。")]),e._v(" "),n("p",[e._v("运行这个程序时，大家会发现它确实变得更快，响应也更迅速（比如在中断它的时候，它能更快地停下来）。而且随着网格尺寸的壮大，它也不会经常性地陷于“停顿”状态。因此，线程的处理又多了一项新的考虑因素：必须随时检查自己有没有“太多的线程”（无论对什么程序和运行平台）。若线程太多，必须试着使用上面介绍的技术，对程序中的线程数量进行“平衡”。如果在一个多线程的程序中遇到了性能上的问题，那么现在有许多因素需要检查：")]),e._v(" "),n("p",[e._v("(1) 对"),n("code",[e._v("sleep")]),e._v("，"),n("code",[e._v("yield()")]),e._v("以及／或者"),n("code",[e._v("wait()")]),e._v("的调用足够多吗？")]),e._v(" "),n("p",[e._v("(2) "),n("code",[e._v("sleep()")]),e._v("的调用时间足够长吗？")]),e._v(" "),n("p",[e._v("(3) 运行的线程数是不是太多？")]),e._v(" "),n("p",[e._v("(4) 试过不同的平台和JVM吗？")]),e._v(" "),n("p",[e._v("象这样的一些问题是造成多线程应用程序的编制成为一种“技术活”的原因之一。")])])}),[],!1,null,null,null);o.default=t.exports}}]);