(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{586:function(a,v,e){"use strict";e.r(v);var _=e(56),t=Object(_.a)({},(function(){var a=this,v=a.$createElement,e=a._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"_2-8-注释和嵌入文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-注释和嵌入文档"}},[a._v("#")]),a._v(" 2.8 注释和嵌入文档")]),a._v(" "),e("p",[a._v("(2)8 注释和嵌入文档")]),a._v(" "),e("p",[a._v("Java里有两种类型的注释。第一种是传统的、C语言风格的注释，是从C++继承而来的。这些注释用一个 "),e("code",[a._v("/*")]),a._v(" 起头，随后是注释内容，并可跨越多行，最后用一个"),e("code",[a._v("*/")]),a._v("结束。注意许多程序员在连续注释内容的每一行都用一个 "),e("code",[a._v("*")]),a._v(" 开头，所以经常能看到象下面这样的内容：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("/* 这是\n* 一段注释，\n* 它跨越了多个行\n*/\n")])])]),e("p",[a._v("但请记住，进行编译时，"),e("code",[a._v("/*")]),a._v("和"),e("code",[a._v("*/")]),a._v("之间的所有东西都会被忽略，所以上述注释与下面这段注释并没有什么不同：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("/* 这是一段注释，\n它跨越了多个行 */\n")])])]),e("p",[a._v("第二种类型的注释也起源于C++。这种注释叫作“单行注释”，以一个 "),e("code",[a._v("//")]),a._v(" 起头，表示这一行的所有内容都是注释。这种类型的注释更常用，因为它书写时更方便。没有必要在键盘上寻找 "),e("code",[a._v("/")]),a._v(" ，再寻找 "),e("code",[a._v("*")]),a._v(" （只需按同样的键两次），而且不必在注释结尾时加一个结束标记。下面便是这类注释的一个例子：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 这是一条单行注释\n")])])]),e("h2",{attrs:{id:"_2-8-1-注释文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-1-注释文档"}},[a._v("#")]),a._v(" 2.8.1 注释文档")]),a._v(" "),e("p",[a._v("对于Java语言，最体贴的一项设计就是它并没有打算让人们为了写程序而写程序——人们也需要考虑程序的文档化问题。对于程序的文档化，最大的问题莫过于对文档的维护。若文档与代码分离，那么每次改变代码后都要改变文档，这无疑会变成相当麻烦的一件事情。解决的方法看起来似乎很简单：将代码同文档“链接”起来。为达到这个目的，最简单的方法是将所有内容都置于同一个文件。然而，为使一切都整齐划一，还必须使用一种特殊的注释语法，以便标记出特殊的文档；另外还需要一个工具，用于提取这些注释，并按有价值的形式将其展现出来。这些都是Java必须做到的。")]),a._v(" "),e("p",[a._v("用于提取注释的工具叫作"),e("code",[a._v("javadoc")]),a._v("。它采用了部分来自Java编译器的技术，查找我们置入程序的特殊注释标记。它不仅提取由这些标记指示的信息，也将毗邻注释的类名或方法名提取出来。这样一来，我们就可用最轻的工作量，生成十分专业的程序文档。")]),a._v(" "),e("p",[e("code",[a._v("javadoc")]),a._v("输出的是一个HTML文件，可用自己的Web浏览器查看。该工具允许我们创建和管理单个源文件，并生动生成有用的文档。由于有了"),e("code",[a._v("javadoc")]),a._v("，所以我们能够用标准的方法创建文档。而且由于它非常方便，所以我们能轻松获得所有Java库的文档。")]),a._v(" "),e("h2",{attrs:{id:"_2-8-2-具体语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-2-具体语法"}},[a._v("#")]),a._v(" 2.8.2 具体语法")]),a._v(" "),e("p",[a._v("所有javadoc命令都只能出现于 "),e("code",[a._v("/**")]),a._v(" 注释中。但和平常一样，注释结束于一个 "),e("code",[a._v("*/")]),a._v(" 。主要通过两种方式来使用"),e("code",[a._v("javadoc")]),a._v("：嵌入的HTML，或使用“文档标记”。其中，“文档标记”（Doc tags）是一些以"),e("code",[a._v("@")]),a._v("开头的命令，置于注释行的起始处（但前导的"),e("code",[a._v("*")]),a._v("会被忽略）。")]),a._v(" "),e("p",[a._v("有三种类型的注释文档，它们对应于位于注释后面的元素：类、变量或者方法。也就是说，一个类注释正好位于一个类定义之前；变量注释正好位于变量定义之前；而一个方法定义正好位于一个方法定义的前面。如下面这个简单的例子所示：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("/** 一个类注释 */\npublic class docTest {\n/** 一个变量注释 */\npublic int i;\n/** 一个方法注释 */\npublic void f() {}\n}\n")])])]),e("p",[a._v("注意"),e("code",[a._v("javadoc")]),a._v("只能为"),e("code",[a._v("public")]),a._v("（公共）和"),e("code",[a._v("protected")]),a._v("（受保护）成员处理注释文档。"),e("code",[a._v("private")]),a._v("（私有）和“友好”（详见5章）成员的注释会被忽略，我们看不到任何输出（也可以用"),e("code",[a._v("-private")]),a._v("标记包括"),e("code",[a._v("private")]),a._v("成员）。这样做是有道理的，因为只有"),e("code",[a._v("public")]),a._v("和"),e("code",[a._v("protected")]),a._v("成员才可在文件之外使用，这是客户程序员的希望。然而，所有类注释都会包含到输出结果里。")]),a._v(" "),e("p",[a._v("上述代码的输出是一个HTML文件，它与其他Java文档具有相同的标准格式。因此，用户会非常熟悉这种格式，可在您设计的类中方便地“漫游”。设计程序时，请务必考虑输入上述代码，用"),e("code",[a._v("javadoc")]),a._v("处理一下，观看最终HTML文件的效果如何。")]),a._v(" "),e("h2",{attrs:{id:"_2-8-3-嵌入html"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-3-嵌入html"}},[a._v("#")]),a._v(" 2.8.3 嵌入HTML")]),a._v(" "),e("p",[e("code",[a._v("javadoc")]),a._v("将HTML命令传递给最终生成的HTML文档。这便使我们能够充分利用HTML的巨大威力。当然，我们的最终动机是格式化代码，不是为了哗众取宠。下面列出一个例子：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("/**\n* <pre>\n* System.out.println(new Date());\n* </pre>\n*/\n")])])]),e("p",[a._v("亦可象在其他Web文档里那样运用HTML，对普通文本进行格式化，使其更具条理、更加美观：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("/**\n* 您<em>甚至</em>可以插入一个列表：\n* <ol>\n* <li> 项目一\n* <li> 项目二\n* <li> 项目三\n* </ol>\n*/\n")])])]),e("p",[a._v("注意在文档注释中，位于一行最开头的星号会被"),e("code",[a._v("javadoc")]),a._v("丢弃。同时丢弃的还有前导空格。"),e("code",[a._v("javadoc")]),a._v(" 会对所有内容进行格式化，使其与标准的文档外观相符。不要将"),e("code",[a._v("<h1>")]),a._v("或"),e("code",[a._v("<hr>")]),a._v("这样的标题当作嵌入HTML使用，因为"),e("code",[a._v("javadoc")]),a._v("会插入自己的标题，我们给出的标题会与之冲撞。")]),a._v(" "),e("p",[a._v("所有类型的注释文档——类、变量和方法——都支持嵌入HTML。")]),a._v(" "),e("h2",{attrs:{id:"_2-8-4-see-引用其他类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-4-see-引用其他类"}},[a._v("#")]),a._v(" 2.8.4 "),e("code",[a._v("@see")]),a._v("：引用其他类")]),a._v(" "),e("p",[a._v("所有三种类型的注释文档都可包含"),e("code",[a._v("@see")]),a._v("标记，它允许我们引用其他类里的文档。对于这个标记，"),e("code",[a._v("javadoc")]),a._v("会生成相应的HTML，将其直接链接到其他文档。格式如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("@see 类名\n@see 完整类名\n@see 完整类名#方法名\n")])])]),e("p",[a._v("每一格式都会在生成的文档里自动加入一个超链接的“See Also”（参见）条目。注意"),e("code",[a._v("javadoc")]),a._v("不会检查我们指定的超链接，不会验证它们是否有效。")]),a._v(" "),e("h2",{attrs:{id:"_2-8-5-类文档标记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-5-类文档标记"}},[a._v("#")]),a._v(" 2.8.5 类文档标记")]),a._v(" "),e("p",[a._v("随同嵌入HTML和"),e("code",[a._v("@se")]),a._v("e引用，类文档还可以包括用于版本信息以及作者姓名的标记。类文档亦可用于“接口”目的（本书后面会详细解释）。")]),a._v(" "),e("p",[e("strong",[a._v("1. "),e("code",[a._v("@version")])])]),a._v(" "),e("p",[a._v("格式如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("@version 版本信息\n")])])]),e("p",[a._v("其中，“版本信息”代表任何适合作为版本说明的资料。若在"),e("code",[a._v("javadoc")]),a._v("命令行使用了"),e("code",[a._v("-version")]),a._v("标记，就会从生成的HTML文档里提取出版本信息。")]),a._v(" "),e("p",[e("strong",[a._v("2. "),e("code",[a._v("@author")])])]),a._v(" "),e("p",[a._v("格式如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("@author 作者信息\n")])])]),e("p",[a._v("其中，“作者信息”包括您的姓名、电子函件地址或者其他任何适宜的资料。若在"),e("code",[a._v("javadoc")]),a._v("命令行使用了"),e("code",[a._v("-author")]),a._v("标记，就会专门从生成的HTML文档里提取出作者信息。")]),a._v(" "),e("p",[a._v("可为一系列作者使用多个这样的标记，但它们必须连续放置。全部作者信息会一起存入最终HTML代码的单独一个段落里。")]),a._v(" "),e("h2",{attrs:{id:"_2-8-6-变量文档标记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-6-变量文档标记"}},[a._v("#")]),a._v(" 2.8.6 变量文档标记")]),a._v(" "),e("p",[a._v("变量文档只能包括嵌入的HTML以及"),e("code",[a._v("@see")]),a._v("引用。")]),a._v(" "),e("h2",{attrs:{id:"_2-8-7-方法文档标记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-7-方法文档标记"}},[a._v("#")]),a._v(" 2.8.7 方法文档标记")]),a._v(" "),e("p",[a._v("除嵌入HTML和"),e("code",[a._v("@see")]),a._v("引用之外，方法还允许使用针对参数、返回值以及异常的文档标记。")]),a._v(" "),e("p",[e("strong",[a._v("1. "),e("code",[a._v("@param")])]),a._v("\n格式如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("@param 参数名 说明\n")])])]),e("p",[a._v("其中，“参数名”是指参数列表内的标识符，而“说明”代表一些可延续到后续行内的说明文字。一旦遇到一个新文档标记，就认为前一个说明结束。可使用任意数量的说明，每个参数一个。")]),a._v(" "),e("p",[e("strong",[a._v("2. "),e("code",[a._v("@return")])])]),a._v(" "),e("p",[a._v("格式如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("@return 说明\n")])])]),e("p",[a._v("其中，“说明”是指返回值的含义。它可延续到后面的行内。")]),a._v(" "),e("p",[e("strong",[a._v("3. "),e("code",[a._v("@exception")])])]),a._v(" "),e("p",[a._v("有关“异常”（"),e("code",[a._v("Exception")]),a._v("）的详细情况，我们会在第9章讲述。简言之，它们是一些特殊的对象，若某个方法失败，就可将它们“扔出”对象。调用一个方法时，尽管只有一个异常对象出现，但一些特殊的方法也许能产生任意数量的、不同类型的异常。所有这些异常都需要说明。所以，异常标记的格式如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("@exception 完整类名 说明\n")])])]),e("p",[a._v("其中，“完整类名”明确指定了一个异常类的名字，它是在其他某个地方定义好的。而“说明”（同样可以延续到下面的行）告诉我们为什么这种特殊类型的异常会在方法调用中出现。")]),a._v(" "),e("p",[e("strong",[a._v("4. "),e("code",[a._v("@deprecated")])])]),a._v(" "),e("p",[a._v("这是Java 1.1的新特性。该标记用于指出一些旧功能已由改进过的新功能取代。该标记的作用是建议用户不必再使用一种特定的功能，因为未来改版时可能摒弃这一功能。若将一个方法标记为"),e("code",[a._v("@deprecated")]),a._v("，则使用该方法时会收到编译器的警告。")]),a._v(" "),e("h2",{attrs:{id:"_2-8-8-文档示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-8-文档示例"}},[a._v("#")]),a._v(" 2.8.8 文档示例")]),a._v(" "),e("p",[a._v("下面还是我们的第一个Java程序，只不过已加入了完整的文档注释：")]),a._v(" "),e("p",[a._v("92页程序")]),a._v(" "),e("p",[a._v("第一行：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("//: Property.java\n")])])]),e("p",[a._v("采用了我自己的方法：将一个"),e("code",[a._v(":")]),a._v("作为特殊的记号，指出这是包含了源文件名字的一个注释行。最后一行也用这样的一条注释结尾，它标志着源代码清单的结束。这样一来，可将代码从本书的正文中方便地提取出来，并用一个编译器检查。这方面的细节在第17章讲述。")])])}),[],!1,null,null,null);v.default=t.exports}}]);