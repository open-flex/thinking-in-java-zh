(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{416:function(e,v,_){"use strict";_.r(v);var a=_(56),t=Object(a.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"_1-6-多态对象的互换使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-多态对象的互换使用"}},[e._v("#")]),e._v(" 1.6 多态对象的互换使用")]),e._v(" "),_("p",[e._v("通常，继承最终会以创建一系列类收场，所有类都建立在统一的接口基础上。我们用一幅颠倒的树形图来阐明这一点（注释⑤）：")]),e._v(" "),_("p",[e._v("⑤：这儿采用了“统一记号法”，本书将主要采用这种方法。")]),e._v(" "),_("p",[_("img",{attrs:{src:"1-2.gif",alt:""}})]),e._v(" "),_("p",[e._v("对这样的一系列类，我们要进行的一项重要处理就是将派生类的对象当作基类的一个对象对待。这一点是非常重要的，因为它意味着我们只需编写单一的代码，令其忽略类型的特定细节，只与基类打交道。这样一来，那些代码就可与类型信息分开。所以更易编写，也更易理解。此外，若通过继承增添了一种新类型，如“三角形”，那么我们为“几何形状”新类型编写的代码会象在旧类型里一样良好地工作。所以说程序具备了“扩展能力”，具有“扩展性”。\n以上面的例子为基础，假设我们用Java写了这样一个函数：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("void doStuff(Shape s) {\n  s.erase();\n  // ...\n  s.draw();\n}\n")])])]),_("p",[e._v("这个函数可与任何“几何形状”（"),_("code",[e._v("Shape")]),e._v("）通信，所以完全独立于它要描绘（"),_("code",[e._v("draw")]),e._v("）和删除（"),_("code",[e._v("erase")]),e._v("）的任何特定类型的对象。如果我们在其他一些程序里使用"),_("code",[e._v("doStuff()")]),e._v("函数：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("Circle c = new Circle();\nTriangle t = new Triangle();\nLine l = new Line();\ndoStuff(c);\ndoStuff(t);\ndoStuff(l);\n")])])]),_("p",[e._v("那么对"),_("code",[e._v("doStuff()")]),e._v("的调用会自动良好地工作，无论对象的具体类型是什么。\n这实际是一个非常有用的编程技巧。请考虑下面这行代码：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("doStuff(c);\n")])])]),_("p",[e._v("此时，一个"),_("code",[e._v("Circle")]),e._v("（圆）引用传递给一个本来期待"),_("code",[e._v("Shape")]),e._v("（形状）引用的函数。由于圆是一种几何形状，所以"),_("code",[e._v("doStuff()")]),e._v("能正确地进行处理。也就是说，凡是"),_("code",[e._v("doStuff()")]),e._v("能发给一个"),_("code",[e._v("Shape")]),e._v("的消息，"),_("code",[e._v("Circle")]),e._v("也能接收。所以这样做是安全的，不会造成错误。")]),e._v(" "),_("p",[e._v("我们将这种把派生类型当作它的基本类型处理的过程叫作“Upcasting”（向上转换）。其中，“cast”（转换）是指根据一个现成的模型创建；而“Up”（向上）表明继承的方向是从“上面”来的——即基类位于顶部，而派生类在下方展开。所以，根据基类进行转换就是一个从上面继承的过程，即“Upcasting”。")]),e._v(" "),_("p",[e._v("在面向对象的程序里，通常都要用到向上转换技术。这是避免去调查准确类型的一个好办法。请看看"),_("code",[e._v("doStuff()")]),e._v("里的代码：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("s.erase();\n// ...\ns.draw();\n")])])]),_("p",[e._v("注意它并未这样表达：“如果你是一个"),_("code",[e._v("Circle")]),e._v("，就这样做；如果你是一个"),_("code",[e._v("Square")]),e._v("，就那样做；等等”。若那样编写代码，就需检查一个"),_("code",[e._v("Shape")]),e._v("所有可能的类型，如圆、矩形等等。这显然是非常麻烦的，而且每次添加了一种新的"),_("code",[e._v("Shape")]),e._v("类型后，都要相应地进行修改。在这儿，我们只需说：“你是一种几何形状，我知道你能将自己删掉，即"),_("code",[e._v("erase()")]),e._v("；请自己采取那个行动，并自己去控制所有的细节吧。”")]),e._v(" "),_("h2",{attrs:{id:"_1-6-1-动态绑定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-1-动态绑定"}},[e._v("#")]),e._v(" 1.6.1 动态绑定")]),e._v(" "),_("p",[e._v("在"),_("code",[e._v("doStuff()")]),e._v("的代码里，最让人吃惊的是尽管我们没作出任何特殊指示，采取的操作也是完全正确和恰当的。我们知道，为"),_("code",[e._v("Circle")]),e._v("调用"),_("code",[e._v("draw()")]),e._v("时执行的代码与为一个"),_("code",[e._v("Square")]),e._v("或"),_("code",[e._v("Line")]),e._v("调用"),_("code",[e._v("draw()")]),e._v("时执行的代码是不同的。但在将"),_("code",[e._v("draw()")]),e._v("消息发给一个匿名"),_("code",[e._v("Shape")]),e._v("时，根据"),_("code",[e._v("Shape")]),e._v("引用当时连接的实际类型，会相应地采取正确的操作。这当然令人惊讶，因为当Java编译器为"),_("code",[e._v("doStuff()")]),e._v("编译代码时，它并不知道自己要操作的准确类型是什么。尽管我们确实可以保证最终会为"),_("code",[e._v("Shape")]),e._v("调用"),_("code",[e._v("erase()")]),e._v("，为"),_("code",[e._v("Shape")]),e._v("调用"),_("code",[e._v("draw()")]),e._v("，但并不能保证为特定的"),_("code",[e._v("Circle")]),e._v("，"),_("code",[e._v("Square")]),e._v("或者"),_("code",[e._v("Line")]),e._v("调用什么。然而最后采取的操作同样是正确的，这是怎么做到的呢？")]),e._v(" "),_("p",[e._v("将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多态性”（Polymorphism）。对面向对象的程序设计语言来说，它们用以实现多态性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。")]),e._v(" "),_("p",[e._v("有些语言要求我们用一个特殊的关键字来允许动态绑定。在C++中，这个关键字是"),_("code",[e._v("virtual")]),e._v("。在Java中，我们则完全不必记住添加一个关键字，因为函数的动态绑定是自动进行的。所以在将一条消息发给对象时，我们完全可以肯定对象会采取正确的行动，即使其中涉及向上转换之类的处理。")]),e._v(" "),_("h2",{attrs:{id:"_1-6-2-抽象的基类和接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-2-抽象的基类和接口"}},[e._v("#")]),e._v(" 1.6.2 抽象的基类和接口")]),e._v(" "),_("p",[e._v("设计程序时，我们经常都希望基类只为自己的派生类提供一个接口。也就是说，我们不想其他任何人实际创建基类的一个对象，只对向上转换成它，以便使用它们的接口。为达到这个目的，需要把那个类变成“抽象”的——使用"),_("code",[e._v("abstract")]),e._v("关键字。若有人试图创建抽象类的一个对象，编译器就会阻止他们。这种工具可有效强制实行一种特殊的设计。")]),e._v(" "),_("p",[e._v("亦可用"),_("code",[e._v("abstract")]),e._v("关键字描述一个尚未实现的方法——作为一个“根”使用，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。”抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。通过创建一个抽象方法，我们可以将一个方法置入接口中，不必再为那个方法提供可能毫无意义的主体代码。")]),e._v(" "),_("p",[_("code",[e._v("interface")]),e._v("（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通"),_("code",[e._v("class")]),e._v("或"),_("code",[e._v("abstract class")]),e._v("中继承）。")])])}),[],!1,null,null,null);v.default=t.exports}}]);