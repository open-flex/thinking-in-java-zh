(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{543:function(t,e,n){"use strict";n.r(e);var i=n(56),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_6-9-初始化和类装载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-初始化和类装载"}},[t._v("#")]),t._v(" 6.9 初始化和类装载")]),t._v(" "),n("p",[t._v("在许多传统语言里，程序都是作为启动过程的一部分一次性载入的。随后进行的是初始化，再是正式执行程序。在这些语言中，必须对初始化过程进行慎重的控制，保证"),n("code",[t._v("static")]),t._v("数据的初始化不会带来麻烦。比如在一个"),n("code",[t._v("static")]),t._v("数据获得初始化之前，就有另一个"),n("code",[t._v("static")]),t._v("数据希望它是一个有效值，那么在C++中就会造成问题。")]),t._v(" "),n("p",[t._v("Java则没有这样的问题，因为它采用了不同的装载方法。由于Java中的一切东西都是对象，所以许多活动变得更加简单，这个问题便是其中的一例。正如下一章会讲到的那样，每个对象的代码都存在于独立的文件中。除非真的需要代码，否则那个文件是不会载入的。通常，我们可认为除非那个类的一个对象构造完毕，否则代码不会真的载入。由于"),n("code",[t._v("static")]),t._v("方法存在一些细微的歧义，所以也能认为“类代码在首次使用的时候载入”。")]),t._v(" "),n("p",[t._v("首次使用的地方也是"),n("code",[t._v("static")]),t._v("初始化发生的地方。装载的时候，所有"),n("code",[t._v("static")]),t._v("对象和"),n("code",[t._v("static")]),t._v("代码块都会按照本来的顺序初始化（亦即它们在类定义代码里写入的顺序）。当然，"),n("code",[t._v("static")]),t._v("数据只会初始化一次。")]),t._v(" "),n("h2",{attrs:{id:"_6-9-1-继承初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-1-继承初始化"}},[t._v("#")]),t._v(" 6.9.1 继承初始化")]),t._v(" "),n("p",[t._v("我们有必要对整个初始化过程有所认识，其中包括继承，对这个过程中发生的事情有一个整体性的概念。请观察下述代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('//: Beetle.java\n// The full process of initialization.\n\nclass Insect {\n  int i = 9;\n  int j;\n  Insect() {\n    prt("i = " + i + ", j = " + j);\n    j = 39;\n  }\n  static int x1 =\n    prt("static Insect.x1 initialized");\n  static int prt(String s) {\n    System.out.println(s);\n    return 47;\n  }\n}\n\npublic class Beetle extends Insect {\n  int k = prt("Beetle.k initialized");\n  Beetle() {\n    prt("k = " + k);\n    prt("j = " + j);\n  }\n  static int x2 =\n    prt("static Beetle.x2 initialized");\n  static int prt(String s) {\n    System.out.println(s);\n    return 63;\n  }\n  public static void main(String[] args) {\n    prt("Beetle constructor");\n    Beetle b = new Beetle();\n  }\n} ///:~\n')])])]),n("p",[t._v("该程序的输出如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("static Insect.x initialized\nstatic Beetle.x initialized\nBeetle constructor\ni = 9, j = 0\nBeetle.k initialized\nk = 63\nj = 39\n")])])]),n("p",[t._v("对"),n("code",[t._v("Beetle")]),t._v("运行"),n("code",[t._v("java")]),t._v("时，发生的第一件事情是装载程序到外面找到那个类。在装载过程中，装载程序注意它有一个基类（即"),n("code",[t._v("extends")]),t._v("关键字要表达的意思），所以随之将其载入。无论是否准备生成那个基类的一个对象，这个过程都会发生（请试着将对象的创建代码当作注释标注出来，自己去证实）。")]),t._v(" "),n("p",[t._v("若基类含有另一个基类，则另一个基类随即也会载入，以此类推。接下来，会在根基类（此时是"),n("code",[t._v("Insect")]),t._v("）执行"),n("code",[t._v("static")]),t._v("初始化，再在下一个派生类执行，以此类推。保证这个顺序是非常关键的，因为派生类的初始化可能要依赖于对基类成员的正确初始化。")]),t._v(" "),n("p",[t._v("此时，必要的类已全部装载完毕，所以能够创建对象。首先，这个对象中的所有基本数据类型都会设成它们的默认值，而将对象引用设为"),n("code",[t._v("null")]),t._v("。随后会调用基类构造器。在这种情况下，调用是自动进行的。但也完全可以用"),n("code",[t._v("super")]),t._v("来自行指定构造器调用（就象在"),n("code",[t._v("Beetle()")]),t._v("构造器中的第一个操作一样）。基类的构建采用与派生类构造器完全相同的处理过程。基础顺构造器完成以后，实例变量会按本来的顺序得以初始化。最后，执行构造器剩余的主体部分。")])])}),[],!1,null,null,null);e.default=a.exports}}]);