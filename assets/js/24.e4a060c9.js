(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{422:function(t,e,v){"use strict";v.r(e);var _=v(56),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"_10-10-总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-10-总结"}},[t._v("#")]),t._v(" 10.10 总结")]),t._v(" "),v("p",[t._v("Java IO流库能满足我们的许多基本要求：可以通过控制台、文件、内存块甚至因特网（参见第15章）进行读写。可以创建新的输入和输出对象类型（通过从"),v("code",[t._v("InputStream")]),t._v("和"),v("code",[t._v("OutputStream")]),t._v("继承）。向一个本来预期为收到字符串的方法传递一个对象时，由于Java已限制了“自动类型转换”，所以会自动调用"),v("code",[t._v("toString()")]),t._v("方法。而我们可以重新定义这个"),v("code",[t._v("toString()")]),t._v("，扩展一个数据流能接纳的对象种类。")]),t._v(" "),v("p",[t._v("在IO数据流库的联机文档和设计过程中，仍有些问题没有解决。比如当我们打开一个文件以便输出时，完全可以指定一旦有人试图覆盖该文件就“抛”出一个异常——有的编程系统允许我们自行指定想打开一个输出文件，但唯一的前提是它尚不存在。但在Java中，似乎必须用一个"),v("code",[t._v("File")]),t._v("对象来判断某个文件是否存在，因为假如将其作为"),v("code",[t._v("FileOutputStream")]),t._v("或者"),v("code",[t._v("FileWriter")]),t._v("打开，那么肯定会被覆盖。若同时指定文件和目录路径，"),v("code",[t._v("File")]),t._v("类设计上的一个缺陷就会暴露出来，因为它会说“不要试图在单个类里做太多的事情”！")]),t._v(" "),v("p",[t._v("IO流库易使我们混淆一些概念。它确实能做许多事情，而且也可以移植。但假如假如事先没有吃透装饰器方案的概念，那么所有的设计都多少带有一点盲目性质。所以不管学它还是教它，都要特别花一些功夫才行。而且它并不完整：没有提供对输出格式化的支持，而其他几乎所有语言的IO包都提供了这方面的支持（这一点没有在Java 1.1里得以纠正，它完全错失了改变库设计模式的机会，反而增添了更特殊的一些情况，使复杂程度进一步提高）。Java 1.1转到那些尚未替换的IO库，而不是增加新库。而且库的设计人员似乎没有很好地指出哪些特性是不赞成的，哪些是首选的，造成库设计中经常都会出现一些令人恼火的反对消息。")]),t._v(" "),v("p",[t._v("然而，一旦掌握了装饰器方案，并开始在一些较为灵活的环境使用库，就会认识到这种设计的好处。到那个时候，为此多付出的代码行应该不至于使你觉得太生气。")])])}),[],!1,null,null,null);e.default=a.exports}}]);