(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{548:function(n,e,a){"use strict";a.r(e);var t=a(56),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"_7-2-深入理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-深入理解"}},[n._v("#")]),n._v(" 7.2 深入理解")]),n._v(" "),a("p",[n._v("对于"),a("code",[n._v("Music.java")]),n._v("的困难性，可通过运行程序加以体会。输出是"),a("code",[n._v("Wind.play()")]),n._v("。这当然是我们希望的输出，但它看起来似乎并不愿按我们的希望行事。请观察一下"),a("code",[n._v("tune()")]),n._v("方法：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public static void tune(Instrument i) {\n// ...\ni.play(Note.middleC);\n}\n")])])]),a("p",[n._v("它接收"),a("code",[n._v("Instrument")]),n._v("引用。所以在这种情况下，编译器怎样才能知道"),a("code",[n._v("Instrument")]),n._v("引用指向的是一个"),a("code",[n._v("Wind")]),n._v("，而不是一个"),a("code",[n._v("Brass")]),n._v("或"),a("code",[n._v("Stringed")]),n._v("呢？编译器无从得知。为了深入了理解这个问题，我们有必要探讨一下“绑定”这个主题。")]),n._v(" "),a("h2",{attrs:{id:"_7-2-1-方法调用的绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-1-方法调用的绑定"}},[n._v("#")]),n._v(" 7.2.1 方法调用的绑定")]),n._v(" "),a("p",[n._v("将一个方法调用同一个方法主体连接到一起就称为“绑定”（Binding）。若在程序运行以前执行绑定（由编译器和链接程序，如果有的话），就叫作“早期绑定”。大家以前或许从未听说过这个术语，因为它在任何程序化语言里都是不可能的。C编译器只有一种方法调用，那就是“早期绑定”。")]),n._v(" "),a("p",[n._v("上述程序最令人迷惑不解的地方全与早期绑定有关，因为在只有一个"),a("code",[n._v("Instrument")]),n._v("引用的前提下，编译器不知道具体该调用哪个方法。")]),n._v(" "),a("p",[n._v("解决的方法就是“后期绑定”，它意味着绑定在运行期间进行，以对象的类型为基础。后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。")]),n._v(" "),a("p",[n._v("Java中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成"),a("code",[n._v("final")]),n._v("。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。")]),n._v(" "),a("p",[n._v("为什么要把一个方法声明成"),a("code",[n._v("final")]),n._v("呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为"),a("code",[n._v("final")]),n._v("方法调用生成效率更高的代码。")]),n._v(" "),a("h2",{attrs:{id:"_7-2-2-产生正确的行为"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-2-产生正确的行为"}},[n._v("#")]),n._v(" 7.2.2 产生正确的行为")]),n._v(" "),a("p",[n._v("知道Java里绑定的所有方法都通过后期绑定具有多态性以后，就可以相应地编写自己的代码，令其与基类沟通。此时，所有的派生类都保证能用相同的代码正常地工作。或者换用另一种方法，我们可以“将一条消息发给一个对象，让对象自行判断要做什么事情。”")]),n._v(" "),a("p",[n._v("在面向对象的程序设计中，有一个经典的“形状”例子。由于它很容易用可视化的形式表现出来，所以经常都用它说明问题。但很不幸的是，它可能误导初学者认为OOP只是为图形化编程设计的，这种认识当然是错误的。")]),n._v(" "),a("p",[n._v("形状例子有一个基类，名为"),a("code",[n._v("Shape")]),n._v("；另外还有大量派生类型："),a("code",[n._v("Circle")]),n._v("（圆形），"),a("code",[n._v("Square")]),n._v("（方形），"),a("code",[n._v("Triangle")]),n._v("（三角形）等等。大家之所以喜欢这个例子，因为很容易理解“圆属于形状的一种类型”等概念。下面这幅继承图向我们展示了它们的关系：")]),n._v(" "),a("p",[a("img",{attrs:{src:"7-1.gif",alt:""}})]),n._v(" "),a("p",[n._v("向上转换可用下面这个语句简单地表现出来：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Shape s = new Circle();\n")])])]),a("p",[n._v("在这里，我们创建了"),a("code",[n._v("Circle")]),n._v("对象，并将结果引用立即赋给一个"),a("code",[n._v("Shape")]),n._v("。这表面看起来似乎属于错误操作（将一种类型分配给另一个），但实际是完全可行的——因为按照继承关系，"),a("code",[n._v("Circle")]),n._v("属于"),a("code",[n._v("Shape")]),n._v("的一种。因此编译器认可上述语句，不会向我们提示一条出错消息。\n当我们调用其中一个基类方法时（已在派生类里覆盖）：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("s.draw();\n")])])]),a("p",[n._v("同样地，大家也许认为会调用"),a("code",[n._v("Shape")]),n._v("的"),a("code",[n._v("draw()")]),n._v("，因为这毕竟是一个"),a("code",[n._v("Shape")]),n._v("引用。那么编译器怎样才能知道该做其他任何事情呢？但此时实际调用的是"),a("code",[n._v("Circle.draw()")]),n._v("，因为后期绑定已经介入（多态性）。")]),n._v(" "),a("p",[n._v("下面这个例子从一个稍微不同的角度说明了问题：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//: Shapes.java\n// Polymorphism in Java\n\nclass Shape {\n  void draw() {}\n  void erase() {}\n}\n\nclass Circle extends Shape {\n  void draw() {\n    System.out.println("Circle.draw()");\n  }\n  void erase() {\n    System.out.println("Circle.erase()");\n  }\n}\n\nclass Square extends Shape {\n  void draw() {\n    System.out.println("Square.draw()");\n  }\n  void erase() {\n    System.out.println("Square.erase()");\n  }\n}\n\nclass Triangle extends Shape {\n  void draw() {\n    System.out.println("Triangle.draw()");\n  }\n  void erase() {\n    System.out.println("Triangle.erase()");\n  }\n}\n\npublic class Shapes {\n  public static Shape randShape() {\n    switch((int)(Math.random() * 3)) {\n      default: // To quiet the compiler\n      case 0: return new Circle();\n      case 1: return new Square();\n      case 2: return new Triangle();\n    }\n  }\n  public static void main(String[] args) {\n    Shape[] s = new Shape[9];\n    // Fill up the array with shapes:\n    for(int i = 0; i < s.length; i++)\n      s[i] = randShape();\n    // Make polymorphic method calls:\n    for(int i = 0; i < s.length; i++)\n      s[i].draw();\n  }\n} ///:~\n')])])]),a("p",[n._v("针对从"),a("code",[n._v("Shape")]),n._v("派生出来的所有东西，"),a("code",[n._v("Shape")]),n._v("建立了一个通用接口——也就是说，所有（几何）形状都可以描绘和删除。派生类覆盖了这些定义，为每种特殊类型的几何形状都提供了独一无二的行为。")]),n._v(" "),a("p",[n._v("在主类"),a("code",[n._v("Shapes")]),n._v("里，包含了一个"),a("code",[n._v("static")]),n._v("方法，名为"),a("code",[n._v("randShape()")]),n._v("。它的作用是在每次调用它时为某个随机选择的"),a("code",[n._v("Shape")]),n._v("对象生成一个引用。请注意向上转换是在每个"),a("code",[n._v("return")]),n._v("语句里发生的。这个语句取得指向一个"),a("code",[n._v("Circle")]),n._v("，"),a("code",[n._v("Square")]),n._v("或者"),a("code",[n._v("Triangle")]),n._v("的引用，并将其作为返回类型"),a("code",[n._v("Shape")]),n._v("发给方法。所以无论什么时候调用这个方法，就绝对没机会了解它的具体类型到底是什么，因为肯定会获得一个单纯的"),a("code",[n._v("Shape")]),n._v("引用。")]),n._v(" "),a("p",[a("code",[n._v("main()")]),n._v("包含了"),a("code",[n._v("Shape")]),n._v("引用的一个数组，其中的数据通过对"),a("code",[n._v("randShape()")]),n._v("的调用填入。在这个时候，我们知道自己拥有"),a("code",[n._v("Shape")]),n._v("，但不知除此之外任何具体的情况（编译器同样不知）。然而，当我们在这个数组里步进，并为每个元素调用"),a("code",[n._v("draw()")]),n._v("的时候，与各类型有关的正确行为会魔术般地发生，就象下面这个输出示例展示的那样：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Circle.draw()\nTriangle.draw()\nCircle.draw()\nCircle.draw()\nCircle.draw()\nSquare.draw()\nTriangle.draw()\nSquare.draw()\nSquare.draw()\n")])])]),a("p",[n._v("当然，由于几何形状是每次随机选择的，所以每次运行都可能有不同的结果。之所以要突出形状的随机选择，是为了让大家深刻体会这一点：为了在编译的时候发出正确的调用，编译器毋需获得任何特殊的情报。对"),a("code",[n._v("draw()")]),n._v("的所有调用都是通过动态绑定进行的。")]),n._v(" "),a("h2",{attrs:{id:"_7-2-3-扩展性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-3-扩展性"}},[n._v("#")]),n._v(" 7.2.3 扩展性")]),n._v(" "),a("p",[n._v("现在，让我们仍然返回乐器（"),a("code",[n._v("Instrument")]),n._v("）示例。由于存在多态性，所以可根据自己的需要向系统里加入任意多的新类型，同时毋需更改"),a("code",[n._v("tune()")]),n._v("方法。在一个设计良好的OOP程序中，我们的大多数或者所有方法都会遵从"),a("code",[n._v("tune()")]),n._v("的模型，而且只与基类接口通信。我们说这样的程序具有“扩展性”，因为可以从通用的基类继承新的数据类型，从而新添一些功能。如果是为了适应新类的要求，那么对基类接口进行操纵的方法根本不需要改变，对于乐器例子，假设我们在基类里加入更多的方法，以及一系列新类，那么会出现什么情况呢？下面是示意图：")]),n._v(" "),a("p",[a("img",{attrs:{src:"7-2.gif",alt:""}})]),n._v(" "),a("p",[n._v("所有这些新类都能与老类——"),a("code",[n._v("tune()")]),n._v("默契地工作，毋需对"),a("code",[n._v("tune()")]),n._v("作任何调整。即使"),a("code",[n._v("tune()")]),n._v("位于一个独立的文件里，而将新方法添加到"),a("code",[n._v("Instrument")]),n._v("的接口，"),a("code",[n._v("tune()")]),n._v("也能正确地工作，不需要重新编译。下面这个程序是对上述示意图的具体实现：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//: Music3.java\n// An extensible program\nimport java.util.*;\n\nclass Instrument3 {\n  public void play() {\n    System.out.println("Instrument3.play()");\n  }\n  public String what() {\n    return "Instrument3";\n  }\n  public void adjust() {}\n}\n\nclass Wind3 extends Instrument3 {\n  public void play() {\n    System.out.println("Wind3.play()");\n  }\n  public String what() { return "Wind3"; }\n  public void adjust() {}\n}\n\nclass Percussion3 extends Instrument3 {\n  public void play() {\n    System.out.println("Percussion3.play()");\n  }\n  public String what() { return "Percussion3"; }\n  public void adjust() {}\n}\n\nclass Stringed3 extends Instrument3 {\n  public void play() {\n    System.out.println("Stringed3.play()");\n  }\n  public String what() { return "Stringed3"; }\n  public void adjust() {}\n}\n\nclass Brass3 extends Wind3 {\n  public void play() {\n    System.out.println("Brass3.play()");\n  }\n  public void adjust() {\n    System.out.println("Brass3.adjust()");\n  }\n}\n\nclass Woodwind3 extends Wind3 {\n  public void play() {\n    System.out.println("Woodwind3.play()");\n  }\n  public String what() { return "Woodwind3"; }\n}\n\npublic class Music3 {\n  // Doesn\'t care about type, so new types\n  // added to the system still work right:\n  static void tune(Instrument3 i) {\n    // ...\n    i.play();\n  }\n  static void tuneAll(Instrument3[] e) {\n    for(int i = 0; i < e.length; i++)\n      tune(e[i]);\n  }\n  public static void main(String[] args) {\n    Instrument3[] orchestra = new Instrument3[5];\n    int i = 0;\n    // Upcasting during addition to the array:\n    orchestra[i++] = new Wind3();\n    orchestra[i++] = new Percussion3();\n    orchestra[i++] = new Stringed3();\n    orchestra[i++] = new Brass3();\n    orchestra[i++] = new Woodwind3();\n    tuneAll(orchestra);\n  }\n} ///:~\n')])])]),a("p",[n._v("新方法是"),a("code",[n._v("what()")]),n._v("和"),a("code",[n._v("adjust()")]),n._v("。前者返回一个"),a("code",[n._v("String")]),n._v("引用，同时返回对那个类的说明；后者使我们能对每种乐器进行调整。")]),n._v(" "),a("p",[n._v("在"),a("code",[n._v("main()")]),n._v("中，当我们将某样东西置入"),a("code",[n._v("Instrument3")]),n._v("数组时，就会自动向上转换到"),a("code",[n._v("Instrument3")]),n._v("。")]),n._v(" "),a("p",[n._v("可以看到，在围绕"),a("code",[n._v("tune()")]),n._v("方法的其他所有代码都发生变化的同时，"),a("code",[n._v("tune()")]),n._v("方法却丝毫不受它们的影响，依然故我地正常工作。这正是利用多态性希望达到的目标。我们对代码进行修改后，不会对程序中不应受到影响的部分造成影响。此外，我们认为多态性是一种至关重要的技术，它允许程序员“将发生改变的东西同没有发生改变的东西区分开”。")])])}),[],!1,null,null,null);e.default=r.exports}}]);