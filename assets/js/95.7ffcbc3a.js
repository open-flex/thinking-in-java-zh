(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{493:function(n,e,a){"use strict";a.r(e);var t=a(56),i=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"_16-6-多重分发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-6-多重分发"}},[n._v("#")]),n._v(" 16.6 多重分发")]),n._v(" "),a("p",[n._v("上述设计模式肯定是令人满意的。系统内新类型的加入涉及添加或修改不同的类，但没有必要在系统内对代码作大范围的改动。除此以外，RTTI并不象它在"),a("code",[n._v("RecycleA.java")]),n._v("里那样被不当地使用。然而，我们仍然有可能更深入一步，以最“纯”的角度来看待RTTI，\n考虑如何在垃圾分类系统中将它完全消灭。")]),n._v(" "),a("p",[n._v("为达到这个目标，首先必须认识到：对所有与不同类型有特殊关联的活动来说——比如侦测一种垃圾的具体类型，并把它置入适当的垃圾筒里——这些活动都应当通过多态性以及动态绑定加以控制。")]),n._v(" "),a("p",[n._v("以前的例子都是先按类型排序，再对属于某种特殊类型的一系列元素进行操作。现在一旦需要操作特定的类型，就请先停下来想一想。事实上，多态性（动态绑定的方法调用）整个的宗旨就是帮我们管理与不同类型有特殊关联的信息。既然如此，为什么还要自己去检查类型呢？")]),n._v(" "),a("p",[n._v("答案在于大家或许不以为然的一个道理：Java只执行单一分发。也就是说，假如对多个类型未知的对象执行某项操作，Java只会为那些类型中的一种调用动态绑定机制。这当然不能解决问题，所以最后不得不人工判断某些类型，才能有效地产生自己的动态绑定行为。")]),n._v(" "),a("p",[n._v("为解决这个缺陷，我们需要用到“多重分发”机制，这意味着需要建立一个配置，使单一方法调用能产生多个动态方法调用，从而在一次处理过程中正确判断出多种类型。为达到这个要求，需要对多个类型结构进行操作：每一次分发都需要一个类型结构。下面的例子将对两个结构进行操作：现有的Trash系列以及由垃圾筒（Trash Bin）的类型构成的一个系列——不同的垃圾或废品将置入这些筒内。第二个分级结构并非绝对显然的。在这种情况下，我们需要人为地创建它，以执行多重分发（由于本例只涉及两次分发，所以称为“双重分发”）。")]),n._v(" "),a("h2",{attrs:{id:"_16-6-1-实现双重分发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-6-1-实现双重分发"}},[n._v("#")]),n._v(" 16.6.1 实现双重分发")]),n._v(" "),a("p",[n._v("记住多态性只能通过方法调用才能表现出来，所以假如想使双重分发正确进行，必须执行两个方法调用：在每种结构中都用一个来判断其中的类型。在"),a("code",[n._v("Trash")]),n._v("结构中，将使用一个新的方法调用"),a("code",[n._v("addToBin()")]),n._v("，它采用的参数是由"),a("code",[n._v("TypeBin")]),n._v("构成的一个数组。那个方法将在数组中遍历，尝试将自己加入适当的垃圾筒，这里正是双重分发发生的地方。")]),n._v(" "),a("p",[a("img",{attrs:{src:"16-3.gif",alt:""}})]),n._v(" "),a("p",[n._v("新建立的分级结构是"),a("code",[n._v("TypeBin")]),n._v("，其中包含了它自己的一个方法，名为"),a("code",[n._v("add()")]),n._v("，而且也应用了多态性。但要注意一个新特点："),a("code",[n._v("add()")]),n._v("已进行了“重载”处理，可接受不同的垃圾类型作为参数。因此，双重满足机制的一个关键点是它也要涉及到重载。")]),n._v(" "),a("p",[n._v("程序的重新设计也带来了一个问题：现在的基类"),a("code",[n._v("Trash")]),n._v("必须包含一个"),a("code",[n._v("addToBin()")]),n._v("方法。为解决这个问题，一个最直接的办法是复制所有代码，并修改基类。然而，假如没有对源码的控制权，那么还有另一个办法可以考虑：将"),a("code",[n._v("addToBin()")]),n._v("方法置入一个接口内部，保持"),a("code",[n._v("Trash")]),n._v("不变，并继承新的、特殊的类型"),a("code",[n._v("Aluminum")]),n._v("，"),a("code",[n._v("Paper")]),n._v("，"),a("code",[n._v("Glass")]),n._v("以及"),a("code",[n._v("Cardboard")]),n._v("。我们在这里准备采取后一个办法。")]),n._v(" "),a("p",[n._v("这个设计模式中用到的大多数类都必须设为"),a("code",[n._v("public")]),n._v("（公用）属性，所以它们放置于自己的类内。下面列出接口代码：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//: TypedBinMember.java\n// An interface for adding the double dispatching\n// method to the trash hierarchy without\n// modifying the original hierarchy.\npackage c16.doubledispatch;\n\ninterface TypedBinMember {\n  // The new method:\n  boolean addToBin(TypedBin[] tb);\n} ///:~\n")])])]),a("p",[n._v("在"),a("code",[n._v("Aluminum")]),n._v("，"),a("code",[n._v("Paper")]),n._v("，"),a("code",[n._v("Glass")]),n._v("以及"),a("code",[n._v("Cardboard")]),n._v("每个特定的子类型内，都会实现接口"),a("code",[n._v("TypeBinMember")]),n._v("的"),a("code",[n._v("addToBin()")]),n._v("方法，但每种情况下使用的代码“似乎”都是完全一样的：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//: DDAluminum.java\n// Aluminum for double dispatching\npackage c16.doubledispatch;\nimport c16.trash.*;\n\npublic class DDAluminum extends Aluminum\n    implements TypedBinMember {\n  public DDAluminum(double wt) { super(wt); }\n  public boolean addToBin(TypedBin[] tb) {\n    for(int i = 0; i < tb.length; i++)\n      if(tb[i].add(this))\n        return true;\n    return false;\n  }\n} ///:~\n//: DDPaper.java\n// Paper for double dispatching\npackage c16.doubledispatch;\nimport c16.trash.*;\n\npublic class DDPaper extends Paper\n    implements TypedBinMember {\n  public DDPaper(double wt) { super(wt); }\n  public boolean addToBin(TypedBin[] tb) {\n    for(int i = 0; i < tb.length; i++)\n      if(tb[i].add(this))\n        return true;\n    return false;\n  }\n} ///:~\n//: DDGlass.java\n// Glass for double dispatching\npackage c16.doubledispatch;\nimport c16.trash.*;\n\npublic class DDGlass extends Glass\n    implements TypedBinMember {\n  public DDGlass(double wt) { super(wt); }\n  public boolean addToBin(TypedBin[] tb) {\n    for(int i = 0; i < tb.length; i++)\n      if(tb[i].add(this))\n        return true;\n    return false;\n  }\n} ///:~\n//: DDCardboard.java\n// Cardboard for double dispatching\npackage c16.doubledispatch;\nimport c16.trash.*;\n\npublic class DDCardboard extends Cardboard\n    implements TypedBinMember {\n  public DDCardboard(double wt) { super(wt); }\n  public boolean addToBin(TypedBin[] tb) {\n    for(int i = 0; i < tb.length; i++)\n      if(tb[i].add(this))\n        return true;\n    return false;\n  }\n} ///:~\n")])])]),a("p",[n._v("每个"),a("code",[n._v("addToBin()")]),n._v("内的代码会为数组中的每个"),a("code",[n._v("TypeBin")]),n._v("对象调用"),a("code",[n._v("add()")]),n._v("。但请注意参数："),a("code",[n._v("this")]),n._v("。对"),a("code",[n._v("Trash")]),n._v("的每个子类来说，"),a("code",[n._v("this")]),n._v("的类型都是不同的，所以不能认为代码“完全”一样——尽管以后在Java里加入参数化类型机制后便可认为一样。这是双重分发的第一个部分，因为一旦进入这个方法内部，便可知道到底是"),a("code",[n._v("Aluminum")]),n._v("，"),a("code",[n._v("Paper")]),n._v("，还是其他什么垃圾类型。在对"),a("code",[n._v("add()")]),n._v("的调用过程中，这种信息是通过"),a("code",[n._v("this")]),n._v("的类型传递的。编译器会分析出对"),a("code",[n._v("add()")]),n._v("正确的重载版本的调用。但由于"),a("code",[n._v("tb[i]")]),n._v("会产生指向基类型"),a("code",[n._v("TypeBin")]),n._v("的一个引用，所以最终会调用一个不同的方法——具体什么方法取决于当前选择的"),a("code",[n._v("TypeBin")]),n._v("的类型。那就是第二次分发。")]),n._v(" "),a("p",[n._v("下面是"),a("code",[n._v("TypeBin")]),n._v("的基类：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//: TypedBin.java\n// Vector that knows how to grab the right type\npackage c16.doubledispatch;\nimport c16.trash.*;\nimport java.util.*;\n\npublic abstract class TypedBin {\n  Vector v = new Vector();\n  protected boolean addIt(Trash t) {\n    v.addElement(t);\n    return true;\n  }\n  public Enumeration elements() {\n    return v.elements();\n  }\n  public boolean add(DDAluminum a) {\n    return false;\n  }\n  public boolean add(DDPaper a) {\n    return false;\n  }\n  public boolean add(DDGlass a) {\n    return false;\n  }\n  public boolean add(DDCardboard a) {\n    return false;\n  }\n} ///:~\n")])])]),a("p",[n._v("可以看到，重载的"),a("code",[n._v("add()")]),n._v("方法全都会返回"),a("code",[n._v("false")]),n._v("。如果未在派生类里对方法进行重载，它就会一直返回"),a("code",[n._v("false")]),n._v("，而且调用者（目前是"),a("code",[n._v("addToBin()")]),n._v("）会认为当前"),a("code",[n._v("Trash")]),n._v("对象尚未成功加入一个集合，所以会继续查找正确的集合。")]),n._v(" "),a("p",[n._v("在"),a("code",[n._v("TypeBin")]),n._v("的每一个子类中，都只有一个重载的方法会被重载——具体取决于准备创建的是什么垃圾筒类型。举个例子来说，"),a("code",[n._v("CardboardBin")]),n._v("会重载"),a("code",[n._v("add(DDCardboard)")]),n._v("。重载的方法会将垃圾对象加入它的集合，并返回"),a("code",[n._v("true")]),n._v("。而"),a("code",[n._v("CardboardBin")]),n._v("中剩余的所有"),a("code",[n._v("add()")]),n._v("方法都会继续返回"),a("code",[n._v("false")]),n._v("，因为它们尚未重载。事实上，假如在这里采用了参数化类型机制，Java代码的自动创建就要方便得多（使用C++的“模板”，我们不必费事地为子类编码，或者将"),a("code",[n._v("addToBin()")]),n._v("方法置入"),a("code",[n._v("Trash")]),n._v("里；Java在这方面尚有待改进）。")]),n._v(" "),a("p",[n._v("由于对这个例子来说，垃圾的类型已经定制并置入一个不同的目录，所以需要用一个不同的垃圾数据文件令其运转起来。下面是一个示范性的"),a("code",[n._v("DDTrash.dat")]),n._v("：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("c16.DoubleDispatch.DDGlass:54\nc16.DoubleDispatch.DDPaper:22\nc16.DoubleDispatch.DDPaper:11\nc16.DoubleDispatch.DDGlass:17\nc16.DoubleDispatch.DDAluminum:89\nc16.DoubleDispatch.DDPaper:88\nc16.DoubleDispatch.DDAluminum:76\nc16.DoubleDispatch.DDCardboard:96\nc16.DoubleDispatch.DDAluminum:25\nc16.DoubleDispatch.DDAluminum:34\nc16.DoubleDispatch.DDGlass:11\nc16.DoubleDispatch.DDGlass:68\nc16.DoubleDispatch.DDGlass:43\nc16.DoubleDispatch.DDAluminum:27\nc16.DoubleDispatch.DDCardboard:44\nc16.DoubleDispatch.DDAluminum:18\nc16.DoubleDispatch.DDPaper:91\nc16.DoubleDispatch.DDGlass:63\nc16.DoubleDispatch.DDGlass:50\nc16.DoubleDispatch.DDGlass:80\nc16.DoubleDispatch.DDAluminum:81\nc16.DoubleDispatch.DDCardboard:12\nc16.DoubleDispatch.DDGlass:12\nc16.DoubleDispatch.DDGlass:54\nc16.DoubleDispatch.DDAluminum:36\nc16.DoubleDispatch.DDAluminum:93\nc16.DoubleDispatch.DDGlass:93\nc16.DoubleDispatch.DDPaper:80\nc16.DoubleDispatch.DDGlass:36\nc16.DoubleDispatch.DDGlass:12\nc16.DoubleDispatch.DDGlass:60\nc16.DoubleDispatch.DDPaper:66\nc16.DoubleDispatch.DDAluminum:36\nc16.DoubleDispatch.DDCardboard:22\n")])])]),a("p",[n._v("下面列出程序剩余的部分：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//: DoubleDispatch.java\n// Using multiple dispatching to handle more\n// than one unknown type during a method call.\npackage c16.doubledispatch;\nimport c16.trash.*;\nimport java.util.*;\n\nclass AluminumBin extends TypedBin {\n  public boolean add(DDAluminum a) {\n    return addIt(a);\n  }\n}\n\nclass PaperBin extends TypedBin {\n  public boolean add(DDPaper a) {\n    return addIt(a);\n  }\n}\n\nclass GlassBin extends TypedBin {\n  public boolean add(DDGlass a) {\n    return addIt(a);\n  }\n}\n\nclass CardboardBin extends TypedBin {\n  public boolean add(DDCardboard a) {\n    return addIt(a);\n  }\n}\n\nclass TrashBinSet {\n  private TypedBin[] binSet = {\n    new AluminumBin(),\n    new PaperBin(),\n    new GlassBin(),\n    new CardboardBin()\n  };\n  public void sortIntoBins(Vector bin) {\n    Enumeration e = bin.elements();\n    while(e.hasMoreElements()) {\n      TypedBinMember t =\n        (TypedBinMember)e.nextElement();\n      if(!t.addToBin(binSet))\n        System.err.println("Couldn\'t add " + t);\n    }\n  }\n  public TypedBin[] binSet() { return binSet; }\n}\n\npublic class DoubleDispatch {\n  public static void main(String[] args) {\n    Vector bin = new Vector();\n    TrashBinSet bins = new TrashBinSet();\n    // ParseTrash still works, without changes:\n    ParseTrash.fillBin("DDTrash.dat", bin);\n    // Sort from the master bin into the\n    // individually-typed bins:\n    bins.sortIntoBins(bin);\n    TypedBin[] tb = bins.binSet();\n    // Perform sumValue for each bin...\n    for(int i = 0; i < tb.length; i++)\n      Trash.sumValue(tb[i].v);\n    // ... and for the master bin\n    Trash.sumValue(bin);\n  }\n} ///:~\n')])])]),a("p",[n._v("其中，"),a("code",[n._v("TrashBinSet")]),n._v("封装了各种不同类型的"),a("code",[n._v("TypeBin")]),n._v("，同时还有"),a("code",[n._v("sortIntoBins()")]),n._v("方法。所有双重分发事件都会在那个方法里发生。可以看到，一旦设置好结构，再归类成各种"),a("code",[n._v("TypeBin")]),n._v("的工作就变得十分简单了。除此以外，两个动态方法调用的效率可能也比其他排序方法高一些。")]),n._v(" "),a("p",[n._v("注意这个系统的方便性主要体现在"),a("code",[n._v("main()")]),n._v("中，同时还要注意到任何特定的类型信息在"),a("code",[n._v("main()")]),n._v("中都是完全独立的。只与"),a("code",[n._v("Trash")]),n._v("基类接口通信的其他所有方法都不会受到"),a("code",[n._v("Trash")]),n._v("类中发生的改变的干扰。")]),n._v(" "),a("p",[n._v("添加新类型需要作出的改动是完全孤立的：我们随同"),a("code",[n._v("addToBin()")]),n._v("方法继承"),a("code",[n._v("Trash")]),n._v("的新类型，然后继承一个新的"),a("code",[n._v("TypeBin")]),n._v("（这实际只是一个副本，可以简单地编辑），最后将一种新类型加入"),a("code",[n._v("TrashBinSet")]),n._v("的集合初化化过程。")])])}),[],!1,null,null,null);e.default=i.exports}}]);