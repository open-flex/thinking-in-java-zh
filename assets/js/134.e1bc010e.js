(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{530:function(e,v,c){"use strict";c.r(v);var a=c(56),t=Object(a.a)({},(function(){var e=this,v=e.$createElement,c=e._self._c||v;return c("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[c("h1",{attrs:{id:"_5-4-类访问"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-类访问"}},[e._v("#")]),e._v(" 5.4 类访问")]),e._v(" "),c("p",[e._v("在Java中，亦可用访问指示符判断出一个库内的哪些类可由那个库的用户使用。若想一个类能由客户程序员调用，可在类主体的起始花括号前面某处放置一个"),c("code",[e._v("public")]),e._v("关键字。它控制着客户程序员是否能够创建属于这个类的一个对象。")]),e._v(" "),c("p",[e._v("为控制一个类的访问，指示符必须在关键字"),c("code",[e._v("class")]),e._v("之前出现。所以我们能够使用：")]),e._v(" "),c("div",{staticClass:"language- extra-class"},[c("pre",{pre:!0,attrs:{class:"language-text"}},[c("code",[e._v("public class Widget {\n")])])]),c("p",[e._v("也就是说，假若我们的库名是"),c("code",[e._v("mylib")]),e._v("，那么所有客户程序员都能访问"),c("code",[e._v("Widget")]),e._v("——通过下述语句：")]),e._v(" "),c("div",{staticClass:"language- extra-class"},[c("pre",{pre:!0,attrs:{class:"language-text"}},[c("code",[e._v("import mylib.Widget;\n")])])]),c("p",[e._v("或者")]),e._v(" "),c("div",{staticClass:"language- extra-class"},[c("pre",{pre:!0,attrs:{class:"language-text"}},[c("code",[e._v("import mylib.*;\n")])])]),c("p",[e._v("然而，我们同时还要注意到一些额外的限制：")]),e._v(" "),c("p",[e._v("(1) 每个编译单元（文件）都只能有一个"),c("code",[e._v("public")]),e._v("类。每个编译单元有一个公共接口的概念是由那个公共类表达出来的。根据自己的需要，它可拥有任意多个提供支撑的“友好”类。但若在一个编译单元里使用了多个"),c("code",[e._v("public")]),e._v("类，编译器就会向我们提示一条出错消息。")]),e._v(" "),c("p",[e._v("(2) "),c("code",[e._v("public")]),e._v("类的名字必须与包含了编译单元的那个文件的名字完全相符，甚至包括它的大小写形式。所以对于"),c("code",[e._v("Widget")]),e._v("来说，文件的名字必须是"),c("code",[e._v("Widget.java")]),e._v("，而不应是"),c("code",[e._v("widget.java")]),e._v("或者"),c("code",[e._v("WIDGET.java")]),e._v("。同样地，如果出现不符，就会报告一个编译期错误。")]),e._v(" "),c("p",[e._v("(3) 可能（但并常见）有一个编译单元根本没有任何公共类。此时，可按自己的意愿任意指定文件名。")]),e._v(" "),c("p",[e._v("如果已经获得了"),c("code",[e._v("mylib")]),e._v("内部的一个类，准备用它完成由"),c("code",[e._v("Widget")]),e._v("或者"),c("code",[e._v("mylib")]),e._v("内部的其他某些"),c("code",[e._v("public")]),e._v("类执行的任务，此时又会出现什么情况呢？我们不希望花费力气为客户程序员编制文档，并感觉以后某个时候也许会进行大手笔的修改，并将自己的类一起删掉，换成另一个不同的类。为获得这种灵活处理的能力，需要保证没有客户程序员能够依赖自己隐藏于"),c("code",[e._v("mylib")]),e._v("内部的特定实现细节。为达到这个目的，只需将"),c("code",[e._v("public")]),e._v("关键字从类中剔除即可，这样便把类变成了“友好的”（类仅能在包内使用）。")]),e._v(" "),c("p",[e._v("注意不可将类设成"),c("code",[e._v("private")]),e._v("（那样会使除类之外的其他东西都不能访问它），也不能设成"),c("code",[e._v("protected")]),e._v("（注释④）。因此，我们现在对于类的访问只有两个选择：“友好的”或者"),c("code",[e._v("public")]),e._v("。若不愿其他任何人访问那个类，可将所有构造器设为"),c("code",[e._v("private")]),e._v("。这样一来，在类的一个"),c("code",[e._v("static")]),e._v("成员内部，除自己之外的其他所有人都无法创建属于那个类的一个对象（注释⑤）。如下例所示：")]),e._v(" "),c("div",{staticClass:"language- extra-class"},[c("pre",{pre:!0,attrs:{class:"language-text"}},[c("code",[e._v('//: Lunch.java\n// Demonstrates class access specifiers.\n// Make a class effectively private\n// with private constructors:\n\nclass Soup {\n  private Soup() {}\n  // (1) Allow creation via static method:\n  public static Soup makeSoup() {\n    return new Soup();\n  }\n  // (2) Create a static object and\n  // return a reference upon request.\n  // (The "Singleton" pattern):\n  private static Soup ps1 = new Soup();\n  public static Soup access() {\n    return ps1;\n  }\n  public void f() {}\n}\n\nclass Sandwich { // Uses Lunch\n  void f() { new Lunch(); }\n}\n\n// Only one public class allowed per file:\npublic class Lunch {\n  void test() {\n    // Can\'t do this! Private constructor:\n    //! Soup priv1 = new Soup();\n    Soup priv2 = Soup.makeSoup();\n    Sandwich f1 = new Sandwich();\n    Soup.access().f();\n  }\n} ///:~\n')])])]),c("p",[e._v("④：实际上，Java 1.1内部类既可以是“受到保护的”，也可以是“私有的”，但那属于特别情况。第7章会详细解释这个问题。")]),e._v(" "),c("p",[e._v("⑤：亦可通过从那个类继承来实现。")]),e._v(" "),c("p",[e._v("迄今为止，我们创建过的大多数方法都是要么返回void，要么返回一个基本数据类型。所以对下述定义来说：")]),e._v(" "),c("div",{staticClass:"language- extra-class"},[c("pre",{pre:!0,attrs:{class:"language-text"}},[c("code",[e._v("public static Soup access() {\nreturn psl;\n}\n")])])]),c("p",[e._v("它最开始多少会使人有些迷惑。位于方法名（"),c("code",[e._v("access")]),e._v("）前的单词指出方法到底返回什么。在这之前，我们看到的都是"),c("code",[e._v("void")]),e._v("，它意味着“什么也不返回”（"),c("code",[e._v("void")]),e._v("在英语里是“虚无”的意思。但亦可返回指向一个对象的引用，此时出现的就是这个情况。该方法返回一个引用，它指向类"),c("code",[e._v("Soup")]),e._v("的一个对象。")]),e._v(" "),c("p",[c("code",[e._v("Soup")]),e._v("类向我们展示出如何通过将所有构造器都设为"),c("code",[e._v("private")]),e._v("，从而防止直接创建一个类。请记住，假若不明确地至少创建一个构造器，就会自动创建默认构造器（没有参数）。若自己编写默认构造器，它就不会自动创建。把它变成"),c("code",[e._v("private")]),e._v("后，就没人能为那个类创建一个对象。但别人怎样使用这个类呢？上面的例子为我们揭示出了两个选择。第一个选择，我们可创建一个"),c("code",[e._v("static")]),e._v("方法，再通过它创建一个新的"),c("code",[e._v("Soup")]),e._v("，然后返回指向它的一个引用。如果想在返回之前对"),c("code",[e._v("Soup")]),e._v("进行一些额外的操作，或者想了解准备创建多少个"),c("code",[e._v("Soup")]),e._v("对象（可能是为了限制它们的个数），这种方案无疑是特别有用的。")]),e._v(" "),c("p",[e._v("第二个选择是采用“设计模式”（Design Pattern）技术，本书后面会对此进行详细介绍。通常方案叫作“单例”，因为它仅允许创建一个对象。类"),c("code",[e._v("Soup")]),e._v("的对象被创建成"),c("code",[e._v("Soup")]),e._v("的一个"),c("code",[e._v("static private")]),e._v("成员，所以有一个而且只能有一个。除非通过"),c("code",[e._v("public")]),e._v("方法"),c("code",[e._v("access()")]),e._v("，否则根本无法访问它。")]),e._v(" "),c("p",[e._v("正如早先指出的那样，如果不针对类的访问设置一个访问指示符，那么它会自动默认为“友好的”。这意味着那个类的对象可由包内的其他类创建，但不能由包外创建。请记住，对于相同目录内的所有文件，如果没有明确地进行"),c("code",[e._v("package")]),e._v("声明，那么它们都默认为那个目录的默认包的一部分。然而，假若那个类一个"),c("code",[e._v("static")]),e._v("成员的属性是"),c("code",[e._v("public")]),e._v("，那么客户程序员仍然能够访问那个"),c("code",[e._v("static")]),e._v("成员——即使它们不能创建属于那个类的一个对象。")])])}),[],!1,null,null,null);v.default=t.exports}}]);