(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{508:function(a,t,e){"use strict";e.r(t);var v=e(56),n=Object(v.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"_2-3-绝对不要清除对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-绝对不要清除对象"}},[a._v("#")]),a._v(" 2.3 绝对不要清除对象")]),a._v(" "),e("p",[a._v("在大多数程序设计语言中，变量的“存在时间”（Lifetime）一直是程序员需要着重考虑的问题。变量应持续多长的时间？如果想清除它，那么何时进行？在变量存在时间上纠缠不清会造成大量的程序错误。在下面的小节里，将阐示Java如何帮助我们完成所有清除工作，从而极大了简化了这个问题。")]),a._v(" "),e("h2",{attrs:{id:"_2-3-1-作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-作用域"}},[a._v("#")]),a._v(" 2.3.1 作用域")]),a._v(" "),e("p",[a._v("大多数程序设计语言都提供了“作用域”（Scope）的概念。对于在作用域里定义的名字，作用域同时决定了它的“可见性”以及“存在时间”。在C，C++和Java里，作用域是由花括号的位置决定的。参考下面这个例子：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("{\n  int x = 12;\n  /* only x available */\n  {\n    int q = 96;\n    /* both x & q available */\n  }\n  /* only x available */\n  /* q “out of scope” */\n}\n")])])]),e("p",[a._v("作为在作用域里定义的一个变量，它只有在那个作用域结束之前才可使用。")]),a._v(" "),e("p",[a._v("在上面的例子中，缩进排版使Java代码更易辨读。由于Java是一种形式自由的语言，所以额外的空格、制表位以及回车都不会对结果程序造成影响。")]),a._v(" "),e("p",[a._v("注意尽管在C和C++里是合法的，但在Java里不能象下面这样书写代码：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("{\n  int x = 12;\n  {\n    int x = 96; /* illegal */\n  }\n}\n")])])]),e("p",[a._v("编译器会认为变量"),e("code",[a._v("x")]),a._v("已被定义。所以C和C++能将一个变量“隐藏”在一个更大的作用域里。但这种做法在Java里是不允许的，因为Java的设计者认为这样做使程序产生了混淆。")]),a._v(" "),e("h2",{attrs:{id:"_2-3-2-对象的作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-对象的作用域"}},[a._v("#")]),a._v(" 2.3.2 对象的作用域")]),a._v(" "),e("p",[a._v("Java对象不具备与基本类型一样的存在时间。用"),e("code",[a._v("new")]),a._v("关键字创建一个Java对象的时候，它会超出作用域的范围之外。所以假若使用下面这段代码：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('{\nString s = new String("a string");\n} /* 作用域的终点 */\n')])])]),e("p",[a._v("那么引用"),e("code",[a._v("s")]),a._v("会在作用域的终点处消失。然而，"),e("code",[a._v("s")]),a._v("指向的"),e("code",[a._v("String")]),a._v("对象依然占据着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一个引用已超出了作用域的边界。在后面的章节里，大家还会继续学习如何在程序运行期间传递和复制对象引用。")]),a._v(" "),e("p",[a._v("这样造成的结果便是：对于用"),e("code",[a._v("new")]),a._v("创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在C和C++里特别突出。看来在C++里遇到的麻烦最大：由于不能从语言获得任何帮助，所以在需要对象的时候，根本无法确定它们是否可用。而且更麻烦的是，在C++里，一旦工作完成，必须保证将对象清除。")]),a._v(" "),e("p",[a._v("这样便带来了一个有趣的问题。假如Java让对象依然故我，怎样才能防止它们大量充斥内存，并最终造成程序的“凝固”呢。在C++里，这个问题最令程序员头痛。但Java以后，情况却发生了改观。Java有一个特别的“垃圾收集器”，它会查找用new创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。这样做可防止在C++里很常见的一个编程问题：由于程序员忘记释放内存造成的“内存溢出”。")])])}),[],!1,null,null,null);t.default=n.exports}}]);