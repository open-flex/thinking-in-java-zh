(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{538:function(e,n,t){"use strict";t.r(n);var a=t(56),v=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_6-2-继承的语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-继承的语法"}},[e._v("#")]),e._v(" 6.2 继承的语法")]),e._v(" "),t("p",[e._v("继承与Java（以及其他OOP语言）非常紧密地结合在一起。我们早在第1章就为大家引入了继承的概念，并在那章之后到本章之前的各章里不时用到，因为一些特殊的场合要求必须使用继承。除此以外，创建一个类时肯定会进行继承，因为若非如此，会从Java的标准根类"),t("code",[e._v("Object")]),e._v("中继承。")]),e._v(" "),t("p",[e._v("用于组合的语法是非常简单且直观的。但为了进行继承，必须采用一种全然不同的形式。需要继承的时候，我们会说：“这个新类和那个旧类差不多。”为了在代码里表面这一观念，需要给出类名。但在类主体的起始花括号之前，需要放置一个关键字"),t("code",[e._v("extends")]),e._v("，在后面跟随“基类”的名字。若采取这种做法，就可自动获得基类的所有数据成员以及方法。下面是一个例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Detergent.java\n// Inheritance syntax & properties\n\nclass Cleanser {\n  private String s = new String("Cleanser");\n  public void append(String a) { s += a; }\n  public void dilute() { append(" dilute()"); }\n  public void apply() { append(" apply()"); }\n  public void scrub() { append(" scrub()"); }\n  public void print() { System.out.println(s); }\n  public static void main(String[] args) {\n    Cleanser x = new Cleanser();\n    x.dilute(); x.apply(); x.scrub();\n    x.print();\n  }\n}\n\npublic class Detergent extends Cleanser {\n  // Change a method:\n  public void scrub() {\n    append(" Detergent.scrub()");\n    super.scrub(); // Call base-class version\n  }\n  // Add methods to the interface:\n  public void foam() { append(" foam()"); }\n  // Test the new class:\n  public static void main(String[] args) {\n    Detergent x = new Detergent();\n    x.dilute();\n    x.apply();\n    x.scrub();\n    x.foam();\n    x.print();\n    System.out.println("Testing base class:");\n    Cleanser.main(args);\n  }\n} ///:~\n')])])]),t("p",[e._v("这个例子向大家展示了大量特性。首先，在"),t("code",[e._v("Cleanser append()")]),e._v("方法里，字符串同一个"),t("code",[e._v("s")]),e._v("连接起来。这是用"),t("code",[e._v("+=")]),e._v("运算符实现的。同"),t("code",[e._v("+")]),e._v("一样，"),t("code",[e._v("+=")]),e._v("被Java用于对字符串进行“重载”处理。")]),e._v(" "),t("p",[e._v("其次，无论"),t("code",[e._v("Cleanser")]),e._v("还是"),t("code",[e._v("Detergent")]),e._v("都包含了一个"),t("code",[e._v("main()")]),e._v("方法。我们可为自己的每个类都创建一个"),t("code",[e._v("main()")]),e._v("。通常建议大家象这样进行编写代码，使自己的测试代码能够封装到类内。即便在程序中含有数量众多的类，但对于在命令行请求的"),t("code",[e._v("public")]),e._v("类，只有"),t("code",[e._v("main()")]),e._v("才会得到调用。所以在这种情况下，当我们使用"),t("code",[e._v("java Detergent")]),e._v("的时候，调用的是"),t("code",[e._v("Degergent.main()")]),e._v("——即使"),t("code",[e._v("Cleanser")]),e._v("并非一个"),t("code",[e._v("public")]),e._v("类。采用这种将"),t("code",[e._v("main()")]),e._v("置入每个类的做法，可方便地为每个类都进行单元测试。而且在完成测试以后，毋需将"),t("code",[e._v("main()")]),e._v("删去；可把它保留下来，用于以后的测试。")]),e._v(" "),t("p",[e._v("在这里，大家可看到"),t("code",[e._v("Deteregent.main()")]),e._v("对"),t("code",[e._v("Cleanser.main()")]),e._v("的调用是明确进行的。")]),e._v(" "),t("p",[e._v("需要着重强调的是"),t("code",[e._v("Cleanser")]),e._v("中的所有类都是"),t("code",[e._v("public")]),e._v("属性。请记住，倘若省略所有访问指示符，则成员默认为“友好的”。这样一来，就只允许对包成员进行访问。在这个包内，任何人都可使用那些没有访问指示符的方法。例如，"),t("code",[e._v("Detergent")]),e._v("将不会遇到任何麻烦。然而，假设来自另外某个包的类准备继承"),t("code",[e._v("Cleanser")]),e._v("，它就只能访问那些"),t("code",[e._v("public")]),e._v("成员。所以在计划继承的时候，一个比较好的规则是将所有字段都设为"),t("code",[e._v("private")]),e._v("，并将所有方法都设为"),t("code",[e._v("public")]),e._v("（"),t("code",[e._v("protected")]),e._v("成员也允许派生出来的类访问它；以后还会深入探讨这一问题）。当然，在一些特殊的场合，我们仍然必须作出一些调整，但这并不是一个好的做法。")]),e._v(" "),t("p",[e._v("注意"),t("code",[e._v("Cleanser")]),e._v("在它的接口中含有一系列方法："),t("code",[e._v("append()")]),e._v("，"),t("code",[e._v("dilute()")]),e._v("，"),t("code",[e._v("apply()")]),e._v("，"),t("code",[e._v("scrub()")]),e._v("以及"),t("code",[e._v("print()")]),e._v("。由于"),t("code",[e._v("Detergent")]),e._v("是从"),t("code",[e._v("Cleanser")]),e._v("派生出来的（通过"),t("code",[e._v("extends")]),e._v("关键字），所以它会自动获得接口内的所有这些方法——即使我们在"),t("code",[e._v("Detergent")]),e._v("里并未看到对它们的明确定义。这样一来，就可将继承想象成“对接口的重复利用”或者“接口的复用”（以后的实现细节可以自由设置，但那并非我们强调的重点）。")]),e._v(" "),t("p",[e._v("正如在"),t("code",[e._v("scrub()")]),e._v("里看到的那样，可以获得在基类里定义的一个方法，并对其进行修改。在这种情况下，我们通常想在新版本里调用来自基类的方法。但在"),t("code",[e._v("scrub()")]),e._v("里，不可只是简单地发出对"),t("code",[e._v("scrub()")]),e._v("的调用。那样便造成了递归调用，我们不愿看到这一情况。为解决这个问题，Java提供了一个"),t("code",[e._v("super")]),e._v("关键字，它引用当前类已从中继承的一个“超类”（Superclass）。所以表达式"),t("code",[e._v("super.scrub()")]),e._v("调用的是方法"),t("code",[e._v("scrub()")]),e._v("的基类版本。")]),e._v(" "),t("p",[e._v("进行继承时，我们并不限于只能使用基类的方法。亦可在派生出来的类里加入自己的新方法。这时采取的做法与在普通类里添加其他任何方法是完全一样的：只需简单地定义它即可。"),t("code",[e._v("extends")]),e._v("关键字提醒我们准备将新方法加入基类的接口里，对其进行“扩展”。"),t("code",[e._v("foam()")]),e._v("便是这种做法的一个产物。")]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("Detergent.main()")]),e._v("里，我们可看到对于"),t("code",[e._v("Detergent")]),e._v("对象，可调用"),t("code",[e._v("Cleanser")]),e._v("以及"),t("code",[e._v("Detergent")]),e._v("内所有可用的方法（如"),t("code",[e._v("foam()")]),e._v("）。")]),e._v(" "),t("h2",{attrs:{id:"_6-2-1-初始化基类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-1-初始化基类"}},[e._v("#")]),e._v(" 6.2.1 初始化基类")]),e._v(" "),t("p",[e._v("由于这儿涉及到两个类——基类及派生类，而不再是以前的一个，所以在想象派生类的结果对象时，可能会产生一些迷惑。从外部看，似乎新类拥有与基类相同的接口，而且可包含一些额外的方法和字段。但继承并非仅仅简单地复制基类的接口了事。创建派生类的一个对象时，它在其中包含了基类的一个“子对象”。这个子对象就象我们根据基类本身创建了它的一个对象。从外部看，基类的子对象已封装到派生类的对象里了。")]),e._v(" "),t("p",[e._v("当然，基类子对象应该正确地初始化，而且只有一种方法能保证这一点：在构造器中执行初始化，通过调用基类构造器，后者有足够的能力和权限来执行对基类的初始化。在派生类的构造器中，Java会自动插入对基类构造器的调用。下面这个例子向大家展示了对这种三级继承的应用：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Cartoon.java\n// Constructor calls during inheritance\n\nclass Art {\n  Art() {\n    System.out.println("Art constructor");\n  }\n}\n\nclass Drawing extends Art {\n  Drawing() {\n    System.out.println("Drawing constructor");\n  }\n}\n\npublic class Cartoon extends Drawing {\n  Cartoon() {\n    System.out.println("Cartoon constructor");\n  }\n  public static void main(String[] args) {\n    Cartoon x = new Cartoon();\n  }\n} ///:~\n')])])]),t("p",[e._v("该程序的输出显示了自动调用：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Art constructor\nDrawing constructor\nCartoon constructor\n")])])]),t("p",[e._v("可以看出，构建是在基类的“外部”进行的，所以基类会在派生类访问它之前得到正确的初始化。\n即使没有为"),t("code",[e._v("Cartoon()")]),e._v("创建一个构造器，编译器也会为我们自动生成一个默认构造器，并发出对基类构造器的调用。")]),e._v(" "),t("p",[e._v("(1) 含有参数的构造器")]),e._v(" "),t("p",[e._v("上述例子有自己默认的构造器；也就是说，它们不含任何参数。编译器可以很容易地调用它们，因为不存在具体传递什么参数的问题。如果类没有默认的参数，或者想调用含有一个参数的某个基类构造器，必须明确地编写对基类的调用代码。这是用"),t("code",[e._v("super")]),e._v("关键字以及适当的参数列表实现的，如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//: Chess.java\n// Inheritance, constructors and arguments\n\nclass Game {\n  Game(int i) {\n    System.out.println("Game constructor");\n  }\n}\n\nclass BoardGame extends Game {\n  BoardGame(int i) {\n    super(i);\n    System.out.println("BoardGame constructor");\n  }\n}\n\npublic class Chess extends BoardGame {\n  Chess() {\n    super(11);\n    System.out.println("Chess constructor");\n  }\n  public static void main(String[] args) {\n    Chess x = new Chess();\n  }\n} ///:~\n')])])]),t("p",[e._v("如果不调用"),t("code",[e._v("BoardGames()")]),e._v("内的基类构造器，编译器就会报告自己找不到"),t("code",[e._v("Games()")]),e._v("形式的一个构造器。除此以外，在派生类构造器中，对基类构造器的调用是必须做的第一件事情（如操作失当，编译器会向我们指出）。")]),e._v(" "),t("p",[e._v("(2) 捕获基本构造器的异常")]),e._v(" "),t("p",[e._v("正如刚才指出的那样，编译器会强迫我们在派生类构造器的主体中首先设置对基类构造器的调用。这意味着在它之前不能出现任何东西。正如大家在第9章会看到的那样，这同时也会防止派生类构造器捕获来自一个基类的任何异常事件。显然，这有时会为我们造成不便。")])])}),[],!1,null,null,null);n.default=v.exports}}]);