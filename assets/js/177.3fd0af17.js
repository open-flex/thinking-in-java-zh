(window.webpackJsonp=window.webpackJsonp||[]).push([[177],{572:function(n,t,a){"use strict";a.r(t);var e=a(56),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"_9-6-用finally清除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-6-用finally清除"}},[n._v("#")]),n._v(" 9.6 用finally清除")]),n._v(" "),a("p",[n._v("无论一个异常是否在"),a("code",[n._v("try")]),n._v("块中发生，我们经常都想执行一些特定的代码。对一些特定的操作，经常都会遇到这种情况，但在恢复内存时一般都不需要（因为垃圾收集器会自动照料一切）。为达到这个目的，可在所有异常控制器的末尾使用一个"),a("code",[n._v("finally")]),n._v("从句（注释④）。所以完整的异常控制小节象下面这个样子：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("try {\n// 要保卫的区域：\n// 可能“抛”出A,B,或C的危险情况\n} catch (A a1) {\n// 控制器 A\n} catch (B b1) {\n// 控制器 B\n} catch (C c1) {\n// 控制器 C\n} finally {\n// 每次都会发生的情况\n}\n")])])]),a("p",[n._v("④：C++异常控制未提供"),a("code",[n._v("finally")]),n._v("从句，因为它依赖构造器来达到这种清除效果。")]),n._v(" "),a("p",[n._v("为演示"),a("code",[n._v("finally")]),n._v("从句，请试验下面这个程序：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//: FinallyWorks.java\n// The finally clause is always executed\n\npublic class FinallyWorks {\n  static int count = 0;\n  public static void main(String[] args) {\n    while(true) {\n      try {\n        // post-increment is zero first time:\n        if(count++ == 0)\n          throw new Exception();\n        System.out.println("No exception");\n      } catch(Exception e) {\n        System.out.println("Exception thrown");\n      } finally {\n        System.out.println("in finally clause");\n        if(count == 2) break; // out of "while"\n      }\n    }\n  }\n} ///:~\n')])])]),a("p",[n._v("通过该程序，我们亦可知道如何应付Java异常（类似C++的异常）不允许我们恢复至异常产生地方的这一事实。若将自己的"),a("code",[n._v("try")]),n._v("块置入一个循环内，就可建立一个条件，它必须在继续程序之前满足。亦可添加一个"),a("code",[n._v("static")]),n._v("计数器或者另一些设备，允许循环在放弃以前尝试数种不同的方法。这样一来，我们的程序可以变得更加“健壮”。")]),n._v(" "),a("p",[n._v("输出如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Exception thrown\nin finally clause\nNo exception\nin finally clause\n")])])]),a("p",[n._v("无论是否“抛”出一个异常，"),a("code",[n._v("finally")]),n._v("从句都会执行。")]),n._v(" "),a("h2",{attrs:{id:"_9-6-1-用finally做什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-6-1-用finally做什么"}},[n._v("#")]),n._v(" 9.6.1 用"),a("code",[n._v("finally")]),n._v("做什么")]),n._v(" "),a("p",[n._v("在没有“垃圾收集”以及“自动调用析构器”机制的一种语言中（注释⑤），"),a("code",[n._v("finally")]),n._v("显得特别重要，因为程序员可用它担保内存的正确释放——无论在"),a("code",[n._v("try")]),n._v("块内部发生了什么状况。但Java提供了垃圾收集机制，所以内存的释放几乎绝对不会成为问题。另外，它也没有构造器可供调用。既然如此，Java里何时才会用到"),a("code",[n._v("finally")]),n._v("呢？")]),n._v(" "),a("p",[n._v("⑤：“析构器”（Destructor）是“构造器”（Constructor）的反义词。它代表一个特殊的函数，一旦某个对象失去用处，通常就会调用它。我们肯定知道在哪里以及何时调用析构器。C++提供了自动的析构器调用机制，但Delphi的Object Pascal版本1及2却不具备这一能力（在这种语言中，析构器的含义与用法都发生了变化）。")]),n._v(" "),a("p",[n._v("除将内存设回原始状态以外，若要设置另一些东西，"),a("code",[n._v("finally")]),n._v("就是必需的。例如，我们有时需要打开一个文件或者建立一个网络连接，或者在屏幕上画一些东西，甚至设置外部世界的一个开关，等等。如下例所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//: OnOffSwitch.java\n// Why use finally?\n\nclass Switch {\n  boolean state = false;\n  boolean read() { return state; }\n  void on() { state = true; }\n  void off() { state = false; }\n}\n\npublic class OnOffSwitch {\n  static Switch sw = new Switch();\n  public static void main(String[] args) {\n    try {\n      sw.on();\n      // Code that can throw exceptions...\n      sw.off();\n    } catch(NullPointerException e) {\n      System.out.println("NullPointerException");\n      sw.off();\n    } catch(IllegalArgumentException e) {\n      System.out.println("IOException");\n      sw.off();\n    }\n  }\n} ///:~\n')])])]),a("p",[n._v("这里的目标是保证"),a("code",[n._v("main()")]),n._v("完成时开关处于关闭状态，所以将"),a("code",[n._v("sw.off()")]),n._v("置于"),a("code",[n._v("try")]),n._v("块以及每个异常控制器的末尾。但产生的一个异常有可能不是在这里捕获的，这便会错过"),a("code",[n._v("sw.off()")]),n._v("。然而，利用"),a("code",[n._v("finally")]),n._v("，我们可以将来自"),a("code",[n._v("try")]),n._v("块的关闭代码只置于一个地方：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//: WithFinally.java\n// Finally Guarantees cleanup\n\nclass Switch2 {\n  boolean state = false;\n  boolean read() { return state; }\n  void on() { state = true; }\n  void off() { state = false; }\n}\n\npublic class WithFinally {\n  static Switch2 sw = new Switch2();\n  public static void main(String[] args) {\n    try {\n      sw.on();\n      // Code that can throw exceptions...\n    } catch(NullPointerException e) {\n      System.out.println("NullPointerException");\n    } catch(IllegalArgumentException e) {\n      System.out.println("IOException");\n    } finally {\n      sw.off();\n    }\n  }\n} ///:~\n')])])]),a("p",[n._v("在这儿，"),a("code",[n._v("sw.off()")]),n._v("已移至一个地方。无论发生什么事情，都肯定会运行它。")]),n._v(" "),a("p",[n._v("即使异常不在当前的"),a("code",[n._v("catch")]),n._v("从句集里捕获，"),a("code",[n._v("finally")]),n._v("都会在异常控制机制转到更高级别搜索一个控制器之前得以执行。如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//: AlwaysFinally.java\n// Finally is always executed\n\nclass Ex extends Exception {}\n\npublic class AlwaysFinally {\n  public static void main(String[] args) {\n    System.out.println(\n      "Entering first try block");\n    try {\n      System.out.println(\n        "Entering second try block");\n      try {\n        throw new Ex();\n      } finally {\n        System.out.println(\n          "finally in 2nd try block");\n      }\n    } catch(Ex e) {\n      System.out.println(\n        "Caught Ex in first try block");\n    } finally {\n      System.out.println(\n        "finally in 1st try block");\n    }\n  }\n} ///:~\n')])])]),a("p",[n._v("该程序的输出展示了具体发生的事情：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Entering first try block\nEntering second try block\nfinally in 2nd try block\nCaught Ex in first try block\nfinally in 1st try block\n")])])]),a("p",[n._v("若调用了"),a("code",[n._v("break")]),n._v("和"),a("code",[n._v("continue")]),n._v("语句，"),a("code",[n._v("finally")]),n._v("语句也会得以执行。请注意，与作上标签的"),a("code",[n._v("break")]),n._v("和"),a("code",[n._v("continue")]),n._v("一道，"),a("code",[n._v("finally")]),n._v("排除了Java对"),a("code",[n._v("goto")]),n._v("跳转语句的需求。")]),n._v(" "),a("h2",{attrs:{id:"_9-6-2-缺点-丢失的异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-6-2-缺点-丢失的异常"}},[n._v("#")]),n._v(" 9.6.2 缺点：丢失的异常")]),n._v(" "),a("p",[n._v("一般情况下，Java的异常实现方案都显得十分出色。不幸的是，它依然存在一个缺点。尽管异常指出程序里存在一个危机，而且绝不应忽略，但一个异常仍有可能简单地“丢失”。在采用"),a("code",[n._v("finally")]),n._v("从句的一种特殊配置下，便有可能发生这种情况：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//: LostMessage.java\n// How an exception can be lost\n\nclass VeryImportantException extends Exception {\n  public String toString() {\n    return "A very important exception!";\n  }\n}\n\nclass HoHumException extends Exception {\n  public String toString() {\n    return "A trivial exception";\n  }\n}\n\npublic class LostMessage {\n  void f() throws VeryImportantException {\n    throw new VeryImportantException();\n  }\n  void dispose() throws HoHumException {\n    throw new HoHumException();\n  }\n  public static void main(String[] args)\n      throws Exception {\n    LostMessage lm = new LostMessage();\n    try {\n      lm.f();\n    } finally {\n      lm.dispose();\n    }\n  }\n} ///:~\n')])])]),a("p",[n._v("输出如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("A trivial exception\n        at LostMessage.dispose(LostMessage.java:21)\n        at LostMessage.main(LostMessage.java:29)\n")])])]),a("p",[n._v("可以看到，这里不存在"),a("code",[n._v("VeryImportantException")]),n._v("（非常重要的异常）的迹象，它只是简单地被"),a("code",[n._v("finally")]),n._v("从句中的"),a("code",[n._v("HoHumException")]),n._v("代替了。")]),n._v(" "),a("p",[n._v("这是一项相当严重的缺陷，因为它意味着一个异常可能完全丢失。而且就象前例演示的那样，这种丢失显得非常“自然”，很难被人查出蛛丝马迹。而与此相反，C++里如果第二个异常在第一个异常得到控制前产生，就会被当作一个严重的编程错误处理。或许Java以后的版本会纠正这个问题（上述结果是用Java 1.1生成的）。")])])}),[],!1,null,null,null);t.default=s.exports}}]);