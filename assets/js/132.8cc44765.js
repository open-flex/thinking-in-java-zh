(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{528:function(e,v,a){"use strict";a.r(v);var _=a(56),t=Object(_.a)({},(function(){var e=this,v=e.$createElement,a=e._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_5-2-java访问指示符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-java访问指示符"}},[e._v("#")]),e._v(" 5.2 Java访问指示符")]),e._v(" "),a("p",[e._v("针对类内每个成员的每个定义，Java访问指示符"),a("code",[e._v("public")]),e._v("，"),a("code",[e._v("protected")]),e._v("以及"),a("code",[e._v("private")]),e._v("都置于它们的最前面——无论它们是一个数据成员，还是一个方法。每个访问指示符都只控制着对那个特定定义的访问。这与C++存在着显著不同。在C++中，访问指示符控制着它后面的所有定义，直到又一个访问指示符加入为止。")]),e._v(" "),a("p",[e._v("通过千丝万缕的联系，程序为所有东西都指定了某种形式的访问。在后面的小节里，大家要学习与各类访问有关的所有知识。首次从默认访问开始。")]),e._v(" "),a("h2",{attrs:{id:"_5-2-1-友好的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-友好的"}},[e._v("#")]),e._v(" 5.2.1 “友好的”")]),e._v(" "),a("p",[e._v("如果根本不指定访问指示符，就象本章之前的所有例子那样，这时会出现什么情况呢？默认的访问没有关键字，但它通常称为“友好”（Friendly）访问。这意味着当前包内的其他所有类都能访问“友好的”成员，但对包外的所有类来说，这些成员却是“私有”（Private）的，外界不得访问。由于一个编译单元（一个文件）只能从属于单个包，所以单个编译单元内的所有类相互间都是自动“友好”的。因此，我们也说友好元素拥有“包访问”权限。")]),e._v(" "),a("p",[e._v("友好访问允许我们将相关的类都组合到一个包里，使它们相互间方便地进行沟通。将类组合到一个包内以后（这样便允许友好成员的相互访问，亦即让它们“交朋友”），我们便“拥有”了那个包内的代码。只有我们已经拥有的代码才能友好地访问自己拥有的其他代码。我们可认为友好访问使类在一个包内的组合显得有意义，或者说前者是后者的原因。在许多语言中，我们在文件内组织定义的方式往往显得有些牵强。但在Java中，却强制用一种颇有意义的形式进行组织。除此以外，我们有时可能想排除一些类，不想让它们访问当前包内定义的类。")]),e._v(" "),a("p",[e._v("对于任何关系，一个非常重要的问题是“谁能访问我们的‘私有’或"),a("code",[e._v("private")]),e._v("代码”。类控制着哪些代码能够访问自己的成员。没有任何秘诀可以“闯入”。另一个包内推荐可以声明一个新类，然后说：“嗨，我是Bob的朋友！”，并指望看到Bob的"),a("code",[e._v("protected")]),e._v("（受到保护的）、友好的以及"),a("code",[e._v("private")]),e._v("（私有）的成员。为获得对一个访问权限，唯一的方法就是：")]),e._v(" "),a("p",[e._v("(1) 使成员成为"),a("code",[e._v("public")]),e._v("（公共的）。这样所有人从任何地方都可以访问它。")]),e._v(" "),a("p",[e._v("(2) 变成一个“友好”成员，方法是舍弃所有访问指示符，并将其类置于相同的包内。这样一来，其他类就可以访问成员。")]),e._v(" "),a("p",[e._v("(3) 正如以后引入“继承”概念后大家会知道的那样，一个继承的类既可以访问一个"),a("code",[e._v("protected")]),e._v("成员，也可以访问一个"),a("code",[e._v("public")]),e._v("成员（但不可访问"),a("code",[e._v("private")]),e._v("成员）。只有在两个类位于相同的包内时，它才可以访问友好成员。但现在不必关心这方面的问题。")]),e._v(" "),a("p",[e._v("(4) 提供“访问器／变化器”方法（亦称为“获取／设置”方法），以便读取和修改值。这是OOP环境中最正规的一种方法，也是Java Beans的基础——具体情况会在第13章介绍。")]),e._v(" "),a("h2",{attrs:{id:"_5-2-2-public-接口访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-2-public-接口访问"}},[e._v("#")]),e._v(" 5.2.2 "),a("code",[e._v("public")]),e._v("：接口访问")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("public")]),e._v("关键字时，它意味着紧随在"),a("code",[e._v("public")]),e._v("后面的成员声明适用于所有人，特别是适用于使用库的客户程序员。假定我们定义了一个名为"),a("code",[e._v("dessert")]),e._v("的包，其中包含下述单元（若执行该程序时遇到困难，请参考第3章3.1.2小节“赋值”）：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//: Cookie.java\n// Creates a library\npackage c05.dessert;\n\npublic class Cookie {\n  public Cookie() {\n   System.out.println("Cookie constructor");\n  }\n  void foo() { System.out.println("foo"); }\n} ///:~\n')])])]),a("p",[e._v("请记住，"),a("code",[e._v("Cookie.java")]),e._v("必须驻留在名为"),a("code",[e._v("dessert")]),e._v("的一个子目录内，而这个子目录又必须位于由"),a("code",[e._v("CLASSPATH")]),e._v("指定的"),a("code",[e._v("C05")]),e._v("目录下面（"),a("code",[e._v("C05")]),e._v("代表本书的第5章）。不要错误地以为Java无论如何都会将当前目录作为搜索的起点看待。如果不将一个"),a("code",[e._v(".")]),e._v("作为"),a("code",[e._v("CLASSPATH")]),e._v("的一部分使用，Java就不会考虑当前目录。")]),e._v(" "),a("p",[e._v("现在，假若创建使用了"),a("code",[e._v("Cookie")]),e._v("的一个程序，如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//: Dinner.java\n// Uses the library\nimport c05.dessert.*;\n\npublic class Dinner {\n  public Dinner() {\n   System.out.println("Dinner constructor");\n  }\n  public static void main(String[] args) {\n    Cookie x = new Cookie();\n    //! x.foo(); // Can\'t access\n  }\n} ///:~\n')])])]),a("p",[e._v("就可以创建一个"),a("code",[e._v("Cookie")]),e._v("对象，因为它的构造器是"),a("code",[e._v("public")]),e._v("的，而且类也是"),a("code",[e._v("public")]),e._v("的（公共类的概念稍后还会进行更详细的讲述）。然而，"),a("code",[e._v("foo()")]),e._v("成员不可在"),a("code",[e._v("Dinner.java")]),e._v("内访问，因为"),a("code",[e._v("foo()")]),e._v("只有在"),a("code",[e._v("dessert")]),e._v("包内才是“友好”的。")]),e._v(" "),a("p",[e._v("(1) 默认包")]),e._v(" "),a("p",[e._v("大家可能会惊讶地发现下面这些代码得以顺利编译——尽管它看起来似乎已违背了规则：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//: Cake.java\n// Accesses a class in a separate\n// compilation unit.\n\nclass Cake {\n  public static void main(String[] args) {\n    Pie x = new Pie();\n    x.f();\n  }\n} ///:~\n")])])]),a("p",[e._v("在位于相同目录的第二个文件里：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//: Pie.java\n// The other class\n\nclass Pie {\n  void f() { System.out.println("Pie.f()"); }\n} ///:~\n')])])]),a("p",[e._v("最初可能会把它们看作完全不相干的文件，然而"),a("code",[e._v("Cake")]),e._v("能创建一个"),a("code",[e._v("Pie")]),e._v("对象，并能调用它的"),a("code",[e._v("f()")]),e._v("方法！通常的想法会认为"),a("code",[e._v("Pie")]),e._v("和"),a("code",[e._v("f()")]),e._v("是“友好的”，所以不适用于"),a("code",[e._v("Cake")]),e._v("。它们确实是友好的——这部分结论非常正确。但它们之所以仍能在"),a("code",[e._v("Cake.java")]),e._v("中使用，是由于它们位于相同的目录中，而且没有明确的包名。Java把象这样的文件看作那个目录“默认包”的一部分，所以它们对于目录内的其他文件来说是“友好”的。")]),e._v(" "),a("h2",{attrs:{id:"_5-2-3-private-不能接触"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-3-private-不能接触"}},[e._v("#")]),e._v(" 5.2.3 "),a("code",[e._v("private")]),e._v("：不能接触！")]),e._v(" "),a("p",[a("code",[e._v("private")]),e._v("关键字意味着除非那个特定的类，而且从那个类的方法里，否则没有人能访问那个成员。同一个包内的其他成员不能访问"),a("code",[e._v("private")]),e._v("成员，这使其显得似乎将类与我们自己都隔离起来。另一方面，也不能由几个合作的人创建一个包。所以"),a("code",[e._v("private")]),e._v("允许我们自由地改变那个成员，同时毋需关心它是否会影响同一个包内的另一个类。默认的“友好”包访问通常已经是一种适当的隐藏方法；请记住，对于包的用户来说，是不能访问一个“友好”成员的。这种效果往往能令人满意，因为默认访问是我们通常采用的方法。对于希望变成"),a("code",[e._v("public")]),e._v("（公共）的成员，我们通常明确地指出，令其可由客户程序员自由调用。而且作为一个结果，最开始的时候通常会认为自己不必频繁使用"),a("code",[e._v("private")]),e._v("关键字，因为完全可以在不用它的前提下发布自己的代码（这与C++是个鲜明的对比）。然而，随着学习的深入，大家就会发现"),a("code",[e._v("private")]),e._v("仍然有非常重要的用途，特别是在涉及多线程处理的时候（详情见第14章）。")]),e._v(" "),a("p",[e._v("下面是应用了"),a("code",[e._v("private")]),e._v("的一个例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//: IceCream.java\n// Demonstrates "private" keyword\n\nclass Sundae {\n  private Sundae() {}\n  static Sundae makeASundae() {\n    return new Sundae();\n  }\n}\n\npublic class IceCream {\n  public static void main(String[] args) {\n    //! Sundae x = new Sundae();\n    Sundae x = Sundae.makeASundae();\n  }\n} ///:~\n')])])]),a("p",[e._v("这个例子向我们证明了使用"),a("code",[e._v("private")]),e._v("的方便：有时可能想控制对象的创建方式，并防止有人直接访问一个特定的构造器（或者所有构造器）。在上面的例子中，我们不可通过它的构造器创建一个"),a("code",[e._v("Sundae")]),e._v("对象；相反，必须调用"),a("code",[e._v("makeASundae()")]),e._v("方法来实现（注释③）。")]),e._v(" "),a("p",[e._v("③：此时还会产生另一个影响：由于默认构造器是唯一获得定义的，而且它的属性是"),a("code",[e._v("private")]),e._v("，所以可防止对这个类的继承（这是第6章要重点讲述的主题）。")]),e._v(" "),a("p",[e._v("若确定一个类只有一个“助手”方法，那么对于任何方法来说，都可以把它们设为"),a("code",[e._v("private")]),e._v("，从而保证自己不会误在包内其他地方使用它，防止自己更改或删除方法。将一个方法的属性设为"),a("code",[e._v("private")]),e._v("后，可保证自己一直保持这一选项（然而，若一个引用被设为"),a("code",[e._v("private")]),e._v("，并不表明其他对象不能拥有指向同一个对象的"),a("code",[e._v("public")]),e._v("引用。有关“别名”的问题将在第12章详述）。")]),e._v(" "),a("h2",{attrs:{id:"_5-2-4-protected-友好的一种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-4-protected-友好的一种"}},[e._v("#")]),e._v(" 5.2.4 "),a("code",[e._v("protected")]),e._v("：“友好的一种”")]),e._v(" "),a("p",[a("code",[e._v("protected")]),e._v("（受到保护的）访问指示符要求大家提前有所认识。首先应注意这样一个事实：为继续学习本书一直到继承那一章之前的内容，并不一定需要先理解本小节的内容。但为了保持内容的完整，这儿仍然要对此进行简要说明，并提供相关的例子。")]),e._v(" "),a("p",[a("code",[e._v("protected")]),e._v("关键字为我们引入了一种名为“继承”的概念，它以现有的类为基础，并在其中加入新的成员，同时不会对现有的类产生影响——我们将这种现有的类称为“基类”或者“基本类”（Base Class）。亦可改变那个类现有成员的行为。对于从一个现有类的继承，我们说自己的新类“扩展”（"),a("code",[e._v("extends")]),e._v("）了那个现有的类。如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Foo extends Bar {\n")])])]),a("p",[e._v("类定义剩余的部分看起来是完全相同的。")]),e._v(" "),a("p",[e._v("若新建一个包，并从另一个包内的某个类里继承，则唯一能够访问的成员就是原来那个包的"),a("code",[e._v("public")]),e._v("成员。当然，如果在相同的包里进行继承，那么继承获得的包能够访问所有“友好”的成员。有些时候，基类的创建者喜欢提供一个特殊的成员，并允许访问派生类。这正是"),a("code",[e._v("protected")]),e._v("的工作。若往回引用5.2.2小节“"),a("code",[e._v("public")]),e._v("：接口访问”的那个"),a("code",[e._v("Cookie.java")]),e._v("文件，则下面这个类就不能访问“友好”的成员：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//: ChocolateChip.java\n// Can't access friendly member\n// in another class\nimport c05.dessert.*;\n\npublic class ChocolateChip extends Cookie {\n  public ChocolateChip() {\n   System.out.println(\n     \"ChocolateChip constructor\");\n  }\n  public static void main(String[] args) {\n    ChocolateChip x = new ChocolateChip();\n    //! x.foo(); // Can't access foo\n  }\n} ///:~\n")])])]),a("p",[e._v("对于继承，值得注意的一件有趣的事情是倘若方法"),a("code",[e._v("foo()")]),e._v("存在于类"),a("code",[e._v("Cookie")]),e._v("中，那么它也会存在于从"),a("code",[e._v("Cookie")]),e._v("继承的所有类中。但由于"),a("code",[e._v("foo()")]),e._v("在外部的包里是“友好”的，所以我们不能使用它。当然，亦可将其变成"),a("code",[e._v("public")]),e._v("。但这样一来，由于所有人都能自由访问它，所以可能并非我们所希望的局面。若象下面这样修改类"),a("code",[e._v("Cookie")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('public class Cookie {\n  public Cookie() {\n    System.out.println("Cookie constructor");\n  }\n  protected void foo() {\n    System.out.println("foo");\n  }\n}\n')])])]),a("p",[e._v("那么仍然能在包"),a("code",[e._v("dessert")]),e._v("里“友好”地访问"),a("code",[e._v("foo()")]),e._v("，但从"),a("code",[e._v("Cookie")]),e._v("继承的其他东西亦可自由地访问它。然而，它并非公共的（"),a("code",[e._v("public")]),e._v("）。")])])}),[],!1,null,null,null);v.default=t.exports}}]);