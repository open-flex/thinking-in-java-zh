(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{546:function(n,t,e){"use strict";e.r(t);var i=e(56),s=Object(i.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_7-1-向上转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-向上转换"}},[n._v("#")]),n._v(" 7.1 向上转换")]),n._v(" "),e("p",[n._v("在第6章，大家已知道可将一个对象作为它自己的类型使用，或者作为它的基类型的一个对象使用。取得一个对象引用，并将其作为基类型引用使用的行为就叫作“向上转换”——因为继承树的画法是基类位于最上方。")]),n._v(" "),e("p",[n._v("但这样做也会遇到一个问题，如下例所示（若执行这个程序遇到麻烦，请参考第3章的3.1.2小节“赋值”）：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//: Music.java\n// Inheritance & upcasting\npackage c07;\n\nclass Note {\n  private int value;\n  private Note(int val) { value = val; }\n  public static final Note\n    middleC = new Note(0),\n    cSharp = new Note(1),\n    cFlat = new Note(2);\n} // Etc.\n\nclass Instrument {\n  public void play(Note n) {\n    System.out.println("Instrument.play()");\n  }\n}\n\n// Wind objects are instruments\n// because they have the same interface:\nclass Wind extends Instrument {\n  // Redefine interface method:\n  public void play(Note n) {\n    System.out.println("Wind.play()");\n  }\n}\n\npublic class Music {\n  public static void tune(Instrument i) {\n    // ...\n    i.play(Note.middleC);\n  }\n  public static void main(String[] args) {\n    Wind flute = new Wind();\n    tune(flute); // Upcasting\n  }\n} ///:~\n')])])]),e("p",[n._v("其中，方法"),e("code",[n._v("Music.tune()")]),n._v("接收一个"),e("code",[n._v("Instrument")]),n._v("引用，同时也接收从"),e("code",[n._v("Instrument")]),n._v("派生出来的所有东西。当一个"),e("code",[n._v("Wind")]),n._v("引用传递给"),e("code",[n._v("tune()")]),n._v("的时候，就会出现这种情况。此时没有转换的必要。这样做是可以接受的；"),e("code",[n._v("Instrument")]),n._v("里的接口必须存在于"),e("code",[n._v("Wind")]),n._v("中，因为"),e("code",[n._v("Wind")]),n._v("是从"),e("code",[n._v("Instrument")]),n._v("里继承得到的。从"),e("code",[n._v("Wind")]),n._v("向"),e("code",[n._v("Instrument")]),n._v("的向上转换可能“缩小”那个接口，但不可能把它变得比"),e("code",[n._v("Instrument")]),n._v("的完整接口还要小。")]),n._v(" "),e("h2",{attrs:{id:"_7-1-1-为什么要向上转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-1-为什么要向上转换"}},[n._v("#")]),n._v(" 7.1.1 为什么要向上转换")]),n._v(" "),e("p",[n._v("这个程序看起来也许显得有些奇怪。为什么所有人都应该有意忘记一个对象的类型呢？进行向上转换时，就可能产生这方面的疑惑。而且如果让"),e("code",[n._v("tune()")]),n._v("简单地取得一个"),e("code",[n._v("Wind")]),n._v("引用，将其作为自己的参数使用，似乎会更加简单、直观得多。但要注意：假如那样做，就需为系统内"),e("code",[n._v("Instrument")]),n._v("的每种类型写一个全新的"),e("code",[n._v("tune()")]),n._v("。假设按照前面的推论，加入"),e("code",[n._v("Stringed")]),n._v("（弦乐）和"),e("code",[n._v("Brass")]),n._v("（铜管）这两种"),e("code",[n._v("Instrument")]),n._v("（乐器）：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//: Music2.java\n// Overloading instead of upcasting\n\nclass Note2 {\n  private int value;\n  private Note2(int val) { value = val; }\n  public static final Note2\n    middleC = new Note2(0),\n    cSharp = new Note2(1),\n    cFlat = new Note2(2);\n} // Etc.\n\nclass Instrument2 {\n  public void play(Note2 n) {\n    System.out.println("Instrument2.play()");\n  }\n}\n\nclass Wind2 extends Instrument2 {\n  public void play(Note2 n) {\n    System.out.println("Wind2.play()");\n  }\n}\n\nclass Stringed2 extends Instrument2 {\n  public void play(Note2 n) {\n    System.out.println("Stringed2.play()");\n  }\n}\n\nclass Brass2 extends Instrument2 {\n  public void play(Note2 n) {\n    System.out.println("Brass2.play()");\n  }\n}\n\npublic class Music2 {\n  public static void tune(Wind2 i) {\n    i.play(Note2.middleC);\n  }\n  public static void tune(Stringed2 i) {\n    i.play(Note2.middleC);\n  }\n  public static void tune(Brass2 i) {\n    i.play(Note2.middleC);\n  }\n  public static void main(String[] args) {\n    Wind2 flute = new Wind2();\n    Stringed2 violin = new Stringed2();\n    Brass2 frenchHorn = new Brass2();\n    tune(flute); // No upcasting\n    tune(violin);\n    tune(frenchHorn);\n  }\n} ///:~\n')])])]),e("p",[n._v("这样做当然行得通，但却存在一个极大的弊端：必须为每种新增的"),e("code",[n._v("Instrument2")]),n._v("类编写与类紧密相关的方法。这意味着第一次就要求多得多的编程量。以后，假如想添加一个象"),e("code",[n._v("tune()")]),n._v("那样的新方法或者为"),e("code",[n._v("Instrument")]),n._v("添加一个新类型，仍然需要进行大量编码工作。此外，即使忘记对自己的某个方法进行重载设置，编译器也不会提示任何错误。这样一来，类型的整个操作过程就显得极难管理，有失控的危险。")]),n._v(" "),e("p",[n._v("但假如只写一个方法，将基类作为参数使用，而不是使用那些特定的派生类，岂不是会简单得多？也就是说，如果我们能不顾派生类，只让自己的代码与基类打交道，那么省下的工作量将是难以估计的。")]),n._v(" "),e("p",[n._v("这正是“多态性”大显身手的地方。然而，大多数程序员（特别是有程序化编程背景的）对于多态性的工作原理仍然显得有些生疏。")])])}),[],!1,null,null,null);t.default=s.exports}}]);