(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{434:function(e,s,n){"use strict";n.r(s);var a=n(56),t=Object(a.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_11-2-rtti语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-rtti语法"}},[e._v("#")]),e._v(" 11.2 RTTI语法")]),e._v(" "),n("p",[e._v("Java用"),n("code",[e._v("Class")]),e._v("对象实现自己的RTTI功能——即便我们要做的只是象转换那样的一些工作。"),n("code",[e._v("Class")]),e._v("类也提供了其他大量方式，以方便我们使用RTTI。")]),e._v(" "),n("p",[e._v("首先必须获得指向适当"),n("code",[e._v("Class")]),e._v("对象的的一个引用。就象前例演示的那样，一个办法是用一个字符串以及"),n("code",[e._v("Class.forName()")]),e._v("方法。这是非常方便的，因为不需要那种类型的一个对象来获取"),n("code",[e._v("Class")]),e._v("引用。然而，对于自己感兴趣的类型，如果已有了它的一个对象，那么为了取得"),n("code",[e._v("Class")]),e._v("引用，可调用属于"),n("code",[e._v("Object")]),e._v("根类一部分的一个方法："),n("code",[e._v("getClass()")]),e._v("。它的作用是返回一个特定的"),n("code",[e._v("Class")]),e._v("引用，用来表示对象的实际类型。"),n("code",[e._v("Class")]),e._v("提供了几个有趣且较为有用的方法，从下例即可看出：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: ToyTest.java\n// Testing class Class\n\ninterface HasBatteries {}\ninterface Waterproof {}\ninterface ShootsThings {}\nclass Toy {\n  // Comment out the following default\n  // constructor to see\n  // NoSuchMethodError from (*1*)\n  Toy() {}\n  Toy(int i) {}\n}\n\nclass FancyToy extends Toy\n    implements HasBatteries,\n      Waterproof, ShootsThings {\n  FancyToy() { super(1); }\n}\n\npublic class ToyTest {\n  public static void main(String[] args) {\n    Class c = null;\n    try {\n      c = Class.forName("FancyToy");\n    } catch(ClassNotFoundException e) {}\n    printInfo(c);\n    Class[] faces = c.getInterfaces();\n    for(int i = 0; i < faces.length; i++)\n      printInfo(faces[i]);\n    Class cy = c.getSuperclass();\n    Object o = null;\n    try {\n      // Requires default constructor:\n      o = cy.newInstance(); // (*1*)\n    } catch(InstantiationException e) {}\n      catch(IllegalAccessException e) {}\n    printInfo(o.getClass());\n  }\n  static void printInfo(Class cc) {\n    System.out.println(\n      "Class name: " + cc.getName() +\n      " is interface? [" +\n      cc.isInterface() + "]");\n  }\n} ///:~\n')])])]),n("p",[e._v("从中可以看出，"),n("code",[e._v("class FancyToy")]),e._v("相当复杂，因为它从"),n("code",[e._v("Toy")]),e._v("中继承，并实现了"),n("code",[e._v("HasBatteries")]),e._v("，"),n("code",[e._v("Waterproof")]),e._v("以及"),n("code",[e._v("ShootsThings")]),e._v("的接口。在"),n("code",[e._v("main()")]),e._v("中创建了一个"),n("code",[e._v("Class")]),e._v("引用，并用位于相应"),n("code",[e._v("try")]),e._v("块内的"),n("code",[e._v("forName()")]),e._v("初始化成"),n("code",[e._v("FancyToy")]),e._v("。")]),e._v(" "),n("p",[n("code",[e._v("Class.getInterfaces")]),e._v("方法会返回"),n("code",[e._v("Class")]),e._v("对象的一个数组，用于表示包含在"),n("code",[e._v("Class")]),e._v("对象内的接口。")]),e._v(" "),n("p",[e._v("若有一个"),n("code",[e._v("Class")]),e._v("对象，也可以用"),n("code",[e._v("getSuperclass()")]),e._v("查询该对象的直接基类是什么。当然，这种做会返回一个"),n("code",[e._v("Class")]),e._v("引用，可用它作进一步的查询。这意味着在运行期的时候，完全有机会调查到对象的完整层次结构。")]),e._v(" "),n("p",[e._v("若从表面看，"),n("code",[e._v("Class")]),e._v("的"),n("code",[e._v("newInstance()")]),e._v("方法似乎是克隆（"),n("code",[e._v("clone()")]),e._v("）一个对象的另一种手段。但两者是有区别的。利用"),n("code",[e._v("newInstance()")]),e._v("，我们可在没有现成对象供“克隆”的情况下新建一个对象。就象上面的程序演示的那样，当时没有"),n("code",[e._v("Toy")]),e._v("对象，只有"),n("code",[e._v("cy")]),e._v("——即"),n("code",[e._v("y")]),e._v("的"),n("code",[e._v("Class")]),e._v("对象的一个引用。利用它可以实现“虚拟构造器”。换言之，我们表达：“尽管我不知道你的准确类型是什么，但请你无论如何都正确地创建自己。”在上述例子中，"),n("code",[e._v("cy")]),e._v("只是一个"),n("code",[e._v("Class")]),e._v("引用，编译期间并不知道进一步的类型信息。一旦新建了一个实例后，可以得到"),n("code",[e._v("Object")]),e._v("引用。但那个引用指向一个"),n("code",[e._v("Toy")]),e._v("对象。当然，如果要将除"),n("code",[e._v("Object")]),e._v("能够接收的其他任何消息发出去，首先必须进行一些调查研究，再进行转换。除此以外，用"),n("code",[e._v("newInstance()")]),e._v("创建的类必须有一个默认构造器。没有办法用"),n("code",[e._v("newInstance()")]),e._v("创建拥有非默认构造器的对象，所以在Java 1.0中可能存在一些限制。然而，Java 1.1的“反射”API（下一节讨论）却允许我们动态地使用类里的任何构造器。")]),e._v(" "),n("p",[e._v("程序中的最后一个方法是"),n("code",[e._v("printInfo()")]),e._v("，它取得一个"),n("code",[e._v("Class")]),e._v("引用，通过"),n("code",[e._v("getName()")]),e._v("获得它的名字，并用"),n("code",[e._v("interface()")]),e._v("调查它是不是一个接口。")]),e._v(" "),n("p",[e._v("该程序的输出如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Class name: FancyToy is interface? [false]\nClass name: HasBatteries is interface? [true]\nClass name: Waterproof is interface? [true]\nClass name: ShootsThings is interface? [true]\nClass name: Toy is interface? [false]\n")])])]),n("p",[e._v("所以利用"),n("code",[e._v("Class")]),e._v("对象，我们几乎能将一个对象的祖宗十八代都调查出来。")])])}),[],!1,null,null,null);s.default=t.exports}}]);