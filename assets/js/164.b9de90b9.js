(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{560:function(e,t,n){"use strict";n.r(t);var v=n(56),o=Object(v.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_8-4-集合的类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-集合的类型"}},[e._v("#")]),e._v(" 8.4 集合的类型")]),e._v(" "),n("p",[e._v("标准Java 1.0和1.1库配套提供了非常少的一系列集合类。但对于自己的大多数编程要求，它们基本上都能胜任。正如大家到本章末尾会看到的，Java 1.2提供的是一套重新设计过的大型集合库。")]),e._v(" "),n("h2",{attrs:{id:"_8-4-1-vector"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-1-vector"}},[e._v("#")]),e._v(" 8.4.1 "),n("code",[e._v("Vector")])]),e._v(" "),n("p",[n("code",[e._v("Vector")]),e._v("的用法很简单，这已在前面的例子中得到了证明。尽管我们大多数时候只需用"),n("code",[e._v("addElement()")]),e._v("插入对象，用"),n("code",[e._v("elementAt()")]),e._v("一次提取一个对象，并用"),n("code",[e._v("elements()")]),e._v("获得对序列的一个“枚举”。但仍有其他一系列方法是非常有用的。同我们对于Java库惯常的做法一样，在这里并不使用或讲述所有这些方法。但请务必阅读相应的电子文档，对它们的工作有一个大概的认识。")]),e._v(" "),n("p",[e._v("(1) 崩溃Java")]),e._v(" "),n("p",[e._v("Java标准集合里包含了"),n("code",[e._v("toString()")]),e._v("方法，所以它们能生成自己的"),n("code",[e._v("String")]),e._v("表达方式，包括它们容纳的对象。例如在"),n("code",[e._v("Vector")]),e._v("中，"),n("code",[e._v("toString()")]),e._v("会在"),n("code",[e._v("Vector")]),e._v("的各个元素中步进和遍历，并为每个元素调用"),n("code",[e._v("toString()")]),e._v("。假定我们现在想打印出自己类的地址。看起来似乎简单地引用"),n("code",[e._v("this")]),e._v("即可（特别是C++程序员有这样做的倾向）：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: CrashJava.java\n// One way to crash Java\nimport java.util.*;\n\npublic class CrashJava {\n  public String toString() {\n    return "CrashJava address: " + this + "\\n";\n  }\n  public static void main(String[] args) {\n    Vector v = new Vector();\n    for(int i = 0; i < 10; i++)\n      v.addElement(new CrashJava());\n    System.out.println(v);\n  }\n} ///:~\n')])])]),n("p",[e._v("若只是简单地创建一个"),n("code",[e._v("CrashJava")]),e._v("对象，并将其打印出来，就会得到无穷无尽的一系列异常错误。然而，假如将"),n("code",[e._v("CrashJava")]),e._v("对象置入一个"),n("code",[e._v("Vector")]),e._v("，并象这里演示的那样打印"),n("code",[e._v("Vector")]),e._v("，就不会出现什么错误提示，甚至连一个异常都不会出现。此时Java只是简单地崩溃（但至少它没有崩溃我的操作系统）。这已在Java 1.1中测试通过。")]),e._v(" "),n("p",[e._v("此时发生的是字符串的自动类型转换。当我们使用下述语句时：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('"CrashJava address: " + this\n')])])]),n("p",[e._v("编译器就在一个字符串后面发现了一个"),n("code",[e._v("+")]),e._v("以及好象并非字符串的其他东西，所以它会试图将"),n("code",[e._v("this")]),e._v("转换成一个字符串。转换时调用的是"),n("code",[e._v("toString()")]),e._v("，后者会产生一个递归调用。若在一个"),n("code",[e._v("Vector")]),e._v("内出现这种事情，看起来栈就会溢出，同时异常控制机制根本没有机会作出响应。")]),e._v(" "),n("p",[e._v("若确实想在这种情况下打印出对象的地址，解决方案就是调用"),n("code",[e._v("Object")]),e._v("的"),n("code",[e._v("toString")]),e._v("方法。此时就不必加入"),n("code",[e._v("this")]),e._v("，只需使用"),n("code",[e._v("super.toString()")]),e._v("。当然，采取这种做法也有一个前提：我们必须从"),n("code",[e._v("Object")]),e._v("直接继承，或者没有一个父类覆盖了"),n("code",[e._v("toString")]),e._v("方法。")]),e._v(" "),n("h2",{attrs:{id:"_8-4-2-bitset"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-2-bitset"}},[e._v("#")]),e._v(" 8.4.2 "),n("code",[e._v("BitSet")])]),e._v(" "),n("p",[n("code",[e._v("BitSet")]),e._v("实际是由“二进制位”构成的一个"),n("code",[e._v("Vector")]),e._v("。如果希望高效率地保存大量“开－关”信息，就应使用"),n("code",[e._v("BitSet")]),e._v("。它只有从尺寸的角度看才有意义；如果希望的高效率的访问，那么它的速度会比使用一些固有类型的数组慢一些。")]),e._v(" "),n("p",[e._v("此外，"),n("code",[e._v("BitSet")]),e._v("的最小长度是一个长整数（"),n("code",[e._v("Long")]),e._v("）的长度：64位。这意味着假如我们准备保存比这更小的数据，如8位数据，那么"),n("code",[e._v("BitSet")]),e._v("就显得浪费了。所以最好创建自己的类，用它容纳自己的标志位。")]),e._v(" "),n("p",[e._v("在一个普通的"),n("code",[e._v("Vector")]),e._v("中，随我们加入越来越多的元素，集合也会自我膨胀。在某种程度上，"),n("code",[e._v("BitSet")]),e._v("也不例外。也就是说，它有时会自行扩展，有时则不然。而且Java的1.0版本似乎在这方面做得最糟，它的"),n("code",[e._v("BitSet")]),e._v("表现十分差强人意（Java1.1已改正了这个问题）。下面这个例子展示了"),n("code",[e._v("BitSet")]),e._v("是如何运作的，同时演示了1.0版本的错误：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: Bits.java\n// Demonstration of BitSet\nimport java.util.*;\n\npublic class Bits {\n  public static void main(String[] args) {\n    Random rand = new Random();\n    // Take the LSB of nextInt():\n    byte bt = (byte)rand.nextInt();\n    BitSet bb = new BitSet();\n    for(int i = 7; i >=0; i--)\n      if(((1 << i) &  bt) != 0)\n        bb.set(i);\n      else\n        bb.clear(i);\n    System.out.println("byte value: " + bt);\n    printBitSet(bb);\n\n    short st = (short)rand.nextInt();\n    BitSet bs = new BitSet();\n    for(int i = 15; i >=0; i--)\n      if(((1 << i) &  st) != 0)\n        bs.set(i);\n      else\n        bs.clear(i);\n    System.out.println("short value: " + st);\n    printBitSet(bs);\n\n    int it = rand.nextInt();\n    BitSet bi = new BitSet();\n    for(int i = 31; i >=0; i--)\n      if(((1 << i) &  it) != 0)\n        bi.set(i);\n      else\n        bi.clear(i);\n    System.out.println("int value: " + it);\n    printBitSet(bi);\n\n    // Test bitsets >= 64 bits:\n    BitSet b127 = new BitSet();\n    b127.set(127);\n    System.out.println("set bit 127: " + b127);\n    BitSet b255 = new BitSet(65);\n    b255.set(255);\n    System.out.println("set bit 255: " + b255);\n    BitSet b1023 = new BitSet(512);\n// Without the following, an exception is thrown\n// in the Java 1.0 implementation of BitSet:\n//    b1023.set(1023);\n    b1023.set(1024);\n    System.out.println("set bit 1023: " + b1023);\n  }\n  static void printBitSet(BitSet b) {\n    System.out.println("bits: " + b);\n    String bbits = new String();\n    for(int j = 0; j < b.size() ; j++)\n      bbits += (b.get(j) ? "1" : "0");\n    System.out.println("bit pattern: " + bbits);\n  }\n} ///:~\n')])])]),n("p",[e._v("随机数字生成器用于创建一个随机的"),n("code",[e._v("byte")]),e._v("、"),n("code",[e._v("short")]),e._v("和"),n("code",[e._v("int")]),e._v("。每一个都会转换成"),n("code",[e._v("BitSet")]),e._v("内相应的位模型。此时一切都很正常，因为"),n("code",[e._v("BitSet")]),e._v("是64位的，所以它们都不会造成最终尺寸的增大。但在Java 1.0中，一旦"),n("code",[e._v("BitSet")]),e._v("大于64位，就会出现一些令人迷惑不解的行为。假如我们设置一个只比"),n("code",[e._v("BitSet")]),e._v("当前分配存储空间大出1的一个位，它能够正常地扩展。但一旦试图在更高的位置设置位，同时不先接触边界，就会得到一个恼人的异常。这正是由于"),n("code",[e._v("BitSet")]),e._v("在Java 1.0里不能正确扩展造成的。本例创建了一个512位的"),n("code",[e._v("BitSet")]),e._v("。构造器分配的存储空间是位数的两倍。所以假如设置位1024或更高的位，同时没有先设置位1023，就会在Java 1.0里得到一个异常。但幸运的是，这个问题已在Java 1.1得到了改正。所以如果是为Java 1.0写代码，请尽量避免使用"),n("code",[e._v("BitSet")]),e._v("。")]),e._v(" "),n("h2",{attrs:{id:"_8-4-3-stack"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-3-stack"}},[e._v("#")]),e._v(" 8.4.3 "),n("code",[e._v("Stack")])]),e._v(" "),n("p",[n("code",[e._v("Stack")]),e._v("有时也可以称为“后入先出”（LIFO）集合。换言之，我们在栈里最后“压入”的东西将是以后第一个“弹出”的。和其他所有Java集合一样，我们压入和弹出的都是“对象”，所以必须对自己弹出的东西进行“转换”。")]),e._v(" "),n("p",[e._v("一种很少见的做法是拒绝使用"),n("code",[e._v("Vector")]),e._v("作为一个"),n("code",[e._v("Stack")]),e._v("的基本构成元素，而是从"),n("code",[e._v("Vector")]),e._v("里“继承”一个"),n("code",[e._v("Stack")]),e._v("。这样一来，它就拥有了一个"),n("code",[e._v("Vector")]),e._v("的所有特征及行为，另外加上一些额外的"),n("code",[e._v("Stack")]),e._v("行为。很难判断出设计者到底是明确想这样做，还是属于一种固有的设计。")]),e._v(" "),n("p",[e._v("下面是一个简单的栈示例，它能读入数组的每一行，同时将其作为字符串压入栈。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: Stacks.java\n// Demonstration of Stack Class\nimport java.util.*;\n\npublic class Stacks {\n  static String[] months = {\n    "January", "February", "March", "April",\n    "May", "June", "July", "August", "September",\n    "October", "November", "December" };\n  public static void main(String[] args) {\n    Stack stk = new Stack();\n    for(int i = 0; i < months.length; i++)\n      stk.push(months[i] + " ");\n    System.out.println("stk = " + stk);\n    // Treating a stack as a Vector:\n    stk.addElement("The last line");\n    System.out.println(\n      "element 5 = " + stk.elementAt(5));\n    System.out.println("popping elements:");\n    while(!stk.empty())\n      System.out.println(stk.pop());\n  }\n} ///:~\n')])])]),n("p",[n("code",[e._v("months")]),e._v("数组的每一行都通过"),n("code",[e._v("push()")]),e._v("继承进入栈，稍后用"),n("code",[e._v("pop()")]),e._v("从栈的顶部将其取出。要声明的一点是，"),n("code",[e._v("Vector")]),e._v("操作亦可针对Stack对象进行。这可能是由继承的特质决定的——"),n("code",[e._v("Stack")]),e._v("“属于”一种"),n("code",[e._v("Vector")]),e._v("。因此，能对"),n("code",[e._v("Vector")]),e._v("进行的操作亦可针对"),n("code",[e._v("Stack")]),e._v("进行，例如"),n("code",[e._v("elementAt()")]),e._v("方法。")]),e._v(" "),n("h2",{attrs:{id:"_8-4-4-hashtable"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-4-hashtable"}},[e._v("#")]),e._v(" 8.4.4 "),n("code",[e._v("Hashtable")])]),e._v(" "),n("p",[n("code",[e._v("Vector")]),e._v("允许我们用一个数字从一系列对象中作出选择，所以它实际是将数字同对象关联起来了。但假如我们想根据其他标准选择一系列对象呢？栈就是这样的一个例子：它的选择标准是“最后压入栈的东西”。这种“从一系列对象中选择”的概念亦可叫作一个“映射”、“字典”或者“关联数组”。从概念上讲，它看起来象一个"),n("code",[e._v("Vector")]),e._v("，但却不是通过数字来查找对象，而是用另一个对象来查找它们！这通常都属于一个程序中的重要进程。")]),e._v(" "),n("p",[e._v("在Java中，这个概念具体反映到抽象类"),n("code",[e._v("Dictionary")]),e._v("身上。该类的接口是非常直观的"),n("code",[e._v("size()")]),e._v("告诉我们其中包含了多少元素；"),n("code",[e._v("isEmpty()")]),e._v("判断是否包含了元素（是则为"),n("code",[e._v("true")]),e._v("）；"),n("code",[e._v("put(Object key, Object value)")]),e._v("添加一个值（我们希望的东西），并将其同一个键关联起来（想用于搜索它的东西）；"),n("code",[e._v("get(Object key)")]),e._v("获得与某个键对应的值；而"),n("code",[e._v("remove(Object Key)")]),e._v("用于从列表中删除“键－值”对。还可以使用枚举技术："),n("code",[e._v("keys()")]),e._v("产生对键的一个枚举（"),n("code",[e._v("Enumeration")]),e._v("）；而"),n("code",[e._v("elements()")]),e._v("产生对所有值的一个枚举。这便是一个"),n("code",[e._v("Dictionary")]),e._v("（字典）的全部。")]),e._v(" "),n("p",[n("code",[e._v("Dictionary")]),e._v("的实现过程并不麻烦。下面列出一种简单的方法，它使用了两个"),n("code",[e._v("Vector")]),e._v("，一个用于容纳键，另一个用来容纳值：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//: AssocArray.java\n// Simple version of a Dictionary\nimport java.util.*;\n\npublic class AssocArray extends Dictionary {\n  private Vector keys = new Vector();\n  private Vector values = new Vector();\n  public int size() { return keys.size(); }\n  public boolean isEmpty() {\n    return keys.isEmpty();\n  }\n  public Object put(Object key, Object value) {\n    keys.addElement(key);\n    values.addElement(value);\n    return key;\n  }\n  public Object get(Object key) {\n    int index = keys.indexOf(key);\n    // indexOf() Returns -1 if key not found:\n    if(index == -1) return null;\n    return values.elementAt(index);\n  }\n  public Object remove(Object key) {\n    int index = keys.indexOf(key);\n    if(index == -1) return null;\n    keys.removeElementAt(index);\n    Object returnval = values.elementAt(index);\n    values.removeElementAt(index);\n    return returnval;\n  }\n  public Enumeration keys() {\n    return keys.elements();\n  }\n  public Enumeration elements() {\n    return values.elements();\n  }\n  // Test it:\n  public static void main(String[] args) {\n    AssocArray aa = new AssocArray();\n    for(char c = 'a'; c <= 'z'; c++)\n      aa.put(String.valueOf(c),\n             String.valueOf(c)\n             .toUpperCase());\n    char[] ca = { 'a', 'e', 'i', 'o', 'u' };\n    for(int i = 0; i < ca.length; i++)\n      System.out.println(\"Uppercase: \" +\n             aa.get(String.valueOf(ca[i])));\n  }\n} ///:~\n")])])]),n("p",[e._v("在对"),n("code",[e._v("AssocArray")]),e._v("的定义中，我们注意到的第一个问题是它“扩展”了字典。这意味着"),n("code",[e._v("AssocArray")]),e._v("属于"),n("code",[e._v("Dictionary")]),e._v("的一种类型，所以可对其发出与"),n("code",[e._v("Dictionary")]),e._v("一样的请求。如果想生成自己的"),n("code",[e._v("Dictionary")]),e._v("，而且就在这里进行，那么要做的全部事情只是填充位于"),n("code",[e._v("Dictionar")]),e._v("y内的所有方法（而且必须覆盖所有方法，因为它们——除构造器外——都是抽象的）。")]),e._v(" "),n("p",[n("code",[e._v("Vector key")]),e._v("和"),n("code",[e._v("value")]),e._v("通过一个标准索引编号链接起来。也就是说，如果用"),n("code",[e._v("roof")]),e._v("的一个键以及"),n("code",[e._v("blue")]),e._v("的一个值调用"),n("code",[e._v("put()")]),e._v("——假定我们准备将一个房子的各部分与它们的油漆颜色关联起来，而且"),n("code",[e._v("AssocArray")]),e._v("里已有100个元素，那么"),n("code",[e._v("roof")]),e._v("就会有101个键元素，而"),n("code",[e._v("blue")]),e._v("有101个值元素。而且要注意一下"),n("code",[e._v("get()")]),e._v("，假如我们作为键传递"),n("code",[e._v("roof")]),e._v("，它就会产生与"),n("code",[e._v("keys.index.Of()")]),e._v("的索引编号，然后用那个索引编号生成相关的值向量内的值。")]),e._v(" "),n("p",[n("code",[e._v("main()")]),e._v("中进行的测试是非常简单的；它只是将小写字符转换成大写字符，这显然可用更有效的方式进行。但它向我们揭示出了"),n("code",[e._v("AssocArray")]),e._v("的强大功能。")]),e._v(" "),n("p",[e._v("标准Java库只包含"),n("code",[e._v("Dictionary")]),e._v("的一个变种，名为"),n("code",[e._v("Hashtable")]),e._v("（散列表，注释③）。Java的散列表具有与"),n("code",[e._v("AssocArray")]),e._v("相同的接口（因为两者都是从"),n("code",[e._v("Dictionary")]),e._v("继承来的）。但有一个方面却反映出了差别：执行效率。若仔细想想必须为一个"),n("code",[e._v("get()")]),e._v("做的事情，就会发现在一个"),n("code",[e._v("Vector")]),e._v("里搜索键的速度要慢得多。但此时用散列表却可以加快不少速度。不必用冗长的线性搜索技术来查找一个键，而是用一个特殊的值，名为“散列码”。散列码可以获取对象中的信息，然后将其转换成那个对象“相对唯一”的整数（"),n("code",[e._v("int")]),e._v("）。所有对象都有一个散列码，而"),n("code",[e._v("hashCode()")]),e._v("是根类"),n("code",[e._v("Object")]),e._v("的一个方法。"),n("code",[e._v("Hashtable")]),e._v("获取对象的"),n("code",[e._v("hashCode()")]),e._v("，然后用它快速查找键。这样可使性能得到大幅度提升（④）。散列表的具体工作原理已超出了本书的范围（⑤）——大家只需要知道散列表是一种快速的“字典”（"),n("code",[e._v("Dictionary")]),e._v("）即可，而字典是一种非常有用的工具。")]),e._v(" "),n("p",[e._v("③：如计划使用RMI（在第15章详述），应注意将远程对象置入散列表时会遇到一个问题（参阅《Core Java》，作者Conrell和Horstmann，Prentice-Hall 1997年出版）")]),e._v(" "),n("p",[e._v("④：如这种速度的提升仍然不能满足你对性能的要求，甚至可以编写自己的散列表例程，从而进一步加快表格的检索过程。这样做可避免在与"),n("code",[e._v("Object")]),e._v("之间进行转换的时间延误，也可以避开由Java类库散列表例程内建的同步过程。")]),e._v(" "),n("p",[e._v("⑤：我的知道的最佳参考读物是《Practical Algorithms for Programmers》，作者为Andrew Binstock和John Rex，Addison-Wesley 1995年出版。")]),e._v(" "),n("p",[e._v("作为应用散列表的一个例子，可考虑用一个程序来检验Java的"),n("code",[e._v("Math.random()")]),e._v("方法的随机性到底如何。在理想情况下，它应该产生一系列完美的随机分布数字。但为了验证这一点，我们需要生成数量众多的随机数字，然后计算落在不同范围内的数字多少。散列表可以极大简化这一工作，因为它能将对象同对象关联起来（此时是将"),n("code",[e._v("Math.random()")]),e._v("生成的值同那些值出现的次数关联起来）。如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//: Statistics.java\n// Simple demonstration of Hashtable\nimport java.util.*;\n\nclass Counter {\n  int i = 1;\n  public String toString() {\n    return Integer.toString(i);\n  }\n}\n\nclass Statistics {\n  public static void main(String[] args) {\n    Hashtable ht = new Hashtable();\n    for(int i = 0; i < 10000; i++) {\n      // Produce a number between 0 and 20:\n      Integer r =\n        new Integer((int)(Math.random() * 20));\n      if(ht.containsKey(r))\n        ((Counter)ht.get(r)).i++;\n      else\n        ht.put(r, new Counter());\n    }\n    System.out.println(ht);\n  }\n} ///:~\n")])])]),n("p",[e._v("在"),n("code",[e._v("main()")]),e._v("中，每次产生一个随机数字，它都会封装到一个"),n("code",[e._v("Integer")]),e._v("对象里，使引用能够随同散列表一起使用（不可对一个集合使用基本数据类型，只能使用对象引用）。"),n("code",[e._v("containKey()")]),e._v("方法检查这个键是否已经在集合里（也就是说，那个数字以前发现过吗？）若已在集合里，则"),n("code",[e._v("get()")]),e._v("方法获得那个键关联的值，此时是一个"),n("code",[e._v("Counter")]),e._v("（计数器）对象。计数器内的值"),n("code",[e._v("i")]),e._v("随后会增加1，表明这个特定的随机数字又出现了一次。")]),e._v(" "),n("p",[e._v("假如键以前尚未发现过，那么方法"),n("code",[e._v("put()")]),e._v("仍然会在散列表内置入一个新的“键－值”对。在创建之初，"),n("code",[e._v("Counter")]),e._v("会自己的变量"),n("code",[e._v("i")]),e._v("自动初始化为1，它标志着该随机数字的第一次出现。")]),e._v(" "),n("p",[e._v("为显示散列表，只需把它简单地打印出来即可。"),n("code",[e._v("Hashtable toString()")]),e._v("方法能遍历所有键－值对，并为每一对都调用"),n("code",[e._v("toString()")]),e._v("。"),n("code",[e._v("Integer toString()")]),e._v("是事先定义好的，可看到计数器使用的"),n("code",[e._v("toString")]),e._v("。一次运行的结果（添加了一些换行）如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{19=526, 18=533, 17=460, 16=513, 15=521, 14=495,\n 13=512, 12=483, 11=488, 10=487, 9=514, 8=523,\n 7=497, 6=487, 5=480, 4=489, 3=509, 2=503, 1=475,\n 0=505}\n")])])]),n("p",[e._v("大家或许会对"),n("code",[e._v("Counter")]),e._v("类是否必要感到疑惑，它看起来似乎根本没有封装类"),n("code",[e._v("Integer")]),e._v("的功能。为什么不用"),n("code",[e._v("int")]),e._v("或"),n("code",[e._v("Integer")]),e._v("呢？事实上，由于所有集合能容纳的仅有对象引用，所以根本不可以使用整数。学过集合后，封装类的概念对大家来说就可能更容易理解了，因为不可以将任何基本数据类型置入集合里。然而，我们对Java包装器能做的唯一事情就是将其初始化成一个特定的值，然后读取那个值。也就是说，一旦包装器对象已经创建，就没有办法改变一个值。这使得"),n("code",[e._v("Integer")]),e._v("包装器对解决我们的问题毫无意义，所以不得不创建一个新类，用它来满足自己的要求。")]),e._v(" "),n("p",[e._v("(1) 创建“关键”类")]),e._v(" "),n("p",[e._v("在前面的例子里，我们用一个标准库的类（"),n("code",[e._v("Integer")]),e._v("）作为"),n("code",[e._v("Hashtable")]),e._v("的一个键使用。作为一个键，它能很好地工作，因为它已经具备正确运行的所有条件。但在使用散列表的时候，一旦我们创建自己的类作为键使用，就会遇到一个很常见的问题。例如，假设一套天气预报系统将"),n("code",[e._v("Groundhog")]),e._v("（土拔鼠）对象匹配成"),n("code",[e._v("Prediction")]),e._v("（预报）。这看起来非常直观：我们创建两个类，然后将"),n("code",[e._v("Groundhog")]),e._v("作为键使用，而将"),n("code",[e._v("Prediction")]),e._v("作为值使用。如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: SpringDetector.java\n// Looks plausible, but doesn\'t work right.\nimport java.util.*;\n\nclass Groundhog {\n  int ghNumber;\n  Groundhog(int n) { ghNumber = n; }\n}\n\nclass Prediction {\n  boolean shadow = Math.random() > 0.5;\n  public String toString() {\n    if(shadow)\n      return "Six more weeks of Winter!";\n    else\n      return "Early Spring!";\n  }\n}\n\npublic class SpringDetector {\n  public static void main(String[] args) {\n    Hashtable ht = new Hashtable();\n    for(int i = 0; i < 10; i++)\n      ht.put(new Groundhog(i), new Prediction());\n    System.out.println("ht = " + ht + "\\n");\n    System.out.println(\n      "Looking up prediction for groundhog #3:");\n    Groundhog gh = new Groundhog(3);\n    if(ht.containsKey(gh))\n      System.out.println((Prediction)ht.get(gh));\n  }\n} ///:~\n')])])]),n("p",[e._v("每个"),n("code",[e._v("Groundhog")]),e._v("都具有一个标识号码，所以赤了在散列表中查找一个"),n("code",[e._v("Prediction")]),e._v("，只需指示它“告诉我与"),n("code",[e._v("Groundhog")]),e._v("号码3相关的"),n("code",[e._v("Prediction")]),e._v("”。"),n("code",[e._v("Prediction")]),e._v("类包含了一个布尔值，用"),n("code",[e._v("Math.random()")]),e._v("进行初始化，以及一个"),n("code",[e._v("toString()")]),e._v("为我们解释结果。在"),n("code",[e._v("main()")]),e._v("中，用"),n("code",[e._v("Groundhog")]),e._v("以及与它们相关的"),n("code",[e._v("Prediction")]),e._v("填充一个散列表。散列表被打印出来，以便我们看到它们确实已被填充。随后，用标识号码为3的一个"),n("code",[e._v("Groundhog")]),e._v("查找与"),n("code",[e._v("Groundhog #3")]),e._v("对应的预报。")]),e._v(" "),n("p",[e._v("看起来似乎非常简单，但实际是不可行的。问题在于"),n("code",[e._v("Groundhog")]),e._v("是从通用的"),n("code",[e._v("Object")]),e._v("根类继承的（若当初未指定基类，则所有类最终都是从"),n("code",[e._v("Object")]),e._v("继承的）。事实上是用"),n("code",[e._v("Object")]),e._v("的"),n("code",[e._v("hashCode()")]),e._v("方法生成每个对象的散列码，而且默认情况下只使用它的对象的地址。所以，"),n("code",[e._v("Groundhog(3)")]),e._v("的第一个实例并不会产生与"),n("code",[e._v("Groundhog(3)")]),e._v("第二个实例相等的散列码，而我们用第二个实例进行检索。")]),e._v(" "),n("p",[e._v("大家或许认为此时要做的全部事情就是正确地覆盖"),n("code",[e._v("hashCode()")]),e._v("。但这样做依然行不能，除非再做另一件事情：覆盖也属于"),n("code",[e._v("Object")]),e._v("一部分的"),n("code",[e._v("equals()")]),e._v("。当散列表试图判断我们的键是否等于表内的某个键时，就会用到这个方法。同样地，默认的"),n("code",[e._v("Object.equals()")]),e._v("只是简单地比较对象地址，所以一个"),n("code",[e._v("Groundhog(3)")]),e._v("并不等于另一个"),n("code",[e._v("Groundhog(3)")]),e._v("。")]),e._v(" "),n("p",[e._v("因此，为了在散列表中将自己的类作为键使用，必须同时覆盖"),n("code",[e._v("hashCode()")]),e._v("和"),n("code",[e._v("equals()")]),e._v("，就象下面展示的那样：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: SpringDetector2.java\n// If you create a class that\'s used as a key in\n// a Hashtable, you must override hashCode()\n// and equals().\nimport java.util.*;\n\nclass Groundhog2 {\n  int ghNumber;\n  Groundhog2(int n) { ghNumber = n; }\n  public int hashCode() { return ghNumber; }\n  public boolean equals(Object o) {\n    return (o instanceof Groundhog2)\n      && (ghNumber == ((Groundhog2)o).ghNumber);\n  }\n}\n\npublic class SpringDetector2 {\n  public static void main(String[] args) {\n    Hashtable ht = new Hashtable();\n    for(int i = 0; i < 10; i++)\n      ht.put(new Groundhog2(i),new Prediction());\n    System.out.println("ht = " + ht + "\\n");\n    System.out.println(\n      "Looking up prediction for groundhog #3:");\n    Groundhog2 gh = new Groundhog2(3);\n    if(ht.containsKey(gh))\n      System.out.println((Prediction)ht.get(gh));\n  }\n} ///:~\n')])])]),n("p",[e._v("注意这段代码使用了来自前一个例子的"),n("code",[e._v("Prediction")]),e._v("，所以"),n("code",[e._v("SpringDetector.java")]),e._v("必须首先编译，否则就会在试图编译"),n("code",[e._v("SpringDetector2.java")]),e._v("时得到一个编译期错误。")]),e._v(" "),n("p",[n("code",[e._v("Groundhog2.hashCode()")]),e._v("将土拔鼠号码作为一个标识符返回（在这个例子中，程序员需要保证没有两个土拔鼠用同样的ID号码并存）。为了返回一个独一无二的标识符，并不需要"),n("code",[e._v("hashCode()")]),e._v("，"),n("code",[e._v("equals()")]),e._v("方法必须能够严格判断两个对象是否相等。")]),e._v(" "),n("p",[n("code",[e._v("equals()")]),e._v("方法要进行两种检查：检查对象是否为"),n("code",[e._v("null")]),e._v("；若不为"),n("code",[e._v("null")]),e._v("，则继续检查是否为"),n("code",[e._v("Groundhog2")]),e._v("的一个实例（要用到"),n("code",[e._v("instanceof")]),e._v("关键字，第11章会详加论述）。即使为了继续执行"),n("code",[e._v("equals()")]),e._v("，它也应该是一个"),n("code",[e._v("Groundhog2")]),e._v("。正如大家看到的那样，这种比较建立在实际"),n("code",[e._v("ghNumber")]),e._v("的基础上。这一次一旦我们运行程序，就会看到它终于产生了正确的输出（许多Java库的类都覆盖了"),n("code",[e._v("hashcode()")]),e._v("和"),n("code",[e._v("equals()")]),e._v("方法，以便与自己提供的内容适应）。")]),e._v(" "),n("p",[e._v("(2) 属性："),n("code",[e._v("Hashtable")]),e._v("的一种类型")]),e._v(" "),n("p",[e._v("在本书的第一个例子中，我们使用了一个名为"),n("code",[e._v("Properties")]),e._v("（属性）的"),n("code",[e._v("Hashtable")]),e._v("类型。在那个例子中，下述程序行：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Properties p = System.getProperties();\np.list(System.out);\n")])])]),n("p",[e._v("调用了一个名为"),n("code",[e._v("getProperties()")]),e._v("的"),n("code",[e._v("static")]),e._v("方法，用于获得一个特殊的"),n("code",[e._v("Properties")]),e._v("对象，对系统的某些特征进行描述。"),n("code",[e._v("list()")]),e._v("属于"),n("code",[e._v("Properties")]),e._v("的一个方法，可将内容发给我们选择的任何流式输出。也有一个"),n("code",[e._v("save()")]),e._v("方法，可用它将属性列表写入一个文件，以便日后用"),n("code",[e._v("load()")]),e._v("方法读取。")]),e._v(" "),n("p",[e._v("尽管"),n("code",[e._v("Properties")]),e._v("类是从"),n("code",[e._v("Hashtable")]),e._v("继承的，但它也包含了一个散列表，用于容纳“默认”属性的列表。所以假如没有在主列表里找到一个属性，就会自动搜索默认属性。")]),e._v(" "),n("p",[n("code",[e._v("Properties")]),e._v("类亦可在我们的程序中使用（第17章的"),n("code",[e._v("ClassScanner.java")]),e._v("便是一例）。在Java库的用户文档中，往往可以找到更多、更详细的说明。")]),e._v(" "),n("h2",{attrs:{id:"_8-4-5-再论枚举器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-5-再论枚举器"}},[e._v("#")]),e._v(" 8.4.5 再论枚举器")]),e._v(" "),n("p",[e._v("我们现在可以开始演示"),n("code",[e._v("Enumeration")]),e._v("（枚举）的真正威力：将穿越一个序列的操作与那个序列的基础结构分隔开。在下面的例子里，"),n("code",[e._v("PrintData")]),e._v("类用一个"),n("code",[e._v("Enumeration")]),e._v("在一个序列中移动，并为每个对象都调用"),n("code",[e._v("toString()")]),e._v("方法。此时创建了两个不同类型的集合：一个"),n("code",[e._v("Vector")]),e._v("和一个"),n("code",[e._v("Hashtable")]),e._v("。并且在它们里面分别填充"),n("code",[e._v("Mouse")]),e._v("和"),n("code",[e._v("Hamster")]),e._v("对象（本章早些时候已定义了这些类；注意必须先编译"),n("code",[e._v("HamsterMaze.java")]),e._v("和"),n("code",[e._v("WorksAnyway.java")]),e._v("，否则下面的程序不能编译）。由于"),n("code",[e._v("Enumeration")]),e._v("隐藏了基层集合的结构，所以"),n("code",[e._v("PrintData")]),e._v("不知道或者不关心"),n("code",[e._v("Enumeration")]),e._v("来自于什么类型的集合：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//: Enumerators2.java\n// Revisiting Enumerations\nimport java.util.*;\n\nclass PrintData {\n  static void print(Enumeration e) {\n    while(e.hasMoreElements())\n      System.out.println(\n        e.nextElement().toString());\n  }\n}\n\nclass Enumerators2 {\n  public static void main(String[] args) {\n    Vector v = new Vector();\n    for(int i = 0; i < 5; i++)\n      v.addElement(new Mouse(i));\n\n    Hashtable h = new Hashtable();\n    for(int i = 0; i < 5; i++)\n      h.put(new Integer(i), new Hamster(i));\n\n    System.out.println("Vector");\n    PrintData.print(v.elements());\n    System.out.println("Hashtable");\n    PrintData.print(h.elements());\n  }\n} ///:~\n')])])]),n("p",[e._v("注意"),n("code",[e._v("PrintData.print()")]),e._v("利用了这些集合中的对象属于"),n("code",[e._v("Object")]),e._v("类这一事实，所以它调用了"),n("code",[e._v("toString()")]),e._v("。但在解决自己的实际问题时，经常都要保证自己的"),n("code",[e._v("Enumeration")]),e._v("穿越某种特定类型的集合。例如，可能要求集合中的所有元素都是一个Shape（几何形状），并含有"),n("code",[e._v("draw()")]),e._v("方法。若出现这种情况，必须从"),n("code",[e._v("Enumeration.nextElement()")]),e._v("返回的"),n("code",[e._v("Object")]),e._v("进行向下转换，以便产生一个"),n("code",[e._v("Shape")]),e._v("。")])])}),[],!1,null,null,null);t.default=o.exports}}]);