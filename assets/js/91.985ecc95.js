(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{489:function(e,n,o){"use strict";o.r(n);var r=o(56),v=Object(r.a)({},(function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"_16-2-观察器模式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_16-2-观察器模式"}},[e._v("#")]),e._v(" 16.2 观察器模式")]),e._v(" "),o("p",[e._v("观察器（"),o("code",[e._v("Observer")]),e._v("）模式解决的是一个相当普通的问题：由于某些对象的状态发生了改变，所以一组对象都需要更新，那么该如何解决？在Smalltalk的MVC（模型－视图－控制器）的“模型－视图”部分中，或在几乎等价的“文档－视图结构”中，大家可以看到这个问题。现在我们有一些数据（“文档”）以及多个视图，假定为一张图（"),o("code",[e._v("Plot")]),e._v("）和一个文本视图。若改变了数据，两个视图必须知道对自己进行更新，而那正是“观察器”要负责的工作。这是一种十分常见的问题，它的解决方案已包括进标准的"),o("code",[e._v("java.util")]),e._v("库中。")]),e._v(" "),o("p",[e._v("在Java中，有两种类型的对象用来实现观察器模式。其中，"),o("code",[e._v("Observable")]),e._v("类用于跟踪那些当发生一个改变时希望收到通知的所有个体——无论“状态”是否改变。如果有人说“好了，所有人都要检查自己，并可能要进行更新”，那么"),o("code",[e._v("Observable")]),e._v("类会执行这个任务——为列表中的每个“人”都调用"),o("code",[e._v("notifyObservers()")]),e._v("方法。"),o("code",[e._v("notifyObservers()")]),e._v("方法属于基类"),o("code",[e._v("Observable")]),e._v("的一部分。")]),e._v(" "),o("p",[e._v("在观察器模式中，实际有两个方面可能发生变化：观察对象的数量以及更新的方式。也就是说，观察器模式允许我们同时修改这两个方面，不会干扰围绕在它周围的其他代码。")]),e._v(" "),o("p",[e._v("下面这个例子类似于第14章的"),o("code",[e._v("ColorBoxes")]),e._v("示例。箱子（"),o("code",[e._v("Boxes")]),e._v("）置于一个屏幕网格中，每个都初始化一种随机的颜色。此外，每个箱子都“实现”（"),o("code",[e._v("implement")]),e._v("）了“观察器”（"),o("code",[e._v("Observer")]),e._v("）接口，而且随一个"),o("code",[e._v("Observable")]),e._v("对象进行了注册。若点击一个箱子，其他所有箱子都会收到一个通知，指出一个改变已经发生。这是由于"),o("code",[e._v("Observable")]),e._v("对象会自动调用每个"),o("code",[e._v("Observer")]),e._v("对象的"),o("code",[e._v("update()")]),e._v("方法。在这个方法内，箱子会检查被点中的那个箱子是否与自己紧邻。若答案是肯定的，那么也修改自己的颜色，保持与点中那个箱子的协调。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("//: BoxObserver.java\n// Demonstration of Observer pattern using\n// Java's built-in observer classes.\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\n\n// You must inherit a new type of Observable:\nclass BoxObservable extends Observable {\n  public void notifyObservers(Object b) {\n    // Otherwise it won't propagate changes:\n    setChanged();\n    super.notifyObservers(b);\n  }\n}\n\npublic class BoxObserver extends Frame {\n  Observable notifier = new BoxObservable();\n  public BoxObserver(int grid) {\n    setTitle(\"Demonstrates Observer pattern\");\n    setLayout(new GridLayout(grid, grid));\n    for(int x = 0; x < grid; x++)\n      for(int y = 0; y < grid; y++)\n        add(new OCBox(x, y, notifier));\n  }   \n  public static void main(String[] args) {\n    int grid = 8;\n    if(args.length > 0)\n      grid = Integer.parseInt(args[0]);\n    Frame f = new BoxObserver(grid);\n    f.setSize(500, 400);\n    f.setVisible(true);\n    f.addWindowListener(\n      new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n          System.exit(0);\n        }\n      });\n  }\n}\n\nclass OCBox extends Canvas implements Observer {\n  Observable notifier;\n  int x, y; // Locations in grid\n  Color cColor = newColor();\n  static final Color[] colors = {\n    Color.black, Color.blue, Color.cyan,\n    Color.darkGray, Color.gray, Color.green,\n    Color.lightGray, Color.magenta,\n    Color.orange, Color.pink, Color.red,\n    Color.white, Color.yellow\n  };\n  static final Color newColor() {\n    return colors[\n      (int)(Math.random() * colors.length)\n    ];\n  }\n  OCBox(int x, int y, Observable notifier) {\n    this.x = x;\n    this.y = y;\n    notifier.addObserver(this);\n    this.notifier = notifier;\n    addMouseListener(new ML());\n  }\n  public void paint(Graphics  g) {\n    g.setColor(cColor);\n    Dimension s = getSize();\n    g.fillRect(0, 0, s.width, s.height);\n  }\n  class ML extends MouseAdapter {\n    public void mousePressed(MouseEvent e) {\n      notifier.notifyObservers(OCBox.this);\n    }\n  }\n  public void update(Observable o, Object arg) {\n    OCBox clicked = (OCBox)arg;\n    if(nextTo(clicked)) {\n      cColor = clicked.cColor;\n      repaint();\n    }\n  }\n  private final boolean nextTo(OCBox b) {\n    return Math.abs(x - b.x) <= 1 &&\n           Math.abs(y - b.y) <= 1;\n  }\n} ///:~\n")])])]),o("p",[e._v("如果是首次查阅"),o("code",[e._v("Observable")]),e._v("的联机帮助文档，可能会多少感到有些困惑，因为它似乎表明可以用一个原始的"),o("code",[e._v("Observable")]),e._v("对象来管理更新。但这种说法是不成立的；大家可自己试试——在"),o("code",[e._v("BoxObserver")]),e._v("中，创建一个"),o("code",[e._v("Observable")]),e._v("对象，替换"),o("code",[e._v("BoxObservable")]),e._v("对象，看看会有什么事情发生。事实上，什么事情也不会发生。为真正产生效果，必须从"),o("code",[e._v("Observable")]),e._v("继承，并在派生类代码的某个地方调用"),o("code",[e._v("setChanged()")]),e._v("。这个方法需要设置"),o("code",[e._v("changed")]),e._v("（已改变）标志，它意味着当我们调用"),o("code",[e._v("notifyObservers()")]),e._v("的时候，所有观察器事实上都会收到通知。在上面的例子中，"),o("code",[e._v("setChanged()")]),e._v("只是简单地在"),o("code",[e._v("notifyObservers()")]),e._v("中调用，大家可依据符合实际情况的任何标准决定何时调用"),o("code",[e._v("setChanged()")]),e._v("。")]),e._v(" "),o("p",[o("code",[e._v("BoxObserver")]),e._v("包含了单个"),o("code",[e._v("Observable")]),e._v("对象，名为"),o("code",[e._v("notifier")]),e._v("。每次创建一个"),o("code",[e._v("OCBox")]),e._v("对象时，它都会同"),o("code",[e._v("notifier")]),e._v("联系到一起。在"),o("code",[e._v("OCBox")]),e._v("中，只要点击鼠标，就会发出对"),o("code",[e._v("notifyObservers()")]),e._v("方法的调用，并将被点中的那个对象作为一个参数传递进去，使收到消息（用它们的"),o("code",[e._v("update()")]),e._v("方法）的所有箱子都能知道谁被点中了，并据此判断自己是否也要变动。通过"),o("code",[e._v("notifyObservers()")]),e._v("和"),o("code",[e._v("update()")]),e._v("中的代码的结合，我们可以应付一些非常复杂的局面。")]),e._v(" "),o("p",[e._v("在"),o("code",[e._v("notifyObservers()")]),e._v("方法中，表面上似乎观察器收到通知的方式必须在编译期间固定下来。然而，只要稍微仔细研究一下上面的代码，就会发现"),o("code",[e._v("BoxObserver")]),e._v("或"),o("code",[e._v("OCBox")]),e._v("中唯一需要留意是否使用"),o("code",[e._v("BoxObservable")]),e._v("的地方就是创建"),o("code",[e._v("Observable")]),e._v("对象的时候——从那时开始，所有东西都会使用基本的"),o("code",[e._v("Observable")]),e._v("接口。这意味着以后若想更改通知方式，可以继承其他"),o("code",[e._v("Observable")]),e._v("类，并在运行期间交换它们。")])])}),[],!1,null,null,null);n.default=v.exports}}]);