(window.webpackJsonp=window.webpackJsonp||[]).push([[138],{534:function(n,t,e){"use strict";e.r(t);var a=e(56),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_6-1-組合的语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-組合的语法"}},[n._v("#")]),n._v(" 6.1 組合的语法")]),n._v(" "),e("p",[n._v("就以前的学习情况来看，事实上已进行了多次“组合”操作。为进行组合，我们只需在新类里简单地置入对象引用即可。举个例子来说，假定需要在一个对象里容纳几个"),e("code",[n._v("String")]),n._v("对象、两种基本数据类型以及属于另一个类的一个对象。对于非基本类型的对象来说，只需将引用置于新类即可；而对于基本数据类型来说，则需在自己的类中定义它们。如下所示（若执行该程序时有麻烦，请参见第3章3.1.2小节“赋值”）：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//: SprinklerSystem.java\n// Composition for code reuse\npackage c06;\n\nclass WaterSource {\n  private String s;\n  WaterSource() {\n    System.out.println("WaterSource()");\n    s = new String("Constructed");\n  }\n  public String toString() { return s; }\n}\n\npublic class SprinklerSystem {\n  private String valve1, valve2, valve3, valve4;\n  WaterSource source;\n  int i;\n  float f;\n  void print() {\n    System.out.println("valve1 = " + valve1);\n    System.out.println("valve2 = " + valve2);\n    System.out.println("valve3 = " + valve3);\n    System.out.println("valve4 = " + valve4);\n    System.out.println("i = " + i);\n    System.out.println("f = " + f);\n    System.out.println("source = " + source);\n  }\n  public static void main(String[] args) {\n    SprinklerSystem x = new SprinklerSystem();\n    x.print();\n  }\n} ///:~\n')])])]),e("p",[e("code",[n._v("WaterSource")]),n._v("内定义的一个方法是比较特别的："),e("code",[n._v("toString()")]),n._v("。大家不久就会知道，每种非基本类型的对象都有一个"),e("code",[n._v("toString()")]),n._v("方法。若编译器本来希望一个"),e("code",[n._v("String")]),n._v("，但却获得某个这样的对象，就会调用这个方法。所以在下面这个表达式中：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('System.out.println("source = " + source) ;\n')])])]),e("p",[n._v("编译器会发现我们试图向一个"),e("code",[n._v("WaterSource")]),n._v("添加一个"),e("code",[n._v("String")]),n._v("对象（"),e("code",[n._v("source =")]),n._v("）。这对它来说是不可接受的，因为我们只能将一个字符串“添加”到另一个字符串，所以它会说：“我要调用"),e("code",[n._v("toString()")]),n._v("，把"),e("code",[n._v("source")]),n._v("转换成字符串！”经这样处理后，它就能编译两个字符串，并将结果字符串传递给一个"),e("code",[n._v("System.out.println()")]),n._v("。每次随同自己创建的一个类允许这种行为的时候，都只需要写一个"),e("code",[n._v("toString()")]),n._v("方法。")]),n._v(" "),e("p",[n._v("如果不深究，可能会草率地认为编译器会为上述代码中的每个引用都自动构造对象（由于Java的安全和谨慎的形象）。例如，可能以为它会为"),e("code",[n._v("WaterSource")]),n._v("调用默认构造器，以便初始化"),e("code",[n._v("source")]),n._v("。打印语句的输出事实上是：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("valve1 = null\nvalve2 = null\nvalve3 = null\nvalve4 = null\ni = 0\nf = 0.0\nsource = null\n")])])]),e("p",[n._v("在类内作为字段使用的基本数据会初始化成零，就象第2章指出的那样。但对象引用会初始化成"),e("code",[n._v("null")]),n._v("。而且假若试图为它们中的任何一个调用方法，就会产生一次“异常”。这种结果实际是相当好的（而且很有用），我们可在不丢弃一次异常的前提下，仍然把它们打印出来。")]),n._v(" "),e("p",[n._v("编译器并不只是为每个引用创建一个默认对象，因为那样会在许多情况下招致不必要的开销。如希望引用得到初始化，可在下面这些地方进行：")]),n._v(" "),e("p",[n._v("(1) 在对象定义的时候。这意味着它们在构造器调用之前肯定能得到初始化。")]),n._v(" "),e("p",[n._v("(2) 在那个类的构造器中。")]),n._v(" "),e("p",[n._v("(3) 紧靠在要求实际使用那个对象之前。这样做可减少不必要的开销——假如对象并不需要创建的话。")]),n._v(" "),e("p",[n._v("下面向大家展示了所有这三种方法：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//: Bath.java\n// Constructor initialization with composition\n\nclass Soap {\n  private String s;\n  Soap() {\n    System.out.println("Soap()");\n    s = new String("Constructed");\n  }\n  public String toString() { return s; }\n}\n\npublic class Bath {\n  private String\n    // Initializing at point of definition:\n    s1 = new String("Happy"),\n    s2 = "Happy",\n    s3, s4;\n  Soap castille;\n  int i;\n  float toy;\n  Bath() {\n    System.out.println("Inside Bath()");\n    s3 = new String("Joy");\n    i = 47;\n    toy = 3.14f;\n    castille = new Soap();\n  }\n  void print() {\n    // Delayed initialization:\n    if(s4 == null)\n      s4 = new String("Joy");\n    System.out.println("s1 = " + s1);\n    System.out.println("s2 = " + s2);\n    System.out.println("s3 = " + s3);\n    System.out.println("s4 = " + s4);\n    System.out.println("i = " + i);\n    System.out.println("toy = " + toy);\n    System.out.println("castille = " + castille);\n  }\n  public static void main(String[] args) {\n    Bath b = new Bath();\n    b.print();\n  }\n} ///:~\n')])])]),e("p",[n._v("请注意在"),e("code",[n._v("Bath")]),n._v("构造器中，在所有初始化开始之前执行了一个语句。如果不在定义时进行初始化，仍然不能保证能在将一条消息发给一个对象引用之前会执行任何初始化——除非出现不可避免的运行期异常。\n下面是该程序的输出：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Inside Bath()\nSoap()\ns1 = Happy\ns2 = Happy\ns3 = Joy\ns4 = Joy\ni = 47\ntoy = 3.14\ncastille = Constructed\n")])])]),e("p",[n._v("调用"),e("code",[n._v("print()")]),n._v("时，它会填充"),e("code",[n._v("s4")]),n._v("，使所有字段在使用之前都获得正确的初始化。")])])}),[],!1,null,null,null);t.default=s.exports}}]);